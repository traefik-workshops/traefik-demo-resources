---
apiVersion: v1
kind: ConfigMap
metadata:
  name: gov-mcp-server
  namespace: gov
  labels:
    {{- include "gov.labels" . | nindent 4 }}
    component: mcp
data:
  main.py: |
    #!/usr/bin/env python3
    """
    Government MCP Server - Emergency Response and Infrastructure Control
    """

    from typing import Any, Dict, List, Optional
    import logging, aiohttp, anyio
    from mcp.server import Server
    from mcp.server.stdio import stdio_server
    from mcp.types import Tool

    # Configure logging
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger("gov-mcp")

    # Create MCP server instance
    server = Server("gov-mcp")

    # API Configuration
    API_BASE_URLS = {
        "police": "http://police-app.gov.svc.cluster.local:3000",
        "utility": "http://utility-app.gov.svc.cluster.local:3000",
        "public_works": "http://public-works-app.gov.svc.cluster.local:3000",
    }
    KEYCLOAK_URL = "http://keycloak-service.traefik-security.svc.cluster.local:8080/realms/traefik/protocol/openid-connect/token"
    KEYCLOAK_CREDENTIALS = {
        "client_id": "traefik",
        "grant_type": "password",
        "client_secret": "{{ .Values.keycloak.clientSecret }}",
        "scope": "openid",
        "username": "{{ .Values.keycloak.adminUsername }}",
        "password": "{{ .Values.keycloak.adminPassword }}",
    }

    jwt_token: Optional[str] = None

    # Area mappings for client-side filtering
    AREA_MAPPINGS = {
        "downtown": ["Main St", "Oak Ave", "City Hall", "Oak Ave & Main St"],
        "north_side": ["Northwood District", "Elm St", "2nd Ave", "Elm St & 2nd Ave"],
        "waterfront": ["Pine St", "1st St", "Pine St & 1st St"],
        "central": ["Maple St", "4th St", "Maple St & 4th St"]
    }

    def get_valid_areas():
        """Get list of valid area names"""
        return list(AREA_MAPPINGS.keys())

    def location_in_area(location: str, area: str) -> bool:
        """Check if a location belongs to a specific area"""
        if area not in AREA_MAPPINGS:
            return False
        area_locations = AREA_MAPPINGS[area]
        # Check if location contains any of the area's streets/locations
        location_lower = location.lower()
        for area_loc in area_locations:
            if area_loc.lower() in location_lower:
                return True
        return False

    @server.list_tools()
    async def list_tools():
        """List available tools"""
        return [
            Tool(
                name="ping",
                description="Return a simple text response",
                inputSchema={"type":"object","properties":{}}
            ),
            Tool(
                name="list_areas",
                description="Get a list of all monitored areas and their coverage boundaries",
                inputSchema={"type":"object","properties":{}}
            ),
            Tool(
                name="emergency_status_summary",
                description="Get a quick summary of all emergency situations across the city",
                inputSchema={"type":"object","properties":{}}
            ),
            Tool(
                name="rescue_mission",
                description="Analyze road conditions and safety status by combining police incident reports and utility infrastructure data to help plan rescue operations",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "area": {
                            "type": "string", 
                            "enum": ["downtown", "north_side", "waterfront", "central"],
                            "description": "Area or district to check. Use 'list_areas' tool to see all valid areas."
                        },
                        "incident_type": {
                            "type": "string",
                            "enum": ["flood", "fire", "accident", "infrastructure_failure", "all"],
                            "description": "Type of incidents to check for. Optional, defaults to 'all'."
                        }
                    },
                    "required": ["area"],
                },
            ),
            Tool(
                name="floodgate_control",
                description="Control floodgate operations at dam locations to manage water levels and prevent flooding",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "dam_location": {
                            "type": "string",
                            "enum": ["north_dam", "south_dam", "east_dam", "central_dam"],
                            "description": "Dam location identifier (north_dam: Northern Regional, south_dam: Southern Regional, east_dam: Eastern Regional, central_dam: Central Regional)"
                        },
                        "action": {
                            "type": "string",
                            "enum": ["open", "close"],
                            "description": "Floodgate action to perform"
                        },
                        "reason": {
                            "type": "string",
                            "description": "Reason for floodgate adjustment (required for audit trail)"
                        }
                    },
                    "required": ["dam_location", "action", "reason"],
                },
            ),
            Tool(
                name="list_all_road_closures",
                description="Get a list of all current road closures and their status. Useful for browsing all road conditions.",
                inputSchema={"type": "object", "properties": {}}
            ),
            Tool(
                name="list_all_incidents",
                description="Get a list of all active police incidents. Useful for browsing all emergency situations.",
                inputSchema={"type": "object", "properties": {}}
            ),
            Tool(
                name="list_all_outages",
                description="Get a list of all power outages and their status. Useful for browsing all utility issues.",
                inputSchema={"type": "object", "properties": {}}
            ),
            Tool(
                name="list_all_infrastructure",
                description="Get a list of all infrastructure status including substations, pumps, and transformers.",
                inputSchema={"type": "object", "properties": {}}
            ),
            Tool(
                name="list_all_dams",
                description="Get a list of all dam floodgate statuses. Useful for monitoring regional water management.",
                inputSchema={"type": "object", "properties": {}}
            ),
            Tool(
                name="get_road_closure_details",
                description="Get detailed information about a specific road closure by street name.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "street_name": {"type": "string", "description": "The street name to get details for"}
                    },
                    "required": ["street_name"]
                }
            ),
            Tool(
                name="get_incident_details",
                description="Get detailed information about a specific police incident by incident ID.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "incident_id": {"type": "string", "description": "The incident ID (e.g., 'INC-2024-1547')"}
                    },
                    "required": ["incident_id"]
                }
            ),
            Tool(
                name="get_outage_details",
                description="Get detailed information about a power outage at a specific location.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "location": {"type": "string", "description": "The location to check for power outage"}
                    },
                    "required": ["location"]
                }
            ),
            Tool(
                name="get_dam_status",
                description="Get the current status of a specific dam's floodgates.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "dam_location": {
                            "type": "string",
                            "enum": ["north_dam", "south_dam", "east_dam", "central_dam"],
                            "description": "Dam location identifier"
                        }
                    },
                    "required": ["dam_location"]
                }
            )
        ]

    async def get_jwt_token() -> str:
        global jwt_token
        if jwt_token:
            return jwt_token
        async with aiohttp.ClientSession() as session:
            async with session.post(
                KEYCLOAK_URL,
                data=KEYCLOAK_CREDENTIALS,
                headers={"Content-Type": "application/x-www-form-urlencoded"},
            ) as r:
                if r.status != 200:
                    raise RuntimeError(f"Keycloak token error: {r.status}")
                data = await r.json()
                jwt_token = data.get("access_token")
                return jwt_token

    async def api_request(service: str, endpoint: str, method: str = "GET", data: Dict | None = None) -> Dict:
        token = await get_jwt_token()
        url = f"{API_BASE_URLS[service]}{endpoint}"
        headers = {"Authorization": f"Bearer {token}"}
        if method == "POST":
            headers["Content-Type"] = "application/json"
        async with aiohttp.ClientSession() as session:
            async with session.request(method, url, headers=headers, json=data) as r:
                if r.status == 200:
                    try:
                        return await r.json()
                    except Exception as e:
                        # If JSON parsing fails, try manual parsing (handles text/plain with JSON content)
                        text_response = await r.text()
                        logger.info(f"aiohttp JSON parsing failed for {url}. Content-Type: {r.headers.get('content-type')}. Trying manual parsing...")
                        try:
                            import json
                            parsed_json = json.loads(text_response)
                            logger.info(f"Manual JSON parsing successful for {url}: {parsed_json}")
                            return parsed_json
                        except Exception as json_error:
                            logger.error(f"Manual JSON parsing also failed for {url}. Response: {text_response}")
                            return {"error": f"Invalid JSON response: {text_response}", "status": r.status, "content_type": r.headers.get('content-type')}
                if r.status == 404:
                    return {"error": "Not found", "status": 404}
                # Get response text for error cases
                error_text = await r.text()
                return {"error": f"API error {r.status}: {error_text}", "status": r.status}

    # Police API endpoints
    async def get_police_incidents() -> Dict:
        logger.info(f"Fetching all police incidents")
        return await api_request("police", f"/incidents")
    
    async def get_police_incident_by_id(incident_id: str) -> Dict:
        logger.info(f"Fetching police incident {incident_id}")
        incidents = await get_police_incidents()
        if incident_id in incidents:
            return incidents[incident_id]
        return {"error": "Incident not found", "status": 404}

    async def get_road_closures() -> Dict:
        logger.info(f"Fetching all road closures")
        result = await api_request("police", f"/road_closures")
        # Convert array response to expected format
        if isinstance(result, list):
            closures = {}
            for item in result:
                road_id = item.get("id", "unknown")
                closures[road_id] = item
            return {"closures": closures}
        # Fallback for object format
        if "road_closures" in result:
            return {"closures": result["road_closures"]}
        return {"closures": result if isinstance(result, dict) else {}}
    
    async def get_road_closure_by_name(street_name: str) -> Dict:
        logger.info(f"Fetching road closure for {street_name}")
        return await api_request("police", f"/road_closures/{street_name}")
    
    async def get_police_areas() -> Dict:
        logger.info("Fetching all police areas")
        return await api_request("police", "/areas")

    # Utility API endpoints
    async def get_infrastructure_status() -> Dict:
        logger.info(f"Fetching all infrastructure status")
        return await api_request("utility", f"/infrastructure/status")

    async def get_power_outages() -> Dict:
        logger.info(f"Fetching all power outages")
        result = await api_request("utility", f"/outages")
        # Convert array response to expected format
        if isinstance(result, list):
            outages = {}
            for item in result:
                location_id = item.get("id", "unknown")
                outages[location_id] = item
            return {"outages": outages}
        # Fallback for object format
        if "outages" in result:
            return {"outages": result["outages"]}
        return {"outages": result if isinstance(result, dict) else {}}
    
    async def get_power_outage_by_location(location: str) -> Dict:
        logger.info(f"Fetching power outage for {location}")
        return await api_request("utility", f"/outages/{location}")
    
    async def get_utility_areas() -> Dict:
        logger.info("Fetching all utility areas")
        return await api_request("utility", "/areas")

    # Public Works API endpoints
    async def get_floodgate_status(dam_location: str) -> Dict:
        logger.info(f"Fetching floodgate status for: {dam_location}")
        return await api_request("public_works", f"/dams/{dam_location}")

    async def control_floodgate(dam_location: str, action: str) -> Dict:
        logger.info(f"Controlling floodgate at {dam_location}: {action}")
        data = {"action": action}
        return await api_request("public_works", f"/dams/{dam_location}/floodgates/control", "POST", data)

    async def get_all_dams() -> Dict:
        logger.info("Fetching all dam statuses")
        return await api_request("public_works", "/dams")

    def analyze_road_conditions(police_data: Dict, utility_data: Dict, area: str = None) -> Dict:
        """Analyze combined data to determine road conditions and safety, optionally filtered by area"""
        conditions = {
            "safe_routes": [],
            "dangerous_areas": [],
            "blocked_roads": [],
            "warnings": [],
            "recommendations": [],
            "area_filter": area
        }
        
        # Process road closures
        if "closures" in police_data:
            for road_name, closure_info in police_data["closures"].items():
                # Filter by area if specified
                if area and not location_in_area(road_name, area):
                    continue
                    
                conditions["blocked_roads"].append({
                    "road": road_name,
                    "reason": closure_info.get("reason", "unknown"),
                    "status": closure_info.get("status", "unknown"),
                    "from_street": closure_info.get("from_street", ""),
                    "to_street": closure_info.get("to_street", "")
                })
                
                if closure_info.get("status") == "Closed":
                    conditions["dangerous_areas"].append({
                        "location": road_name,
                        "reason": f"Road Closed - {closure_info.get('reason', 'unknown')}",
                        "source": "police"
                    })
        
        # Process power outages
        if "outages" in utility_data:
            for location, outage_info in utility_data["outages"].items():
                # Filter by area if specified
                if area and not location_in_area(location, area):
                    continue
                    
                status = outage_info.get("status", "unknown")
                hazard = outage_info.get("hazard", "None")
                
                if status == "Outage Confirmed":
                    conditions["warnings"].append(f"Power outage at {location}: {hazard}")
                    if hazard != "None" and hazard != "Unknown":
                        conditions["dangerous_areas"].append({
                            "location": location,
                            "reason": f"Power Outage - {hazard}",
                            "source": "utility"
                        })
        
        # Process infrastructure issues (placeholder for when API provides this)
        if "infrastructure" in utility_data:
            for item in utility_data["infrastructure"]:
                if area and not location_in_area(item.get("location", ""), area):
                    continue
                if item.get("status") == "failed":
                    conditions["warnings"].append(f"Infrastructure failure: {item.get('type')} at {item.get('location')}")
        
        # Generate recommendations
        if conditions["dangerous_areas"]:
            conditions["recommendations"].append("Avoid marked dangerous areas")
        if conditions["blocked_roads"]:
            conditions["recommendations"].append("Use alternative routes around blocked roads")
        if conditions["warnings"]:
            conditions["recommendations"].append("Exercise caution due to infrastructure issues")
        
        return conditions

    @server.call_tool()
    async def call_tool(name: str, arguments: dict):
        """Handle tool calls - return as list to prevent dict.items() issues"""
        logger.info(f"Tool called: {name} with args: {arguments}")
        
        if name == "ping":
            return [{"type": "text", "text": "pong"}]
        
        elif name == "list_areas":
            try:
                response = "üó∫Ô∏è **MONITORED AREAS**\n\n"
                for area_name, locations in AREA_MAPPINGS.items():
                    response += f"**{area_name.upper()}:**\n"
                    for location in locations:
                        response += f"‚Ä¢ {location}\n"
                    response += "\n"
                response += "Use these area names with the 'rescue_mission' tool to get targeted analysis."
                return [{"type": "text", "text": response}]
            except Exception as e:
                logger.error(f"Error in list_areas: {e}")
                return [{"type": "text", "text": f"‚ùå Error listing areas: {str(e)}"}]
        
        elif name == "emergency_status_summary":
            try:
                steps = []
                steps.append("üåç Generating city-wide emergency status summary...")
                
                # Fetch all data without area filtering
                steps.append("üìä Fetching police and utility data...")
                road_closures = await get_road_closures()
                outages = await get_power_outages()
                
                # Analyze all data
                analysis = analyze_road_conditions(road_closures, outages)
                
                # Build summary response
                response = "üö® **CITY-WIDE EMERGENCY STATUS SUMMARY**\n\n"
                
                # Critical Issues Count
                critical_count = len(analysis["dangerous_areas"])
                blocked_roads_count = len(analysis["blocked_roads"])
                warnings_count = len(analysis["warnings"])
                
                response += f"**üî¥ Critical Issues:** {critical_count}\n"
                response += f"**üöß Blocked Roads:** {blocked_roads_count}\n"
                response += f"**‚ö†Ô∏è Active Warnings:** {warnings_count}\n\n"
                
                # Quick overview by area
                response += "**STATUS BY AREA:**\n"
                for area_name in get_valid_areas():
                    area_analysis = analyze_road_conditions(road_closures, outages, area_name)
                    area_issues = len(area_analysis["dangerous_areas"]) + len(area_analysis["blocked_roads"])
                    if area_issues == 0:
                        response += f"üü¢ {area_name.upper()}: All Clear\n"
                    elif area_issues <= 2:
                        response += f"üü° {area_name.upper()}: {area_issues} issue(s)\n"
                    else:
                        response += f"üî¥ {area_name.upper()}: {area_issues} issues\n"
                
                response += "\n**For detailed analysis of specific areas, use the 'rescue_mission' tool.**\n"
                response += "\n**Process Steps:**\n" + "\n".join(steps)
                
                return [{"type": "text", "text": response}]
                
            except Exception as e:
                logger.error(f"Error in emergency_status_summary: {e}")
                return [{"type": "text", "text": f"‚ùå System error during summary: {str(e)}"}]
        
        elif name == "rescue_mission":
            area = arguments.get("area")
            incident_type = arguments.get("incident_type", "all")
            
            if not area:
                return [{"type": "text", "text": "Error: area is required"}]
            
            # Validate area
            if area not in get_valid_areas():
                valid_areas = ", ".join(get_valid_areas())
                return [{"type": "text", "text": f"‚ùå Invalid area '{area}'. Valid areas are: {valid_areas}. Use 'list_areas' tool to see details."}]
            
            try:
                steps = []
                steps.append("üö® Starting rescue mission analysis...")
                steps.append(f"üìç Target area: {area}")
                steps.append(f"üîç Incident filter: {incident_type}")
                
                # Gather data from all sources (no area filtering at API level)
                steps.append("\nüöî Fetching police data...")
                road_closures = await get_road_closures()
                
                steps.append("‚ö° Fetching utility infrastructure data...")
                outages = await get_power_outages()
                
                # Analyze combined data with area filtering
                steps.append("üßÆ Analyzing road conditions for target area...")
                analysis = analyze_road_conditions(road_closures, outages, area)
                
                # Build response message
                response = "üö® **RESCUE MISSION ANALYSIS**\n\n"
                response += f"**Area:** {area}\n"
                response += f"**Timestamp:** current\n\n"
                
                # Dangerous areas
                if analysis["dangerous_areas"]:
                    response += "‚õî **DANGEROUS AREAS:**\n"
                    for area_info in analysis["dangerous_areas"]:
                        response += f"‚Ä¢ {area_info['location']}: {area_info['reason']}\n"
                    response += "\n"
                
                # Blocked roads
                if analysis["blocked_roads"]:
                    response += "üöß **BLOCKED ROADS:**\n"
                    for road in analysis["blocked_roads"]:
                        clear_time = road.get('estimated_clear_time', 'Unknown')
                        response += f"‚Ä¢ {road['road']}: {road['reason']} (Status: {road.get('status', 'Unknown')})\n"
                    response += "\n"
                
                # Infrastructure warnings
                if analysis["warnings"]:
                    response += "‚ö†Ô∏è **INFRASTRUCTURE WARNINGS:**\n"
                    for warning in analysis["warnings"]:
                        response += f"‚Ä¢ {warning}\n"
                    response += "\n"
                
                # Safe routes (if any identified)
                if analysis["safe_routes"]:
                    response += "‚úÖ **SAFE ROUTES:**\n"
                    for route in analysis["safe_routes"]:
                        response += f"‚Ä¢ {route}\n"
                    response += "\n"
                
                # Recommendations
                response += "üìã **RECOMMENDATIONS:**\n"
                if analysis["recommendations"]:
                    for rec in analysis["recommendations"]:
                        response += f"‚Ä¢ {rec}\n"
                else:
                    response += "‚Ä¢ Area appears to be relatively safe for rescue operations\n"
                
                response += "\n**Analysis Steps:**\n" + "\n".join(steps)
                
                return [{"type": "text", "text": response}]
                
            except Exception as e:
                logger.error(f"Error in rescue mission analysis: {e}")
                return [{"type": "text", "text": f"‚ùå System error during analysis: {str(e)}"}]
        
        elif name == "floodgate_control":
            dam_location = arguments.get("dam_location")
            action = arguments.get("action")
            reason = arguments.get("reason")
            
            if not all([dam_location, action, reason]):
                return [{"type": "text", "text": "Error: dam_location, action, and reason are required"}]
            
            try:
                steps = []
                steps.append("üåä Starting floodgate control operation...")
                steps.append(f"üè≠ Target dam: {dam_location}")
                steps.append(f"‚öôÔ∏è Requested action: {action}")
                
                # Get current status first
                steps.append("üìä Checking current floodgate status...")
                current_status = await get_floodgate_status(dam_location)
                
                if "error" in current_status:
                    return [{"type": "text", "text": f"‚ùå Failed to get current status: {current_status['error']}"}]
                
                current_position = current_status.get("floodgate_status", "unknown")
                dam_name = current_status.get("name", "Unknown Dam")
                dam_location_name = current_status.get("location", "Unknown Location")
                last_action = current_status.get("last_action", "unknown")
                
                steps.append(f"üìç Current status: {current_position}")
                steps.append(f"üè≠ Dam: {dam_name} ({dam_location_name})")
                steps.append(f"üìÖ Last action: {last_action}")
                
                # Check if action is needed
                if action == "close" and current_position == "closed":
                    return [{"type": "text", "text": f"‚ÑπÔ∏è Floodgate at {dam_location} is already closed"}]
                elif action == "open" and current_position == "open":
                    return [{"type": "text", "text": f"‚ÑπÔ∏è Floodgate at {dam_location} is already open"}]
                
                # Get all dam statuses for context
                steps.append("üåä Checking regional dam statuses...")
                all_dams = await get_all_dams()
                
                # Execute floodgate control
                steps.append(f"üîß Executing floodgate {action}...")
                control_result = await control_floodgate(dam_location, action)
                
                if "error" in control_result:
                    msg = f"‚ùå Floodgate control failed: {control_result['error']}\n\n" + "\n".join(steps)
                    return [{"type": "text", "text": msg}]
                
                # Build success response
                response = "‚úÖ **FLOODGATE CONTROL SUCCESSFUL**\n\n"
                response += f"**Dam:** {dam_name} ({dam_location})\n"
                response += f"**Action Performed:** {action}\n"
                response += f"**Reason:** {reason}\n"
                response += f"**Operator:** System Administrator\n"
                response += f"**Status:** {control_result.get('status', 'unknown')}\n\n"
                
                response += "**Status Change:**\n"
                response += f"‚Ä¢ Previous: {current_position}\n"
                response += f"‚Ä¢ Current: {action}ed\n\n"
                
                response += "**Regional Dam Statuses:**\n"
                if isinstance(all_dams, dict):
                    for dam_id, dam_info in all_dams.items():
                        status_emoji = "üü¢" if dam_info.get("floodgate_status") == "open" else "üî¥" if dam_info.get("floodgate_status") == "closed" else "üü°"
                        response += f"{status_emoji} {dam_id}: {dam_info.get('name', 'Unknown')} ({dam_info.get('location', 'Unknown')}) - {dam_info.get('floodgate_status', 'unknown')}\n"
                
                response += f"\n**Audit Log:** Action recorded with reason: '{reason}'\n"
                response += "\n**Process Steps:**\n" + "\n".join(steps)
                
                return [{"type": "text", "text": response}]
                
            except Exception as e:
                logger.error(f"Error in floodgate control: {e}")
                return [{"type": "text", "text": f"‚ùå System error during floodgate control: {str(e)}"}]
        
        elif name == "list_all_road_closures":
            try:
                road_closures = await get_road_closures()
                if "error" in road_closures:
                    return [{"type": "text", "text": f"‚ùå Error fetching road closures: {road_closures['error']}"}]
                
                response = "üöî **ALL ROAD CLOSURES**\n\n"
                closures = road_closures.get("closures", {})
                response += f"**Total Roads:** {len(closures)}\n\n"
                
                for street_name, closure_info in closures.items():
                    status = closure_info.get("status", "Unknown")
                    reason = closure_info.get("reason", "Unknown")
                    area = closure_info.get("area", "Unknown")
                    
                    status_emoji = "üî¥" if status == "Closed" else "üü°" if status == "Restricted" else "üü¢"
                    response += f"{status_emoji} **{street_name}** ({area})\n"
                    response += f"   ‚Ä¢ Status: {status}\n"
                    response += f"   ‚Ä¢ Reason: {reason}\n\n"
                
                return [{"type": "text", "text": response}]
            except Exception as e:
                logger.error(f"Error listing road closures: {e}")
                return [{"type": "text", "text": f"‚ùå System error: {str(e)}"}]
        
        elif name == "list_all_incidents":
            try:
                incidents = await get_police_incidents()
                if "error" in incidents:
                    return [{"type": "text", "text": f"‚ùå Error fetching incidents: {incidents['error']}"}]
                
                response = "üö® **ALL POLICE INCIDENTS**\n\n"
                response += f"**Total Incidents:** {len(incidents)}\n\n"
                
                for incident_id, incident_info in incidents.items():
                    incident_type = incident_info.get("type", "unknown")
                    severity = incident_info.get("severity", "unknown")
                    location = incident_info.get("location", "Unknown")
                    area = incident_info.get("area", "Unknown")
                    
                    severity_emoji = "üî¥" if severity in ["critical", "major"] else "üü°" if severity in ["high", "medium"] else "üü¢"
                    response += f"{severity_emoji} **{incident_id}** - {incident_type}\n"
                    response += f"   ‚Ä¢ Severity: {severity}\n"
                    response += f"   ‚Ä¢ Location: {location} ({area})\n\n"
                
                return [{"type": "text", "text": response}]
            except Exception as e:
                logger.error(f"Error listing incidents: {e}")
                return [{"type": "text", "text": f"‚ùå System error: {str(e)}"}]
        
        elif name == "list_all_outages":
            try:
                outages = await get_power_outages()
                if "error" in outages:
                    return [{"type": "text", "text": f"‚ùå Error fetching outages: {outages['error']}"}]
                
                response = "‚ö° **ALL POWER OUTAGES**\n\n"
                outage_data = outages.get("outages", {})
                response += f"**Total Locations:** {len(outage_data)}\n\n"
                
                for location, outage_info in outage_data.items():
                    status = outage_info.get("status", "Unknown")
                    hazard = outage_info.get("hazard", "None")
                    area = outage_info.get("area", "Unknown")
                    affected = outage_info.get("affected_customers", 0)
                    
                    status_emoji = "üî¥" if status == "Outage Confirmed" else "üü°" if status == "Outage Reported" else "üü¢"
                    response += f"{status_emoji} **{location}** ({area})\n"
                    response += f"   ‚Ä¢ Status: {status}\n"
                    response += f"   ‚Ä¢ Hazard: {hazard}\n"
                    response += f"   ‚Ä¢ Affected Customers: {affected}\n\n"
                
                return [{"type": "text", "text": response}]
            except Exception as e:
                logger.error(f"Error listing outages: {e}")
                return [{"type": "text", "text": f"‚ùå System error: {str(e)}"}]
        
        elif name == "list_all_infrastructure":
            try:
                infrastructure = await get_infrastructure_status()
                if "error" in infrastructure:
                    return [{"type": "text", "text": f"‚ùå Error fetching infrastructure: {infrastructure['error']}"}]
                
                response = "üèóÔ∏è **ALL INFRASTRUCTURE STATUS**\n\n"
                response += f"**Total Infrastructure:** {len(infrastructure)}\n\n"
                
                for infra_id, infra_info in infrastructure.items():
                    infra_type = infra_info.get("type", "unknown")
                    location = infra_info.get("location", "Unknown")
                    status = infra_info.get("status", "unknown")
                    area = infra_info.get("area", "Unknown")
                    capacity = infra_info.get("capacity", "Unknown")
                    
                    status_emoji = "üü¢" if status == "operational" else "üî¥" if status == "failed" else "üü°"
                    response += f"{status_emoji} **{infra_id}** - {infra_type}\n"
                    response += f"   ‚Ä¢ Location: {location} ({area})\n"
                    response += f"   ‚Ä¢ Status: {status}\n"
                    response += f"   ‚Ä¢ Capacity: {capacity}\n\n"
                
                return [{"type": "text", "text": response}]
            except Exception as e:
                logger.error(f"Error listing infrastructure: {e}")
                return [{"type": "text", "text": f"‚ùå System error: {str(e)}"}]
        
        elif name == "list_all_dams":
            try:
                dams = await get_all_dams()
                if "error" in dams:
                    return [{"type": "text", "text": f"‚ùå Error fetching dams: {dams['error']}"}]
                
                response = "üåä **ALL DAM STATUSES**\n\n"
                response += f"**Total Dams:** {len(dams)}\n\n"
                
                for dam_id, dam_info in dams.items():
                    name = dam_info.get("name", "Unknown")
                    location = dam_info.get("location", "Unknown")
                    floodgate_status = dam_info.get("floodgate_status", "unknown")
                    last_action = dam_info.get("last_action", "Unknown")
                    
                    status_emoji = "üü¢" if floodgate_status == "open" else "üî¥" if floodgate_status == "closed" else "üü°"
                    response += f"{status_emoji} **{name}** ({dam_id})\n"
                    response += f"   ‚Ä¢ Location: {location}\n"
                    response += f"   ‚Ä¢ Floodgate: {floodgate_status}\n"
                    response += f"   ‚Ä¢ Last Action: {last_action}\n\n"
                
                return [{"type": "text", "text": response}]
            except Exception as e:
                logger.error(f"Error listing dams: {e}")
                return [{"type": "text", "text": f"‚ùå System error: {str(e)}"}]
        
        elif name == "get_road_closure_details":
            street_name = arguments.get("street_name")
            if not street_name:
                return [{"type": "text", "text": "Error: street_name is required"}]
            
            try:
                closure = await get_road_closure_by_name(street_name)
                if "error" in closure:
                    return [{"type": "text", "text": f"‚ùå Error: {closure['error']}"}]
                
                status = closure.get("status", "Unknown")
                reason = closure.get("reason", "Unknown")
                area = closure.get("area", "Unknown")
                closure_type = closure.get("closure_type", "Unknown")
                from_int = closure.get("from_intersection", "N/A")
                to_int = closure.get("to_intersection", "N/A")
                duration = closure.get("estimated_duration", "Unknown")
                notes = closure.get("notes", "None")
                
                response = f"üöî **ROAD CLOSURE DETAILS: {street_name}**\n\n"
                response += f"**Status:** {status}\n"
                response += f"**Reason:** {reason}\n"
                response += f"**Area:** {area}\n"
                response += f"**Closure Type:** {closure_type}\n"
                response += f"**From:** {from_int}\n"
                response += f"**To:** {to_int}\n"
                response += f"**Duration:** {duration}\n"
                response += f"**Notes:** {notes}\n"
                
                return [{"type": "text", "text": response}]
            except Exception as e:
                logger.error(f"Error getting road closure details: {e}")
                return [{"type": "text", "text": f"‚ùå System error: {str(e)}"}]
        
        elif name == "get_incident_details":
            incident_id = arguments.get("incident_id")
            if not incident_id:
                return [{"type": "text", "text": "Error: incident_id is required"}]
            
            try:
                incident = await get_police_incident_by_id(incident_id)
                if "error" in incident:
                    return [{"type": "text", "text": f"‚ùå Error: {incident['error']}"}]
                
                incident_type = incident.get("type", "unknown")
                severity = incident.get("severity", "unknown")
                location = incident.get("location", "Unknown")
                area = incident.get("area", "Unknown")
                timestamp = incident.get("timestamp", "Unknown")
                notes = incident.get("notes", "None")
                
                response = f"üö® **INCIDENT DETAILS: {incident_id}**\n\n"
                response += f"**Type:** {incident_type}\n"
                response += f"**Severity:** {severity}\n"
                response += f"**Location:** {location}\n"
                response += f"**Area:** {area}\n"
                response += f"**Timestamp:** {timestamp}\n"
                response += f"**Notes:** {notes}\n"
                
                # Add type-specific details
                if "vehicles_involved" in incident:
                    response += f"**Vehicles Involved:** {incident['vehicles_involved']}\n"
                if "injuries" in incident:
                    response += f"**Injuries:** {incident['injuries']}\n"
                if "case_status" in incident:
                    response += f"**Case Status:** {incident['case_status']}\n"
                
                return [{"type": "text", "text": response}]
            except Exception as e:
                logger.error(f"Error getting incident details: {e}")
                return [{"type": "text", "text": f"‚ùå System error: {str(e)}"}]
        
        elif name == "get_outage_details":
            location = arguments.get("location")
            if not location:
                return [{"type": "text", "text": "Error: location is required"}]
            
            try:
                outage = await get_power_outage_by_location(location)
                if "error" in outage:
                    return [{"type": "text", "text": f"‚ùå Error: {outage['error']}"}]
                
                status = outage.get("status", "Unknown")
                hazard = outage.get("hazard", "None")
                area = outage.get("area", "Unknown")
                affected = outage.get("affected_customers", 0)
                
                response = f"‚ö° **POWER OUTAGE DETAILS: {location}**\n\n"
                response += f"**Status:** {status}\n"
                response += f"**Hazard:** {hazard}\n"
                response += f"**Area:** {area}\n"
                response += f"**Affected Customers:** {affected}\n"
                
                return [{"type": "text", "text": response}]
            except Exception as e:
                logger.error(f"Error getting outage details: {e}")
                return [{"type": "text", "text": f"‚ùå System error: {str(e)}"}]
        
        elif name == "get_dam_status":
            dam_location = arguments.get("dam_location")
            if not dam_location:
                return [{"type": "text", "text": "Error: dam_location is required"}]
            
            try:
                dam = await get_floodgate_status(dam_location)
                if "error" in dam:
                    return [{"type": "text", "text": f"‚ùå Error: {dam['error']}"}]
                
                name = dam.get("name", "Unknown")
                location = dam.get("location", "Unknown")
                floodgate_status = dam.get("floodgate_status", "unknown")
                last_action = dam.get("last_action", "Unknown")
                
                response = f"üåä **DAM STATUS: {name}**\n\n"
                response += f"**Dam ID:** {dam_location}\n"
                response += f"**Location:** {location}\n"
                response += f"**Floodgate Status:** {floodgate_status}\n"
                response += f"**Last Action:** {last_action}\n"
                
                return [{"type": "text", "text": response}]
            except Exception as e:
                logger.error(f"Error getting dam status: {e}")
                return [{"type": "text", "text": f"‚ùå System error: {str(e)}"}]
        
        else:
            # For errors, still need to return proper structure
            return [{"type": "text", "text": f"Unknown tool: {name}"}]

    if __name__ == "__main__":
        from mcp.server.fastmcp import FastMCP
        import uvicorn
        
        # Convert low-level server to FastMCP for streamable-http support
        # json_response=True returns pure JSON instead of SSE format
        mcp_app = FastMCP("gov-mcp", stateless_http=True, json_response=True)
        
        # Re-register tools with FastMCP
        @mcp_app.tool()
        async def ping() -> str:
            """Return a simple text response"""
            return "pong"
        
        @mcp_app.tool()
        async def list_areas() -> str:
            """Get a list of all monitored areas"""
            response = "üó∫Ô∏è **MONITORED AREAS**\n\n"
            for area_name, locations in AREA_MAPPINGS.items():
                response += f"**{area_name.upper()}:**\n"
                for location in locations:
                    response += f"‚Ä¢ {location}\n"
                response += "\n"
            return response
        
        @mcp_app.tool()
        async def emergency_status_summary() -> str:
            """Get emergency status summary"""
            road_closures = await get_road_closures()
            outages = await get_power_outages()
            analysis = analyze_road_conditions(road_closures, outages)
            return f"üö® Critical: {len(analysis['dangerous_areas'])}, Blocked: {len(analysis['blocked_roads'])}"
        
        @mcp_app.tool()
        async def rescue_mission(area: str, incident_type: str = "all") -> str:
            """Analyze rescue mission for area"""
            if area not in get_valid_areas():
                return f"‚ùå Invalid area '{area}'"
            road_closures = await get_road_closures()
            outages = await get_power_outages()
            analysis = analyze_road_conditions(road_closures, outages, area)
            response = f"üö® **RESCUE MISSION: {area}**\n\n"
            response += f"Dangerous areas: {len(analysis['dangerous_areas'])}\n"
            response += f"Blocked roads: {len(analysis['blocked_roads'])}\n"
            return response
        
        @mcp_app.tool()
        async def floodgate_control(dam_location: str, action: str, reason: str) -> str:
            """Control floodgate operations"""
            valid_dams = ["north_dam", "south_dam", "east_dam", "central_dam"]
            if dam_location not in valid_dams:
                return f"‚ùå Invalid dam: {dam_location}"
            if action not in ["open", "close"]:
                return f"‚ùå Invalid action: {action}"
            current = await get_floodgate_status(dam_location)
            if "error" in current:
                return f"‚ùå Error: {current['error']}"
            result = await control_floodgate(dam_location, action)
            return f"‚úÖ Floodgate {action}ed at {dam_location}. Reason: {reason}"
        
        @mcp_app.tool()
        async def list_all_road_closures() -> str:
            """List all road closures"""
            data = await get_road_closures()
            if "error" in data:
                return f"‚ùå Error: {data['error']}"
            closures = data.get("closures", {})
            return f"üöî {len(closures)} road closures found"
        
        @mcp_app.tool()
        async def list_all_incidents() -> str:
            """List all police incidents"""
            data = await get_police_incidents()
            if "error" in data:
                return f"‚ùå Error: {data['error']}"
            return f"üö® {len(data)} incidents found"
        
        @mcp_app.tool()
        async def list_all_outages() -> str:
            """List all power outages"""
            data = await get_power_outages()
            if "error" in data:
                return f"‚ùå Error: {data['error']}"
            outages = data.get("outages", {})
            return f"‚ö° {len(outages)} outages found"
        
        @mcp_app.tool()
        async def list_all_infrastructure() -> str:
            """List all infrastructure"""
            data = await get_infrastructure_status()
            if "error" in data:
                return f"‚ùå Error: {data['error']}"
            return f"üèóÔ∏è {len(data)} infrastructure items found"
        
        @mcp_app.tool()
        async def list_all_dams() -> str:
            """List all dams"""
            data = await get_all_dams()
            if "error" in data:
                return f"‚ùå Error: {data['error']}"
            return f"üåä {len(data)} dams found"
        
        @mcp_app.tool()
        async def get_road_closure_details(street_name: str) -> str:
            """Get road closure details"""
            data = await get_road_closure_by_name(street_name)
            if "error" in data:
                return f"‚ùå Error: {data['error']}"
            return f"üöî {street_name}: {data.get('status', 'Unknown')}"
        
        @mcp_app.tool()
        async def get_incident_details(incident_id: str) -> str:
            """Get incident details"""
            data = await get_police_incident_by_id(incident_id)
            if "error" in data:
                return f"‚ùå Error: {data['error']}"
            return f"üö® {incident_id}: {data.get('type', 'Unknown')}"
        
        @mcp_app.tool()
        async def get_outage_details(location: str) -> str:
            """Get outage details"""
            data = await get_power_outage_by_location(location)
            if "error" in data:
                return f"‚ùå Error: {data['error']}"
            return f"‚ö° {location}: {data.get('status', 'Unknown')}"
        
        @mcp_app.tool()
        async def get_dam_status(dam_location: str) -> str:
            """Get dam status"""
            data = await get_floodgate_status(dam_location)
            if "error" in data:
                return f"‚ùå Error: {data['error']}"
            return f"üåä {data.get('name', 'Unknown')}: {data.get('floodgate_status', 'unknown')}"
        
        logger.info("Starting Government MCP Server with streamable-http...")
        # Use uvicorn directly to control host and port
        import uvicorn
        app = mcp_app.streamable_http_app()
        uvicorn.run(app, host="0.0.0.0", port=8080)

  requirements.txt: |
    mcp>=1.3.0
    uvicorn>=0.32.1
    aiohttp==3.9.1
    anyio==4.11.0
    httpx>=0.27.0

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: gov-mcp-server
  namespace: gov
  labels:
    {{- include "gov.labels" . | nindent 4 }}
    component: mcp
    app: gov-mcp-server
spec:
  replicas: 1
  selector:
    matchLabels:
      app: gov-mcp-server
  template:
    metadata:
      labels:
        {{- include "gov.labels" . | nindent 8 }}
        component: mcp
        app: gov-mcp-server
    spec:
      containers:
      - name: mcp-server
        image: python:3.11-slim
        ports:
        - containerPort: 8080
        command: ["/bin/bash"]
        args:
        - -c
        - |
          cd /app
          
          # Install Python dependencies
          pip install -r requirements.txt
          
          # Run MCP server with streamable-http
          echo "Starting Government MCP Server with streamable-http..."
          python main.py
        volumeMounts:
        - name: server-code
          mountPath: /app
        env:
        - name: PYTHONUNBUFFERED
          value: "1"
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          tcpSocket:
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          tcpSocket:
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 5
      volumes:
      - name: server-code
        configMap:
          name: gov-mcp-server
---
apiVersion: v1
kind: Service
metadata:
  name: gov-mcp-server
  namespace: gov
  labels:
    {{- include "gov.labels" . | nindent 4 }}
    component: mcp
    app: gov-mcp-server
spec:
  selector:
    app: gov-mcp-server
  ports:
  - port: 8080
    targetPort: 8080
    protocol: TCP
  type: ClusterIP
---
apiVersion: traefik.io/v1alpha1
kind: Middleware
metadata:
  name: gov-mcp-gateway
  namespace: gov
  labels:
    {{- include "gov.labels" . | nindent 4 }}
    component: mcp
spec:
  plugin:
    mcp:
      policies:
        # Allow MCP protocol handshake and tool discovery
        - match: Equals(`mcp.method`, `initialize`)
          action: allow
        - match: Equals(`mcp.method`, `tools/list`)
          action: allow
        - match: Equals(`mcp.method`, `ping`)
          action: allow
        # Allow all read-only list/browse operations
        - match: Equals(`mcp.method`, `tools/call`) && (Equals(`mcp.params.name`, `list_all_road_closures`) || Equals(`mcp.params.name`, `list_all_incidents`) || Equals(`mcp.params.name`, `list_all_outages`) || Equals(`mcp.params.name`, `list_all_infrastructure`) || Equals(`mcp.params.name`, `list_all_dams`) || Equals(`mcp.params.name`, `list_areas`))
          action: allow
        # Allow all read-only detail lookups
        - match: Equals(`mcp.method`, `tools/call`) && (Equals(`mcp.params.name`, `get_road_closure_details`) || Equals(`mcp.params.name`, `get_incident_details`) || Equals(`mcp.params.name`, `get_outage_details`) || Equals(`mcp.params.name`, `get_dam_status`))
          action: allow
        # Allow emergency analysis operations
        - match: Equals(`mcp.method`, `tools/call`) && (Equals(`mcp.params.name`, `emergency_status_summary`) || Equals(`mcp.params.name`, `rescue_mission`))
          action: allow
        # Require special authorization for write operations like floodgate control
        - match: Equals(`mcp.method`, `tools/call`) && Equals(`mcp.params.name`, `floodgate_control`)
          action: allow  # In production, this should check for specific roles/permissions via JWT claims
        # Allow utility tool operations
        - match: Equals(`mcp.method`, `tools/call`) && Equals(`mcp.params.name`, `ping`)
          action: allow
      defaultAction: deny
---
apiVersion: traefik.io/v1alpha1
kind: Middleware
metadata:
  name: gov-mcp-cors
  namespace: gov
  labels:
    {{- include "gov.labels" . | nindent 4 }}
    component: mcp
spec:
  headers:
    accessControlAllowMethods:
      - "*"
    accessControlAllowHeaders:
      - "*"
    accessControlAllowOriginList:
      - "*"
    accessControlExposeHeaders:
      - "*"
    accessControlMaxAge: 100
    addVaryHeader: true
---
apiVersion: traefik.io/v1alpha1
kind: IngressRoute
metadata:
  name: gov-mcp-route
  namespace: gov
  labels:
    {{- include "gov.labels" . | nindent 4 }}
    component: mcp
spec:
  entryPoints:
    - websecure
  routes:
    - kind: Rule
      match: {{ include "gov.mcp.hostMatch" . }}
      middlewares:
        - name: gov-mcp-cors
        - name: gov-mcp-gateway
      services:
        - name: gov-mcp-server
          port: 8080
          passHostHeader: false
