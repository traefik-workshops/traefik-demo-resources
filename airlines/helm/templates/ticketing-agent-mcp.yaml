---
apiVersion: v1
kind: ConfigMap
metadata:
  name: ticketing-agent-mcp-server
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: ticketing-agent-mcp
data:
  main.py: |
    #!/usr/bin/env python3
    """
    Ticketing Agent MCP Server
    """

    from typing import Any, Dict, List, Optional
    import logging, aiohttp, anyio, json
    from mcp.server import Server
    from mcp.server.stdio import stdio_server
    from mcp.types import Tool

    # Configure logging
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger("ticketing-agent-mcp")

    # Create MCP server instance
    server = Server("ticketing-agent-mcp")
    
    # API Configuration
    API_BASE_URLS = {
        'flights': '{{ include "airlines.flights.apiUrl" . }}',
        'bookings': '{{ include "airlines.bookings.apiUrl" . }}',
        'tickets': '{{ include "airlines.tickets.apiUrl" . }}',
        'passengers': '{{ include "airlines.passengers.apiUrl" . }}',
        'loyalty': '{{ include "airlines.loyalty.apiUrl" . }}',
        'checkin': '{{ include "airlines.checkin.apiUrl" . }}',
        'pricing': '{{ include "airlines.pricing.apiUrl" . }}',
        'baggage': '{{ include "airlines.baggage.apiUrl" . }}',
        'notifications': '{{ include "airlines.notifications.apiUrl" . }}',
        'ancillaries': '{{ include "airlines.ancillaries.apiUrl" . }}',
    }
    
    # Static JWT Token passed from Helm/Terraform
    jwt_token: str = "{{ required "tools-access.ticketing.token is required" (index .Values "tools-access" "ticketing" "token") }}"

    @server.list_tools()
    async def list_tools():
        """List available ticketing agent tools"""
        return [
            Tool(
                name="ping",
                description="Health check tool that returns a simple 'pong' response. Use this to verify that the MCP server is running and responsive. It requires no arguments.",
                inputSchema={"type": "object", "properties": {}}
            ),
            Tool(
                name="search_flights",
                description="Intelligently searches for available flights with OPTIONAL parameters. ALL parameters are optional - can work with ANY combination or NO parameters at all. If parameters are missing, queries all flights and shows what's available, filtering by whatever criteria IS provided. Use when user provides complete or incomplete search criteria. Examples: 'flights to JFK' (destination only), 'flights from LAX' (origin only), 'show me flights' (no params - shows all), 'JFK to LAX on 2024-12-25' (all params).",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "origin": {"type": "string", "description": "Origin airport code (e.g., 'JFK') - OPTIONAL"},
                        "destination": {"type": "string", "description": "Destination airport code (e.g., 'LAX') - OPTIONAL"},
                        "date": {"type": "string", "description": "Travel date in YYYY-MM-DD format - OPTIONAL"},
                        "passengers": {"type": "integer", "description": "Number of passengers (default: 1)", "default": 1},
                        "cabin_class": {
                            "type": "string",
                            "enum": ["economy", "premium_economy", "business", "first"],
                            "description": "Preferred cabin class",
                            "default": "economy"
                        }
                    }
                }
            ),
            Tool(
                name="book_flight_itinerary",
                description="Completes an end-to-end flight booking process. This tool orchestrates multiple APIs to create a booking, issue a ticket, select seats, and handle loyalty benefits. Use this when a user has selected a specific flight and wants to proceed with booking. Requires flight_id and passenger_id.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "flight_id": {"type": "string", "description": "Flight ID from search results"},
                        "passenger_id": {"type": "string", "description": "Passenger ID"},
                        "loyalty_number": {"type": "string", "description": "Optional loyalty program number"},
                        "seat_preference": {"type": "string", "description": "Preferred seat (e.g., '12A')"},
                        "include_baggage": {"type": "boolean", "description": "Include checked baggage", "default": False},
                        "meal_preference": {
                            "type": "string",
                            "enum": ["standard", "vegetarian", "vegan", "kosher", "halal", "gluten_free"],
                            "description": "Meal preference",
                            "default": "standard"
                        }
                    },
                    "required": ["flight_id", "passenger_id"]
                }
            ),
            Tool(
                name="modify_booking",
                description="Modifies an existing booking by changing the flight. This tool calculates change fees and processes the rebooking. Use this when a user wants to change their flight. Requires booking_id and new_flight_id.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "booking_id": {"type": "string", "description": "Existing booking reference"},
                        "new_flight_id": {"type": "string", "description": "New flight ID"},
                        "reason": {"type": "string", "description": "Reason for modification"}
                    },
                    "required": ["booking_id", "new_flight_id"]
                }
            ),
            Tool(
                name="cancel_booking_with_refund",
                description="Cancels an existing booking and processes any applicable refund. Use this tool when a user wishes to cancel their trip. It checks fare rules and loyalty status to determine refund eligibility. Requires booking_id.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "booking_id": {"type": "string", "description": "Booking reference to cancel"},
                        "reason": {"type": "string", "description": "Cancellation reason"}
                    },
                    "required": ["booking_id"]
                }
            ),
            Tool(
                name="check_in_and_generate_boarding_pass",
                description="Performs online check-in for a passenger and generates their boarding pass. Use this tool when a user is ready to check in for their flight. It can also handle seat selection during check-in. Requires booking_id.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "booking_id": {"type": "string", "description": "Booking reference"},
                        "seat_selection": {"type": "string", "description": "Desired seat number"}
                    },
                    "required": ["booking_id"]
                }
            ),
            Tool(
                name="get_loyalty_status",
                description="Retrieves detailed information about a customer's loyalty program status. Use this tool to check miles balance, tier status, and available benefits. Requires loyalty_number.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "loyalty_number": {"type": "string", "description": "Loyalty program number"}
                    },
                    "required": ["loyalty_number"]
                }
            ),
            Tool(
                name="redeem_miles_for_flight",
                description="Books a flight using loyalty miles instead of currency. This tool handles the redemption process and applies tier benefits. Use this when a user wants to use their miles for a flight. Requires flight_id, passenger_id, loyalty_number, and miles_to_use.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "flight_id": {"type": "string", "description": "Flight ID"},
                        "passenger_id": {"type": "string", "description": "Passenger ID"},
                        "loyalty_number": {"type": "string", "description": "Loyalty program number"},
                        "miles_to_use": {"type": "integer", "description": "Number of miles to redeem"}
                    },
                    "required": ["flight_id", "passenger_id", "loyalty_number", "miles_to_use"]
                }
            ),
            Tool(
                name="select_seat",
                description="Allows passengers to select or change their seat for a booking. Use this when a user wants to choose a specific seat (window, aisle, exit row, etc.). Requires booking_id and desired seat number.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "booking_id": {"type": "string", "description": "Booking reference"},
                        "seat_number": {"type": "string", "description": "Desired seat number (e.g., '12A', '23F')"},
                        "seat_type": {
                            "type": "string",
                            "enum": ["window", "aisle", "middle", "exit_row", "bulkhead"],
                            "description": "Preferred seat type",
                            "default": "window"
                        }
                    },
                    "required": ["booking_id", "seat_number"]
                }
            ),
            Tool(
                name="manage_baggage",
                description="Add, remove, or modify checked baggage for a booking. Use this to handle baggage requests, calculate fees, and update baggage allowances. Requires booking_id and baggage details.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "booking_id": {"type": "string", "description": "Booking reference"},
                        "action": {
                            "type": "string",
                            "enum": ["add", "remove", "modify"],
                            "description": "Action to perform on baggage"
                        },
                        "baggage_count": {"type": "integer", "description": "Number of checked bags (1-3)", "minimum": 0, "maximum": 3},
                        "baggage_type": {
                            "type": "string",
                            "enum": ["standard", "oversize", "sports_equipment"],
                            "description": "Type of baggage",
                            "default": "standard"
                        }
                    },
                    "required": ["booking_id", "action"]
                }
            ),
            Tool(
                name="update_meal_preference",
                description="Update meal preferences for a passenger on a flight. Use this when a user wants to select or change their in-flight meal. Requires booking_id and meal choice.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "booking_id": {"type": "string", "description": "Booking reference"},
                        "meal_type": {
                            "type": "string",
                            "enum": ["standard", "vegetarian", "vegan", "kosher", "halal", "gluten_free", "low_sodium", "diabetic", "child_meal"],
                            "description": "Meal preference"
                        },
                        "special_requests": {"type": "string", "description": "Additional dietary requirements or allergies"}
                    },
                    "required": ["booking_id", "meal_type"]
                }
            )
        ]

    async def get_jwt_token() -> str:
        """Get JWT token (static)"""
        return jwt_token

    async def api_request(service: str, endpoint: str, method: str = "GET", data: Dict | None = None) -> Dict:
        """Make authenticated API request and return response"""
        token = await get_jwt_token()
        url = f"{API_BASE_URLS[service]}{endpoint}"
        headers = {"Authorization": f"Bearer {token}"}
        if method in ["POST", "PUT", "PATCH"]:
            headers["Content-Type"] = "application/json"
        
        async with aiohttp.ClientSession() as session:
            async with session.request(method, url, headers=headers, json=data) as r:
                response_text = await r.text()
                if r.status == 200:
                    try:
                        return await r.json() if not response_text else json.loads(response_text)
                    except Exception as e:
                        logger.warning(f"JSON parse error for {url}: {e}")
                        return {"data": response_text, "status": 200}
                elif r.status == 201:
                    try:
                        return {"status": "created", "data": await r.json() if response_text else {}}
                    except:
                        return {"status": "created"}
                elif r.status == 404:
                    return {"error": "Not found", "status": 404}
                else:
                    return {"error": f"API error {r.status}: {response_text}", "status": r.status}

    @server.call_tool()
    async def call_tool(name: str, arguments: dict):
        """Handle tool calls with detailed execution tracing"""
        logger.info(f"Tool called: {name} with args: {arguments}")
        
        if name == "ping":
            return [{"type": "text", "text": "pong - Ticketing Agent MCP Server is operational"}]
        
        elif name == "search_flights":
            origin = arguments.get("origin")
            destination = arguments.get("destination")
            date = arguments.get("date")
            passengers = arguments.get("passengers", 1)
            cabin_class = arguments.get("cabin_class", "economy")

            try:
                steps = []
                steps.append("‚úàÔ∏è **INTELLIGENT FLIGHT SEARCH**")

                # Build search criteria display
                criteria = []
                if origin:
                    criteria.append(f"Origin: {origin}")
                if destination:
                    criteria.append(f"Destination: {destination}")
                if date:
                    criteria.append(f"Date: {date}")
                criteria.append(f"Passengers: {passengers}")
                criteria.append(f"Class: {cabin_class}")

                if origin or destination or date:
                    steps.append("Search criteria: " + ", ".join(criteria))
                else:
                    steps.append("No specific criteria - showing all available flights")
                steps.append("")

                # Step 1: Query flights (with or without filters)
                steps.append("1Ô∏è‚É£ Querying flight inventory...")

                # Build query based on available parameters
                if origin and destination and date:
                    # Traditional search with all params
                    search_result = await api_request(
                        "flights",
                        f"/flights/search?origin={origin}&dest={destination}&date={date}"
                    )
                else:
                    # Autonomous mode: get all flights and filter
                    steps.append("   ‚ÑπÔ∏è  Missing some parameters - querying all flights autonomously...")
                    search_result = await api_request("flights", "/flights")

                if "error" in search_result:
                    steps.append(f"   ‚ùå Error: {search_result['error']}")
                    return [{"type": "text", "text": "\\n".join(steps)}]

                # Extract flights from response
                flights_data = search_result.get("flights", [])
                if isinstance(flights_data, dict):
                    flights = list(flights_data.values())
                else:
                    flights = flights_data

                steps.append(f"   ‚úÖ Retrieved {len(flights)} flights from inventory")

                # Step 1.5: Apply filters if partial criteria provided
                if not (origin and destination and date):
                    steps.append("\\n1.5Ô∏è‚É£ Applying available filters...")
                    original_count = len(flights)

                    if origin:
                        flights = [f for f in flights if f.get("origin", "").upper() == origin.upper()]
                        steps.append(f"   ‚úÖ Filtered by origin={origin}: {len(flights)} flights")

                    if destination:
                        flights = [f for f in flights if f.get("destination", "").upper() == destination.upper()]
                        steps.append(f"   ‚úÖ Filtered by destination={destination}: {len(flights)} flights")

                    if date:
                        flights = [f for f in flights if date in f.get("departure_time", "")]
                        steps.append(f"   ‚úÖ Filtered by date={date}: {len(flights)} flights")

                    if not origin and not destination and not date:
                        steps.append(f"   ‚ÑπÔ∏è  No filters applied - showing all {len(flights)} flights")

                steps.append(f"\\n   ‚úÖ Final result: {len(flights)} matching flights")
                
                # Step 2: Get pricing for each flight
                steps.append("\\n2Ô∏è‚É£ Fetching pricing information...")
                priced_flights = []
                for flight in flights[:5]:  # Limit to top 5
                    flight_id = flight.get("id", "unknown")
                    pricing = await api_request(
                        "pricing",
                        f"/pricing/calculate",
                        "POST",
                        {"flight_id": flight_id, "cabin_class": cabin_class, "passengers": passengers}
                    )
                    
                    if "error" not in pricing:
                        flight["pricing"] = pricing
                        priced_flights.append(flight)
                        price = pricing.get("total", 0)
                        steps.append(f"   ‚úÖ Flight {flight_id}: ${price:.2f}")
                    else:
                        steps.append(f"   ‚ö†Ô∏è  Flight {flight_id}: Pricing unavailable")
                
                # Step 3: Check seat availability
                steps.append("\\n3Ô∏è‚É£ Checking seat availability...")
                for flight in priced_flights:
                    flight_id = flight.get("flight_id")
                    inventory_response = await api_request("flights", f"/flights/{flight_id}/inventory")
                    
                    available_seats = 0
                    if "error" not in inventory_response:
                        # Handle wrapped inventory
                        inventory = inventory_response
                        if "flights" in inventory_response:
                            inv_data = inventory_response["flights"]
                            if isinstance(inv_data, dict) and flight_id in inv_data:
                                inventory = inv_data[flight_id]
                            elif isinstance(inv_data, list):
                                found = next((f for f in inv_data if f.get("flight_id") == flight_id), None)
                                if found:
                                    inventory = found
                        
                        available_seats = inventory.get("seats_available", 0)
                    
                    flight["available_seats"] = available_seats
                    steps.append(f"   ‚úÖ Flight {flight_id}: {available_seats} seats available")
                
                # Build response
                response = "\\n".join(steps)
                response += "\\n\\n**AVAILABLE FLIGHTS**:\\n"
                for i, flight in enumerate(priced_flights, 1):
                    dept_time = flight.get("departure_time", "Unknown")
                    arr_time = flight.get("arrival_time", "Unknown")
                    flight_num = flight.get("flight_id", "Unknown")
                    price = flight["pricing"].get("total", 0) if "pricing" in flight else 0
                    seats = flight.get("available_seats", "?")
                    
                    response += f"\\n{i}. **Flight {flight_num}** (ID: {flight.get('flight_id')})\\n"
                    response += f"   Departure: {dept_time} | Arrival: {arr_time}\\n"
                    response += f"   Price: ${price:.2f} | Seats: {seats}\\n"
                
                response += "\\n\\n**Next Step**: Use `book_flight_itinerary` with a flight_id to complete booking"
                
                return [{"type": "text", "text": response}]
                
            except Exception as e:
                logger.error(f"Error in search_flights: {e}")
                return [{"type": "text", "text": f"‚ùå System error during flight search: {str(e)}"}]
        
        elif name == "book_flight_itinerary":
            flight_id = arguments.get("flight_id")
            passenger_id = arguments.get("passenger_id")
            loyalty_number = arguments.get("loyalty_number")
            seat_preference = arguments.get("seat_preference")
            include_baggage = arguments.get("include_baggage", False)
            meal_preference = arguments.get("meal_preference", "standard")
            
            try:
                steps = []
                warnings = []
                errors = []
                
                steps.append("üé´ **FLIGHT BOOKING PROCESS INITIATED**")
                steps.append(f"‚úàÔ∏è  Flight ID: {flight_id}")
                steps.append(f"üë§ Passenger ID: {passenger_id}")
                steps.append("")
                
                # Step 1: Get flight details
                steps.append("1Ô∏è‚É£ Retrieving flight information...")
                flight_response = await api_request("flights", f"/flights/{flight_id}")
                if "error" in flight_response:
                    errors.append(f"Flight not found: {flight_response['error']}")
                    steps.append(f"   ‚ùå {errors[-1]}")
                    return [{"type": "text", "text": "\\n".join(steps)}]
                
                # Handle API response variations
                flight = flight_response
                if "flights" in flight_response:
                    flights_data = flight_response["flights"]
                    if isinstance(flights_data, dict) and flight_id in flights_data:
                        flight = flights_data[flight_id]
                    elif isinstance(flights_data, list):
                        found = next((f for f in flights_data if f.get("flight_id") == flight_id), None)
                        if found:
                            flight = found
                
                # Check if we actually have the flight data
                if not flight or "flight_id" not in flight:
                     # Fallback logic if needed
                     pass
                
                flight_num = flight.get("flight_id", "Unknown")
                origin = flight.get("origin", "???")
                dest = flight.get("destination", "???")
                dept_time = flight.get("departure_time", "Unknown")
                steps.append(f"   ‚úÖ Flight {flight_num}: {origin} ‚Üí {dest} at {dept_time}")
                
                # Step 2: Get passenger details
                steps.append("\\n2Ô∏è‚É£ Verifying passenger information...")
                passenger_response = await api_request("passengers", f"/passengers/{passenger_id}")
                if "error" in passenger_response:
                    errors.append(f"Passenger not found: {passenger_response['error']}")
                    steps.append(f"   ‚ùå {errors[-1]}")
                    return [{"type": "text", "text": "\\n".join(steps)}]
                
                # Handle wrapped passenger response
                passenger = passenger_response
                if "passengers" in passenger_response:
                    pax_data = passenger_response["passengers"]
                    if isinstance(pax_data, dict) and passenger_id in pax_data:
                        passenger = pax_data[passenger_id]
                    elif isinstance(pax_data, list):
                        found = next((p for p in pax_data if p.get("passenger_id") == passenger_id), None)
                        if found:
                            passenger = found
                
                passenger_name = passenger.get("first_name", "") + " " + passenger.get("last_name", "")
                if passenger_name.strip() == "": passenger_name = "Unknown"
                steps.append(f"   ‚úÖ Passenger: {passenger_name}")
                
                # Step 3: Check loyalty status (if provided)
                loyalty_discount = 0
                loyalty_tier = "None"
                if loyalty_number:
                    steps.append("\\n3Ô∏è‚É£ Checking loyalty program benefits...")
                    loyalty_response = await api_request("loyalty", f"/loyalty/members/{loyalty_number}")
                    if "error" not in loyalty_response:
                        # Handle wrapped loyalty response
                        loyalty = loyalty_response
                        if "members" in loyalty_response:
                            members_data = loyalty_response["members"]
                            if isinstance(members_data, dict) and loyalty_number in members_data:
                                loyalty = members_data[loyalty_number]
                            elif isinstance(members_data, list):
                                found = next((m for m in members_data if m.get("member_id") == loyalty_number), None)
                                if found:
                                    loyalty = found
                        
                        loyalty_tier = loyalty.get("tier", "Standard")
                        miles_available = loyalty.get("miles_balance", 0)
                        steps.append(f"   ‚úÖ Tier: {loyalty_tier} | Miles: {miles_available:,}")
                        
                        # Calculate tier discount
                        if loyalty_tier == "Gold":
                            loyalty_discount = 0.10
                        elif loyalty_tier == "Platinum":
                            loyalty_discount = 0.15
                        elif loyalty_tier == "Diamond":
                            loyalty_discount = 0.20
                        
                        if loyalty_discount > 0:
                            steps.append(f"   üéÅ {int(loyalty_discount * 100)}% loyalty discount applied")
                    else:
                        warnings.append(f"Loyalty lookup failed: {loyalty_response['error']}")
                        steps.append(f"   ‚ö†Ô∏è  {warnings[-1]}")
                
                # Step 4: Calculate pricing
                steps.append("\\n4Ô∏è‚É£ Calculating total price...")
                pricing = await api_request(
                    "pricing",
                    "/pricing/calculate",
                    "POST",
                    {"flight_id": flight_id, "cabin_class": "economy", "passengers": 1}
                )
                
                if "error" in pricing:
                    errors.append(f"Pricing calculation failed: {pricing['error']}")
                    steps.append(f"   ‚ùå {errors[-1]}")
                    return [{"type": "text", "text": "\\n".join(steps)}]
                
                base_fare = pricing.get("base_fare", 0)
                taxes = pricing.get("taxes", 0)
                subtotal = base_fare + taxes
                discount_amount = subtotal * loyalty_discount
                total_price = subtotal - discount_amount
                
                steps.append(f"   ‚úÖ Base Fare: ${base_fare:.2f}")
                steps.append(f"   ‚úÖ Taxes & Fees: ${taxes:.2f}")
                if loyalty_discount > 0:
                    steps.append(f"   ‚úÖ Loyalty Discount: -${discount_amount:.2f}")
                steps.append(f"   ‚úÖ **Total: ${total_price:.2f}**")
                
                # Step 5: Create booking
                steps.append("\\n5Ô∏è‚É£ Creating reservation...")
                booking = await api_request(
                    "bookings",
                    "/bookings",
                    "POST",
                    {
                        "flight_id": flight_id,
                        "passenger_id": passenger_id,
                        "total_price": total_price
                    }
                )
                
                if "error" in booking:
                    errors.append(f"Booking creation failed: {booking['error']}")
                    steps.append(f"   ‚ùå {errors[-1]}")
                    return [{"type": "text", "text": "\\n".join(steps)}]
                
                booking_id = booking.get("data", {}).get("booking_id", "UNKNOWN")
                steps.append(f"   ‚úÖ Booking Reference: **{booking_id}**")
                
                # Step 6: Issue ticket
                steps.append("\\n6Ô∏è‚É£ Issuing e-ticket...")
                ticket = await api_request(
                    "tickets",
                    "/tickets/issue",
                    "POST",
                    {"booking_id": booking_id, "passenger_id": passenger_id}
                )
                
                if "error" in ticket:
                    warnings.append(f"Ticket issuance delayed: {ticket['error']}")
                    steps.append(f"   ‚ö†Ô∏è  {warnings[-1]}")
                else:
                    ticket_number = ticket.get("data", {}).get("ticket_number", "PENDING")
                    steps.append(f"   ‚úÖ Ticket Number: {ticket_number}")
                
                # Step 7: Seat selection
                if seat_preference:
                    steps.append("\\n7Ô∏è‚É£ Selecting seat...")
                    seat_result = await api_request(
                        "checkin",
                        f"/checkin/{booking_id}/seat",
                        "POST",
                        {"seat": seat_preference}
                    )
                    
                    if "error" in seat_result:
                        # Try to assign any available seat
                        warnings.append(f"Preferred seat {seat_preference} unavailable")
                        steps.append(f"   ‚ö†Ô∏è  {warnings[-1]}")
                        
                        auto_seat = await api_request(
                            "checkin",
                            f"/checkin/{booking_id}/seat/auto",
                            "POST",
                            {}
                        )
                        if "error" not in auto_seat:
                            assigned_seat = auto_seat.get("data", {}).get("seat", "TBD")
                            steps.append(f"   ‚úÖ Auto-assigned seat: {assigned_seat}")
                    else:
                        steps.append(f"   ‚úÖ Seat confirmed: {seat_preference}")
                
                # Step 8: Add baggage if requested
                if include_baggage:
                    steps.append("\\n8Ô∏è‚É£ Adding checked baggage...")
                    baggage = await api_request(
                        "baggage",
                        f"/baggage/add",
                        "POST",
                        {"booking_id": booking_id, "bags": 1}
                    )
                    
                    if "error" in baggage:
                        warnings.append(f"Baggage addition failed: {baggage['error']}")
                        steps.append(f"   ‚ö†Ô∏è  {warnings[-1]}")
                    else:
                        bag_fee = baggage.get("data", {}).get("fee", 0)
                        steps.append(f"   ‚úÖ 1 checked bag added (${bag_fee:.2f})")
                
                # Step 9: Record meal preference
                if meal_preference != "standard":
                    steps.append("\\n9Ô∏è‚É£ Recording meal preference...")
                    meal = await api_request(
                        "ancillaries",
                        f"/ancillaries/meal",
                        "POST",
                        {"booking_id": booking_id, "preference": meal_preference}
                    )
                    
                    if "error" in meal:
                        warnings.append(f"Meal preference not saved: {meal['error']}")
                        steps.append(f"   ‚ö†Ô∏è  {warnings[-1]}")
                    else:
                        steps.append(f"   ‚úÖ Meal preference: {meal_preference}")
                
                # Step 10: Send confirmation
                steps.append("\\nüîü Sending booking confirmation...")
                notification = await api_request(
                    "notifications",
                    "/notifications/send",
                    "POST",
                    {
                        "type": "booking_confirmation",
                        "recipient": passenger_id,
                        "booking_id": booking_id
                    }
                )
                
                if "error" in notification:
                    warnings.append(f"Confirmation email failed: {notification['error']}")
                    steps.append(f"   ‚ö†Ô∏è  {warnings[-1]}")
                else:
                    steps.append(f"   ‚úÖ Confirmation sent to passenger")
                
                # Build final response
                response = "\\n".join(steps)
                response += "\\n\\n" + "="*60
                response += "\\n**BOOKING COMPLETED SUCCESSFULLY** ‚úÖ\\n"
                response += "="*60
                response += f"\\n\\n**Booking Reference**: {booking_id}"
                response += f"\\n**Total Price**: ${total_price:.2f}"
                response += f"\\n**APIs Called**: {len([s for s in steps if 'Ô∏è‚É£' in s])}"
                response += f"\\n**Warnings**: {len(warnings)}"
                response += f"\\n**Errors**: {len(errors)}"
                
                if warnings:
                    response += "\\n\\n**Warnings**:"
                    for w in warnings:
                        response += f"\\n‚Ä¢ {w}"
                
                return [{"type": "text", "text": response}]
                
            except Exception as e:
                logger.error(f"Error in book_flight_itinerary: {e}")
                return [{"type": "text", "text": f"‚ùå Critical system error during booking: {str(e)}\\n\\nPartial trace:\\n" + "\\n".join(steps)}]
        
        elif name == "get_loyalty_status":
            loyalty_number = arguments.get("loyalty_number")
            
            try:
                steps = []
                steps.append("üèÜ **LOYALTY STATUS CHECK**")
                steps.append(f"üé´ Member Number: {loyalty_number}")
                steps.append("")
                
                # Step 1: Get member details
                steps.append("1Ô∏è‚É£ Retrieving membership information...")
                loyalty = await api_request("loyalty", f"/loyalty/members/{loyalty_number}")
                
                if "error" in loyalty:
                    steps.append(f"   ‚ùå Member not found: {loyalty['error']}")
                    return [{"type": "text", "text": "\\n".join(steps)}]
                
                name = loyalty.get("name", "Unknown")
                tier = loyalty.get("tier", "Standard")
                miles = loyalty.get("miles", 0)
                tier_miles = loyalty.get("tier_qualifying_miles", 0)
                member_since = loyalty.get("member_since", "Unknown")
                
                steps.append(f"   ‚úÖ Member: {name}")
                steps.append(f"   ‚úÖ Tier: {tier}")
                steps.append(f"   ‚úÖ Available Miles: {miles:,}")
                steps.append(f"   ‚úÖ Tier Miles: {tier_miles:,}")
                steps.append(f"   ‚úÖ Member Since: {member_since}")
                
                # Step 2: Calculate next tier requirements
                steps.append("\\n2Ô∏è‚É£ Calculating tier progress...")
                next_tier_requirements = {
                    "Standard": ("Silver", 25000),
                    "Silver": ("Gold", 50000),
                    "Gold": ("Platinum", 75000),
                    "Platinum": ("Diamond", 100000),
                    "Diamond": ("Diamond", 100000)  # Already at top
                }
                
                next_tier, required_miles = next_tier_requirements.get(tier, ("Unknown", 0))
                miles_needed = max(0, required_miles - tier_miles)
                
                if tier == "Diamond":
                    steps.append(f"   üèÜ **Already at highest tier!**")
                else:
                    progress_pct = (tier_miles / required_miles * 100) if required_miles > 0 else 0
                    steps.append(f"   üìä Progress to {next_tier}: {progress_pct:.1f}%")
                    steps.append(f"   ‚úàÔ∏è  {miles_needed:,} miles needed")
                
                # Build response
                response = "\\n".join(steps)
                response += "\\n\\n**TIER BENEFITS**:\\n"
                
                benefits = {
                    "Standard": ["Earn 1 mile per dollar", "Standard booking"],
                    "Silver": ["Earn 1.25 miles per dollar", "Priority check-in", "1 free checked bag"],
                    "Gold": ["Earn 1.5 miles per dollar", "Priority boarding", "2 free checked bags", "10% discount on tickets"],
                    "Platinum": ["Earn 1.75 miles per dollar", "Lounge access", "3 free checked bags", "15% discount on tickets"],
                    "Diamond": ["Earn 2 miles per dollar", "Premium lounge access", "Unlimited free bags", "20% discount", "Complimentary upgrades"]
                }
                
                for benefit in benefits.get(tier, []):
                    response += f"‚Ä¢ {benefit}\\n"
                
                return [{"type": "text", "text": response}]
                
            except Exception as e:
                logger.error(f"Error in get_loyalty_status: {e}")
                return [{"type": "text", "text": f"‚ùå System error: {str(e)}"}]
        
        elif name == "modify_booking":
            booking_id = arguments.get("booking_id")
            new_flight_id = arguments.get("new_flight_id")
            reason = arguments.get("reason", "Customer request")
            
            try:
                steps = []
                steps.append("‚úèÔ∏è **BOOKING MODIFICATION**")
                steps.append(f"üìã Booking: {booking_id}")
                steps.append(f"‚úàÔ∏è  New Flight: {new_flight_id}")
                steps.append("")
                
                # Step 1: Get current booking
                steps.append("1Ô∏è‚É£ Retrieving current booking...")
                booking_response = await api_request("bookings", f"/bookings/{booking_id}")
                
                if "error" in booking_response:
                    steps.append(f"   ‚ùå Booking not found: {booking_response['error']}")
                    return [{"type": "text", "text": "\\n".join(steps)}]
                
                booking = booking_response.get("data", booking_response)
                old_flight_id = booking.get("flight_id", "Unknown")
                passenger_id = booking.get("passenger_id", "Unknown")
                steps.append(f"   ‚úÖ Current flight: {old_flight_id}")
                
                # Step 2: Get new flight details
                steps.append("\\n2Ô∏è‚É£ Checking new flight availability...")
                new_flight = await api_request("flights", f"/flights/{new_flight_id}")
                
                if "error" in new_flight:
                    steps.append(f"   ‚ùå New flight not available")
                    return [{"type": "text", "text": "\\n".join(steps)}]
                
                steps.append(f"   ‚úÖ New flight available")
                
                # Step 3: Calculate change fee
                steps.append("\\n3Ô∏è‚É£ Calculating change fee...")
                change_fee = 75.00
                steps.append(f"   üí∞ Change fee: ${change_fee:.2f}")
                
                # Step 4: Update booking
                steps.append("\\n4Ô∏è‚É£ Updating booking...")
                update_result = await api_request(
                    "bookings",
                    f"/bookings/{booking_id}",
                    "PUT",
                    {"flight_id": new_flight_id, "change_fee": change_fee}
                )
                
                if "error" not in update_result:
                    steps.append(f"   ‚úÖ Booking updated successfully")
                else:
                    steps.append(f"   ‚ö†Ô∏è  Update pending confirmation")
                
                # Step 5: Send notification
                steps.append("\\n5Ô∏è‚É£ Sending confirmation...")
                await api_request(
                    "notifications",
                    "/notifications/send",
                    "POST",
                    {"type": "booking_confirmation", "recipient": passenger_id, "booking_id": booking_id}
                )
                steps.append(f"   ‚úÖ Confirmation sent")
                
                response = "\\n".join(steps)
                response += "\\n\\n" + "="*60
                response += "\\n**BOOKING MODIFIED** ‚úÖ\\n"
                response += "="*60
                response += f"\\n\\n**Booking**: {booking_id}"
                response += f"\\n**Old Flight**: {old_flight_id}"
                response += f"\\n**New Flight**: {new_flight_id}"
                response += f"\\n**Change Fee**: ${change_fee:.2f}"
                
                return [{"type": "text", "text": response}]
                
            except Exception as e:
                logger.error(f"Error in modify_booking: {e}")
                return [{"type": "text", "text": f"‚ùå Error: {str(e)}"}]
        
        elif name == "cancel_booking_with_refund":
            booking_id = arguments.get("booking_id")
            reason = arguments.get("reason", "Customer request")
            
            try:
                steps = []
                steps.append("‚ùå **BOOKING CANCELLATION**")
                steps.append(f"üìã Booking: {booking_id}")
                steps.append(f"üìù Reason: {reason}")
                steps.append("")
                
                # Step 1: Get booking details
                steps.append("1Ô∏è‚É£ Retrieving booking...")
                booking_response = await api_request("bookings", f"/bookings/{booking_id}")
                
                if "error" in booking_response:
                    steps.append(f"   ‚ùå Booking not found")
                    return [{"type": "text", "text": "\\n".join(steps)}]
                
                booking = booking_response.get("data", booking_response)
                flight_id = booking.get("flight_id", "Unknown")
                passenger_id = booking.get("passenger_id", "Unknown")
                total_price = booking.get("total_price", 0)
                steps.append(f"   ‚úÖ Booking found: {flight_id}")
                
                # Step 2: Check refund eligibility
                steps.append("\\n2Ô∏è‚É£ Checking refund eligibility...")
                cancellation_fee = 50.00
                refund_amount = max(0, total_price - cancellation_fee)
                steps.append(f"   üí∞ Original price: ${total_price:.2f}")
                steps.append(f"   üí∞ Cancellation fee: ${cancellation_fee:.2f}")
                steps.append(f"   üí∞ Refund amount: ${refund_amount:.2f}")
                
                # Step 3: Cancel booking
                steps.append("\\n3Ô∏è‚É£ Cancelling booking...")
                cancel_result = await api_request(
                    "bookings",
                    f"/bookings/{booking_id}",
                    "DELETE"
                )
                
                if "error" not in cancel_result:
                    steps.append(f"   ‚úÖ Booking cancelled")
                else:
                    steps.append(f"   ‚ö†Ô∏è  Cancellation pending")
                
                # Step 4: Process refund
                if refund_amount > 0:
                    steps.append("\\n4Ô∏è‚É£ Processing refund...")
                    steps.append(f"   ‚úÖ Refund of ${refund_amount:.2f} initiated")
                    steps.append(f"   ‚ÑπÔ∏è  Processing time: 5-7 business days")
                
                # Step 5: Send notification
                steps.append("\\n5Ô∏è‚É£ Sending confirmation...")
                await api_request(
                    "notifications",
                    "/notifications/send",
                    "POST",
                    {"type": "booking_confirmation", "recipient": passenger_id, "booking_id": booking_id}
                )
                steps.append(f"   ‚úÖ Cancellation confirmation sent")
                
                response = "\\n".join(steps)
                response += "\\n\\n" + "="*60
                response += "\\n**BOOKING CANCELLED** ‚úÖ\\n"
                response += "="*60
                response += f"\\n\\n**Booking**: {booking_id}"
                response += f"\\n**Refund**: ${refund_amount:.2f}"
                response += f"\\n**Status**: Cancelled"
                
                return [{"type": "text", "text": response}]
                
            except Exception as e:
                logger.error(f"Error in cancel_booking_with_refund: {e}")
                return [{"type": "text", "text": f"‚ùå Error: {str(e)}"}]
        
        elif name == "check_in_and_generate_boarding_pass":
            booking_id = arguments.get("booking_id")
            seat_selection = arguments.get("seat_selection")
            
            try:
                steps = []
                steps.append("üé´ **CHECK-IN PROCESS**")
                steps.append(f"üìã Booking: {booking_id}")
                steps.append("")
                
                # Step 1: Get booking
                steps.append("1Ô∏è‚É£ Retrieving booking...")
                booking_response = await api_request("bookings", f"/bookings/{booking_id}")
                
                if "error" in booking_response:
                    steps.append(f"   ‚ùå Booking not found")
                    return [{"type": "text", "text": "\\n".join(steps)}]
                
                booking = booking_response.get("data", booking_response)
                flight_id = booking.get("flight_id", "Unknown")
                passenger_id = booking.get("passenger_id", "Unknown")
                steps.append(f"   ‚úÖ Flight: {flight_id}")
                
                # Step 2: Get flight details
                steps.append("\\n2Ô∏è‚É£ Getting flight details...")
                flight = await api_request("flights", f"/flights/{flight_id}")
                
                if "error" not in flight:
                    dept_time = flight.get("departure_time", "Unknown")
                    gate = flight.get("gate", "TBA")
                    steps.append(f"   ‚úÖ Departure: {dept_time}")
                    steps.append(f"   ‚úÖ Gate: {gate}")
                
                # Step 3: Seat assignment
                steps.append("\\n3Ô∏è‚É£ Assigning seat...")
                if seat_selection:
                    seat_result = await api_request(
                        "checkin",
                        f"/checkin/{booking_id}/seat",
                        "POST",
                        {"seat": seat_selection}
                    )
                    assigned_seat = seat_selection if "error" not in seat_result else "12A"
                else:
                    assigned_seat = "12A"  # Auto-assign
                
                steps.append(f"   ‚úÖ Seat assigned: {assigned_seat}")
                
                # Step 4: Generate boarding pass
                steps.append("\\n4Ô∏è‚É£ Generating boarding pass...")
                checkin_result = await api_request(
                    "checkin",
                    f"/checkin/{booking_id}",
                    "POST",
                    {"seat": assigned_seat, "checked_in": True}
                )
                
                boarding_pass_num = f"BP{booking_id[-6:]}{assigned_seat.replace(' ', '')}"
                steps.append(f"   ‚úÖ Boarding pass: {boarding_pass_num}")
                
                # Step 5: Send boarding pass
                steps.append("\\n5Ô∏è‚É£ Sending boarding pass...")
                await api_request(
                    "notifications",
                    "/notifications/send",
                    "POST",
                    {"type": "flight_reminder", "recipient": passenger_id, "booking_id": booking_id}
                )
                steps.append(f"   ‚úÖ Boarding pass sent to mobile")
                
                response = "\\n".join(steps)
                response += "\\n\\n" + "="*60
                response += "\\n**CHECK-IN COMPLETE** ‚úÖ\\n"
                response += "="*60
                response += f"\\n\\n**Booking**: {booking_id}"
                response += f"\\n**Flight**: {flight_id}"
                response += f"\\n**Seat**: {assigned_seat}"
                response += f"\\n**Boarding Pass**: {boarding_pass_num}"
                response += f"\\n**Gate**: {gate if 'flight' in locals() else 'TBA'}"
                
                return [{"type": "text", "text": response}]
                
            except Exception as e:
                logger.error(f"Error in check_in_and_generate_boarding_pass: {e}")
                return [{"type": "text", "text": f"‚ùå Error: {str(e)}"}]
        
        elif name == "redeem_miles_for_flight":
            flight_id = arguments.get("flight_id")
            passenger_id = arguments.get("passenger_id")
            loyalty_number = arguments.get("loyalty_number")
            miles_to_use = arguments.get("miles_to_use")
            
            try:
                steps = []
                steps.append("üíé **MILES REDEMPTION**")
                steps.append(f"‚úàÔ∏è  Flight: {flight_id}")
                steps.append(f"üé´ Loyalty: {loyalty_number}")
                steps.append(f"üí∞ Miles: {miles_to_use:,}")
                steps.append("")
                
                # Step 1: Check loyalty account
                steps.append("1Ô∏è‚É£ Checking loyalty account...")
                loyalty = await api_request("loyalty", f"/loyalty/members/{loyalty_number}")
                
                if "error" in loyalty:
                    steps.append(f"   ‚ùå Loyalty account not found")
                    return [{"type": "text", "text": "\\n".join(steps)}]
                
                available_miles = loyalty.get("miles_balance", 0)
                tier = loyalty.get("tier", "Standard")
                steps.append(f"   ‚úÖ Available miles: {available_miles:,}")
                steps.append(f"   ‚úÖ Tier: {tier}")
                
                # Step 2: Check if enough miles
                if available_miles < miles_to_use:
                    steps.append("\\n‚ùå **INSUFFICIENT MILES**")
                    steps.append(f"   Needed: {miles_to_use:,}")
                    steps.append(f"   Available: {available_miles:,}")
                    steps.append(f"   Short by: {miles_to_use - available_miles:,}")
                    return [{"type": "text", "text": "\\n".join(steps)}]
                
                steps.append("\\n2Ô∏è‚É£ Validating redemption...")
                steps.append(f"   ‚úÖ Sufficient miles available")
                
                # Step 3: Get flight pricing
                steps.append("\\n3Ô∏è‚É£ Calculating ticket value...")
                pricing = await api_request(
                    "pricing",
                    "/pricing/calculate",
                    "POST",
                    {"flight_id": flight_id, "cabin_class": "economy", "passengers": 1}
                )
                
                ticket_value = pricing.get("total", 500) if "error" not in pricing else 500
                miles_value = miles_to_use / 100  # 100 miles = $1
                steps.append(f"   üíµ Ticket value: ${ticket_value:.2f}")
                steps.append(f"   üíé Miles value: ${miles_value:.2f}")
                
                # Step 4: Create booking
                steps.append("\\n4Ô∏è‚É£ Creating award booking...")
                booking = await api_request(
                    "bookings",
                    "/bookings",
                    "POST",
                    {
                        "flight_id": flight_id,
                        "passenger_id": passenger_id,
                        "total_price": 0,
                        "payment_method": "miles",
                        "miles_used": miles_to_use
                    }
                )
                
                if "error" in booking:
                    steps.append(f"   ‚ùå Booking failed")
                    return [{"type": "text", "text": "\\n".join(steps)}]
                
                booking_id = booking.get("data", {}).get("booking_id", "AWARD001")
                steps.append(f"   ‚úÖ Booking created: {booking_id}")
                
                # Step 5: Deduct miles
                steps.append("\\n5Ô∏è‚É£ Deducting miles...")
                new_balance = available_miles - miles_to_use
                steps.append(f"   ‚úÖ Miles deducted: {miles_to_use:,}")
                steps.append(f"   ‚úÖ New balance: {new_balance:,}")
                
                # Step 6: Issue ticket
                steps.append("\\n6Ô∏è‚É£ Issuing award ticket...")
                ticket = await api_request(
                    "tickets",
                    "/tickets/issue",
                    "POST",
                    {"booking_id": booking_id, "passenger_id": passenger_id}
                )
                
                ticket_number = ticket.get("data", {}).get("ticket_number", "AWARD-TKT") if "error" not in ticket else "AWARD-TKT"
                steps.append(f"   ‚úÖ Ticket: {ticket_number}")
                
                response = "\\n".join(steps)
                response += "\\n\\n" + "="*60
                response += "\\n**AWARD BOOKING COMPLETE** ‚úÖ\\n"
                response += "="*60
                response += f"\\n\\n**Booking**: {booking_id}"
                response += f"\\n**Ticket**: {ticket_number}"
                response += f"\\n**Miles Used**: {miles_to_use:,}"
                response += f"\\n**Remaining Miles**: {new_balance:,}"
                
                return [{"type": "text", "text": response}]
                
            except Exception as e:
                logger.error(f"Error in redeem_miles_for_flight: {e}")
                return [{"type": "text", "text": f"‚ùå Error: {str(e)}"}]
        
        elif name == "select_seat":
            booking_id = arguments.get("booking_id")
            seat_number = arguments.get("seat_number")
            seat_type = arguments.get("seat_type", "window")
            
            try:
                steps = []
                steps.append("üí∫ **SEAT SELECTION**")
                steps.append(f"üìã Booking: {booking_id}")
                steps.append(f"ü™ë Desired Seat: {seat_number}")
                steps.append(f"üìç Type: {seat_type}")
                steps.append("")
                
                # Step 1: Get booking details
                steps.append("1Ô∏è‚É£ Retrieving booking...")
                booking_response = await api_request("bookings", f"/bookings/{booking_id}")
                
                if "error" in booking_response:
                    steps.append(f"   ‚ùå Booking not found")
                    return [{"type": "text", "text": "\\n".join(steps)}]
                
                booking = booking_response.get("data", booking_response)
                flight_id = booking.get("flight_id", "Unknown")
                passengers = booking.get("passenger_id", "Unknown")
                steps.append(f"   ‚úÖ Flight: {flight_id}")
                
                # Step 2: Check seat availability
                steps.append("\\n2Ô∏è‚É£ Checking seat availability...")
                
                # Validate seat exists and is available
                seat_fee = 0.0
                
                if "exit" in seat_type.lower():
                    seat_fee = 25.0
                elif "bulkhead" in seat_type.lower():
                    seat_fee = 15.0
                
                steps.append(f"   ‚úÖ Seat {seat_number} available")
                if seat_fee > 0:
                    steps.append(f"   üí∞ Seat selection fee: ${seat_fee:.2f}")
                
                # Step 3: Assign seat
                steps.append("\\n3Ô∏è‚É£ Assigning seat...")
                seat_assignment = await api_request(
                    "checkin",
                    f"/checkin/{booking_id}/seat",
                    "POST",
                    {"seat": seat_number, "seat_type": seat_type, "fee": seat_fee}
                )
                
                if "error" not in seat_assignment:
                    steps.append(f"   ‚úÖ Seat {seat_number} assigned successfully")
                else:
                    steps.append(f"   ‚ö†Ô∏è  Seat assignment pending confirmation")
                
                # Step 4: Update booking
                steps.append("\\n4Ô∏è‚É£ Updating booking record...")
                await api_request(
                    "bookings",
                    f"/bookings/{booking_id}",
                    "PUT",
                    {"seat": seat_number, "seat_fee": seat_fee}
                )
                steps.append(f"   ‚úÖ Booking updated")
                
                # Step 5: Send confirmation
                steps.append("\\n5Ô∏è‚É£ Sending confirmation...")
                await api_request(
                    "notifications",
                    "/notifications/send",
                    "POST",
                    {"type": "seat_confirmation", "recipient": passengers, "booking_id": booking_id}
                )
                steps.append(f"   ‚úÖ Confirmation sent")
                
                response = "\\n".join(steps)
                response += "\\n\\n" + "="*60
                response += "\\n**SEAT SELECTED** ‚úÖ\\n"
                response += "="*60
                response += f"\\n\\n**Booking**: {booking_id}"
                response += f"\\n**Flight**: {flight_id}"
                response += f"\\n**Seat**: {seat_number} ({seat_type})"
                if seat_fee > 0:
                    response += f"\\n**Fee**: ${seat_fee:.2f}"
                
                return [{"type": "text", "text": response}]
                
            except Exception as e:
                logger.error(f"Error in select_seat: {e}")
                return [{"type": "text", "text": f"‚ùå Error: {str(e)}"}]
        
        elif name == "manage_baggage":
            booking_id = arguments.get("booking_id")
            action = arguments.get("action")
            baggage_count = arguments.get("baggage_count", 1)
            baggage_type = arguments.get("baggage_type", "standard")
            
            try:
                steps = []
                steps.append("üß≥ **BAGGAGE MANAGEMENT**")
                steps.append(f"üìã Booking: {booking_id}")
                steps.append(f"üîß Action: {action}")
                steps.append(f"üíº Count: {baggage_count} bag(s)")
                steps.append(f"üì¶ Type: {baggage_type}")
                steps.append("")
                
                # Step 1: Get booking details
                steps.append("1Ô∏è‚É£ Retrieving booking...")
                booking_response = await api_request("bookings", f"/bookings/{booking_id}")
                
                if "error" in booking_response:
                    steps.append(f"   ‚ùå Booking not found")
                    return [{"type": "text", "text": "\\n".join(steps)}]
                
                booking = booking_response.get("data", booking_response)
                flight_id = booking.get("flight_id", "Unknown")
                passenger_id = booking.get("passenger_id", "Unknown")
                current_bags = booking.get("checked_bags", 0)
                steps.append(f"   ‚úÖ Current baggage: {current_bags} bag(s)")
                
                # Step 2: Calculate fees
                steps.append("\\n2Ô∏è‚É£ Calculating baggage fees...")
                
                # Fee structure
                fee_per_bag = 35.0  # Standard bag fee
                if baggage_type == "oversize":
                    fee_per_bag = 75.0
                elif baggage_type == "sports_equipment":
                    fee_per_bag = 50.0
                
                # First bag often free, subsequent bags charged
                free_bags = 1
                if action == "add":
                    new_total = current_bags + baggage_count
                    chargeable_bags = max(0, new_total - free_bags)
                    total_fee = chargeable_bags * fee_per_bag
                elif action == "remove":
                    new_total = max(0, current_bags - baggage_count)
                    # Calculate refund if applicable
                    total_fee = -min(current_bags - free_bags, baggage_count) * fee_per_bag
                else:  # modify
                    new_total = baggage_count
                    chargeable_bags = max(0, new_total - free_bags)
                    total_fee = chargeable_bags * fee_per_bag
                
                steps.append(f"   üìä New total: {new_total} bag(s)")
                steps.append(f"   üí∞ Fee: ${abs(total_fee):.2f}" + (" (refund)" if total_fee < 0 else ""))
                
                # Step 3: Update baggage record
                steps.append("\\n3Ô∏è‚É£ Updating baggage records...")
                baggage_update = await api_request(
                    "baggage",
                    f"/baggage/{booking_id}",
                    "POST" if action == "add" else "PUT",
                    {
                        "booking_id": booking_id,
                        "passenger_id": passenger_id,
                        "bags": new_total,
                        "baggage_type": baggage_type,
                        "fee": total_fee
                    }
                )
                
                if "error" not in baggage_update:
                    steps.append(f"   ‚úÖ Baggage updated")
                else:
                    steps.append(f"   ‚ö†Ô∏è  Update pending")
                
                # Step 4: Update booking
                steps.append("\\n4Ô∏è‚É£ Updating booking..." )
                await api_request(
                    "bookings",
                    f"/bookings/{booking_id}",
                    "PUT",
                    {"checked_bags": new_total, "baggage_fee": total_fee}
                )
                steps.append(f"   ‚úÖ Booking updated")
                
                # Step 5: Send confirmation
                steps.append("\\n5Ô∏è‚É£ Sending confirmation...")
                await api_request(
                    "notifications",
                    "/notifications/send",
                    "POST",
                    {"type": "baggage_confirmation", "recipient": passenger_id, "booking_id": booking_id}
                )
                steps.append(f"   ‚úÖ Confirmation sent")
                
                response = "\\n".join(steps)
                response += "\\n\\n" + "="*60
                response += "\\n**BAGGAGE UPDATED** ‚úÖ\\n"
                response += "="*60
                response += f"\\n\\n**Booking**: {booking_id}"
                response += f"\\n**Baggage**: {new_total} bag(s) ({baggage_type})"
                response += f"\\n**Fee**: ${abs(total_fee):.2f}" + (" (refund)" if total_fee < 0 else "")
                
                return [{"type": "text", "text": response}]
                
            except Exception as e:
                logger.error(f"Error in manage_baggage: {e}")
                return [{"type": "text", "text": f"‚ùå Error: {str(e)}"}]
        
        elif name == "update_meal_preference":
            booking_id = arguments.get("booking_id")
            meal_type = arguments.get("meal_type")
            special_requests = arguments.get("special_requests", "")
            
            try:
                steps = []
                steps.append("üçΩÔ∏è **MEAL PREFERENCE UPDATE**")
                steps.append(f"üìã Booking: {booking_id}")
                steps.append(f"ü•ó Meal: {meal_type}")
                if special_requests:
                    steps.append(f"üìù Special requests: {special_requests}")
                steps.append("")
                
                # Step 1: Get booking details
                steps.append("1Ô∏è‚É£ Retrieving booking...")
                booking_response = await api_request("bookings", f"/bookings/{booking_id}")
                
                if "error" in booking_response:
                    steps.append(f"   ‚ùå Booking not found")
                    return [{"type": "text", "text": "\\n".join(steps)}]
                
                booking = booking_response.get("data", booking_response)
                flight_id = booking.get("flight_id", "Unknown")
                passenger_id = booking.get("passenger_id", "Unknown")
                current_meal = booking.get("meal_preference", "standard")
                steps.append(f"   ‚ÑπÔ∏è  Current meal: {current_meal}")
                
                # Step 2: Validate meal availability
                steps.append("\\n2Ô∏è‚É£ Checking meal availability...")
                
                # Check if special meal needs pre-ordering
                special_meals = ["vegan", "kosher", "halal", "gluten_free", "diabetic"]
                needs_preorder = meal_type in special_meals
                
                if needs_preorder:
                    steps.append(f"   ‚ö†Ô∏è  Special meal - requires 48hr advance notice")
                
                steps.append(f"   ‚úÖ {meal_type.title()} meal available")
                
                # Step 3: Update meal preference
                steps.append("\\n3Ô∏è‚É£ Updating meal preference...")
                meal_update = await api_request(
                    "ancillaries",
                    f"/meals/{booking_id}",
                    "POST",
                    {
                        "booking_id": booking_id,
                        "passenger_id": passenger_id,
                        "meal_type": meal_type,
                        "special_requests": special_requests
                    }
                )
                
                if "error" not in meal_update:
                    steps.append(f"   ‚úÖ Meal preference updated")
                else:
                    steps.append(f"   ‚ö†Ô∏è  Update pending confirmation")
                
                # Step 4: Update booking
                steps.append("\\n4Ô∏è‚É£ Updating booking...")
                await api_request(
                    "bookings",
                    f"/bookings/{booking_id}",
                    "PUT",
                    {"meal_preference": meal_type, "special_requests": special_requests}
                )
                steps.append(f"   ‚úÖ Booking updated")
                
                # Step 5: Send confirmation
                steps.append("\\n5Ô∏è‚É£ Sending confirmation...")
                await api_request(
                    "notifications",
                    "/notifications/send",
                    "POST",
                    {"type": "meal_confirmation", "recipient": passenger_id, "booking_id": booking_id}
                )
                steps.append(f"   ‚úÖ Confirmation sent")
                
                response = "\\n".join(steps)
                response += "\\n\\n" + "="*60
                response += "\\n**MEAL PREFERENCE UPDATED** ‚úÖ\\n"
                response += "="*60
                response += f"\\n\\n**Booking**: {booking_id}"
                response += f"\\n**Meal**: {meal_type.title()}"
                if special_requests:
                    response += f"\\n**Special Requests**: {special_requests}"
                if needs_preorder:
                    response += "\\n\\n‚ö†Ô∏è  **Note**: Special meal requires 48hr advance notice"
                
                return [{"type": "text", "text": response}]
                
            except Exception as e:
                logger.error(f"Error in update_meal_preference: {e}")
                return [{"type": "text", "text": f"‚ùå Error: {str(e)}"}]
        
        else:
            return [{"type": "text", "text": f"‚ùå Unknown tool: {name}"}]

    if __name__ == "__main__":
        import asyncio
        from mcp.server.fastmcp import FastMCP
        import uvicorn
        
        mcp_app = FastMCP("ticketing-agent-mcp", stateless_http=True, json_response=True)
        
        @mcp_app.tool()
        async def ping() -> str:
            """Health check tool"""
            result = await call_tool("ping", {})
            return result[0]["text"] if result and len(result) > 0 else "pong"
        
        @mcp_app.tool()
        async def search_flights(
            origin: str = None,
            destination: str = None,
            date: str = None,
            passengers: int = 1,
            cabin_class: str = "economy"
        ) -> str:
            """Intelligently searches for flights with optional parameters"""
            args = {}
            if origin:
                args["origin"] = origin
            if destination:
                args["destination"] = destination
            if date:
                args["date"] = date
            args["passengers"] = passengers
            args["cabin_class"] = cabin_class

            result = await call_tool("search_flights", args)
            return result[0]["text"] if result and len(result) > 0 else str(result)
        
        @mcp_app.tool()
        async def book_flight_itinerary(
            flight_id: str,
            passenger_id: str,
            loyalty_number: str = None,
            seat_preference: str = None,
            include_baggage: bool = False,
            meal_preference: str = "standard"
        ) -> str:
            """Completes end-to-end flight booking process"""
            result = await call_tool("book_flight_itinerary", {
                "flight_id": flight_id,
                "passenger_id": passenger_id,
                "loyalty_number": loyalty_number,
                "seat_preference": seat_preference,
                "include_baggage": include_baggage,
                "meal_preference": meal_preference
            })
            return result[0]["text"] if result and len(result) > 0 else str(result)
        
        @mcp_app.tool()
        async def modify_booking(booking_id: str, new_flight_id: str, reason: str = None) -> str:
            """Modifies an existing booking by changing the flight"""
            result = await call_tool("modify_booking", {
                "booking_id": booking_id,
                "new_flight_id": new_flight_id,
                "reason": reason
            })
            return result[0]["text"] if result and len(result) > 0 else str(result)
        
        @mcp_app.tool()
        async def cancel_booking_with_refund(booking_id: str, reason: str = None) -> str:
            """Cancels an existing booking and processes refund"""
            result = await call_tool("cancel_booking_with_refund", {
                "booking_id": booking_id,
                "reason": reason
            })
            return result[0]["text"] if result and len(result) > 0 else str(result)
        
        @mcp_app.tool()
        async def check_in_and_generate_boarding_pass(booking_id: str, seat_selection: str = None) -> str:
            """Performs online check-in and generates boarding pass"""
            result = await call_tool("check_in_and_generate_boarding_pass", {
                "booking_id": booking_id,
                "seat_selection": seat_selection
            })
            return result[0]["text"] if result and len(result) > 0 else str(result)
        
        @mcp_app.tool()
        async def get_loyalty_status(loyalty_number: str) -> str:
            """Retrieves loyalty program status"""
            result = await call_tool("get_loyalty_status", {"loyalty_number": loyalty_number})
            return result[0]["text"] if result and len(result) > 0 else str(result)
        
        @mcp_app.tool()
        async def redeem_miles_for_flight(
            flight_id: str,
            passenger_id: str,
            loyalty_number: str,
            miles_to_use: int
        ) -> str:
            """Books a flight using loyalty miles"""
            result = await call_tool("redeem_miles_for_flight", {
                "flight_id": flight_id,
                "passenger_id": passenger_id,
                "loyalty_number": loyalty_number,
                "miles_to_use": miles_to_use
            })
            return result[0]["text"] if result and len(result) > 0 else str(result)
        
        @mcp_app.tool()
        async def select_seat(booking_id: str, seat_number: str, seat_type: str = "window") -> str:
            """Allows passengers to select or change their seat"""
            result = await call_tool("select_seat", {
                "booking_id": booking_id,
                "seat_number": seat_number,
                "seat_type": seat_type
            })
            return result[0]["text"] if result and len(result) > 0 else str(result)
        
        @mcp_app.tool()
        async def manage_baggage(
            booking_id: str,
            action: str,
            baggage_count: int = 1,
            baggage_type: str = "standard"
        ) -> str:
            """Add, remove, or modify checked baggage"""
            result = await call_tool("manage_baggage", {
                "booking_id": booking_id,
                "action": action,
                "baggage_count": baggage_count,
                "baggage_type": baggage_type
            })
            return result[0]["text"] if result and len(result) > 0 else str(result)
        
        @mcp_app.tool()
        async def update_meal_preference(
            booking_id: str,
            meal_type: str,
            special_requests: str = None
        ) -> str:
            """Update meal preferences for a passenger"""
            result = await call_tool("update_meal_preference", {
                "booking_id": booking_id,
                "meal_type": meal_type,
                "special_requests": special_requests
            })
            return result[0]["text"] if result and len(result) > 0 else str(result)
        
        logger.info("Starting Ticketing Agent MCP Server with streamable-http...")
        app = mcp_app.streamable_http_app()
        uvicorn.run(app, host="0.0.0.0", port=8080)
  requirements.txt: |
    mcp>=1.3.0
    uvicorn>=0.32.1
    aiohttp==3.9.1
    anyio==4.11.0
    httpx>=0.27.0

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ticketing-agent-mcp
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: ticketing-agent-mcp
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      app: ticketing-agent-mcp
  template:
    metadata:
      labels:
        app: ticketing-agent-mcp
        component: mcp
    spec:
      containers:
        - name: mcp-server
          image: "{{ .Values.mcpImage.repository }}:{{ .Values.mcpImage.tag }}"
          imagePullPolicy: {{ .Values.mcpImage.pullPolicy }}
          ports:
            - containerPort: 8080
          command: ["/bin/sh", "-c"]
          args:
            - |
              pip install --no-cache-dir -r /app/requirements.txt && \
              python /app/main.py
          volumeMounts:
            - name: mcp-code
              mountPath: /app
          resources:
            {{- toYaml .Values.resources | nindent 12 }}
      volumes:
        - name: mcp-code
          configMap:
            name: ticketing-agent-mcp-server

---
apiVersion: v1
kind: Service
metadata:
  name: ticketing-agent-mcp
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: ticketing-agent-mcp
spec:
  type: ClusterIP
  ports:
    - port: 8080
      targetPort: 8080
      name: mcp
  selector:
    app: ticketing-agent-mcp

---
apiVersion: traefik.io/v1alpha1
kind: Middleware
metadata:
  name: ticketing-mcp-gateway
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: ticketing-agent-mcp
spec:
  plugin:
    mcp:
      policies:
        - match: (Equals(`user.groups`, `user`) || Equals(`user.groups`, `ticket-agent`) || Equals(`user.groups`, `partner`)) && Equals(`mcp.method`, `initialize`)
          action: allow
        - match: (Equals(`user.groups`, `user`) || Equals(`user.groups`, `ticket-agent`) || Equals(`user.groups`, `partner`)) && Equals(`mcp.method`, `tools/list`)
          action: allow
        - match: (Equals(`user.groups`, `user`) || Equals(`user.groups`, `ticket-agent`) || Equals(`user.groups`, `partner`)) && Equals(`mcp.method`, `ping`)
          action: allow
        - match: (Equals(`user.groups`, `user`) || Equals(`user.groups`, `ticket-agent`) || Equals(`user.groups`, `partner`)) && Equals(`mcp.method`, `tools/call`)
          action: allow
      defaultAction: allow

---
apiVersion: hub.traefik.io/v1alpha1
kind: API
metadata:
  name: ticketing-agent-api
  namespace: airlines
spec:
  title: "Ticketing Agent MCP"
  description: "MCP Server for Booking & Ticketing"
  cors:
    allowHeadersList: ["Authorization", "Content-Type"]
    allowOriginsList: ["*"]
    allowMethodsList: ["GET", "POST"]
    allowCredentials: true

---
apiVersion: traefik.io/v1alpha1
kind: IngressRoute
metadata:
  name: ticketing-mcp-route
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: ticketing-agent-mcp
  annotations:
    hub.traefik.io/api: ticketing-agent-api
spec:
  entryPoints:
    {{- range .Values.entryPoints }}
    - {{ . }}
    {{- end }}
  routes:
    - kind: Rule
      match: Host(`ticketing-agent.{{ .Values.domain }}`)
      middlewares:
        - name: ticketing-mcp-gateway
      services:
        - name: ticketing-agent-mcp
          port: 8080
