---
apiVersion: v1
kind: ConfigMap
metadata:
  name: ticketing-agent-mcp-server
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: ticketing-agent-mcp
data:
  main.py: |
    #!/usr/bin/env python3
    """
    Ticketing Agent MCP Server
    """

    from typing import Any, Dict, List, Optional
    import logging, aiohttp, anyio, json
    from mcp.server import Server
    from mcp.server.stdio import stdio_server
    from mcp.types import Tool

    # Configure logging
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger("ticketing-agent-mcp")

    # Create MCP server instance
    server = Server("ticketing-agent-mcp")
    
    # API Configuration
    API_BASE_URLS = {
        'flights': '{{ include "airlines.flights.apiUrl" . }}',
        'bookings': '{{ include "airlines.bookings.apiUrl" . }}',
        'tickets': '{{ include "airlines.tickets.apiUrl" . }}',
        'passengers': '{{ include "airlines.passengers.apiUrl" . }}',
        'loyalty': '{{ include "airlines.loyalty.apiUrl" . }}',
        'checkin': '{{ include "airlines.checkin.apiUrl" . }}',
        'pricing': '{{ include "airlines.pricing.apiUrl" . }}',
        'baggage': '{{ include "airlines.baggage.apiUrl" . }}',
        'notifications': '{{ include "airlines.notifications.apiUrl" . }}',
        'ancillaries': '{{ include "airlines.ancillaries.apiUrl" . }}',
    }
    
    # Static JWT Token passed from Helm/Terraform
    jwt_token: str = "{{ index .Values "tool-access" "ticketing" "token" }}"

    @server.list_tools()
    async def list_tools():
        """List available ticketing agent tools"""
        return [
            Tool(
                name="ping",
                description="Health check tool that returns a simple 'pong' response. Use this to verify that the MCP server is running and responsive. It requires no arguments.",
                inputSchema={"type": "object", "properties": {}}
            ),
            Tool(
                name="search_flights",
                description="Searches for available flights based on origin, destination, and date. Use this tool when a user wants to find flight options. It returns a list of flights with pricing and availability. Requires origin, destination, and date.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "origin": {"type": "string", "description": "Origin airport code (e.g., 'JFK')"},
                        "destination": {"type": "string", "description": "Destination airport code (e.g., 'LAX')"},
                        "date": {"type": "string", "description": "Travel date in YYYY-MM-DD format"},
                        "passengers": {"type": "integer", "description": "Number of passengers (default: 1)", "default": 1},
                        "cabin_class": {
                            "type": "string",
                            "enum": ["economy", "premium_economy", "business", "first"],
                            "description": "Preferred cabin class",
                            "default": "economy"
                        }
                    },
                    "required": ["origin", "destination", "date"]
                }
            ),
            Tool(
                name="book_flight_itinerary",
                description="Completes an end-to-end flight booking process. This tool orchestrates multiple APIs to create a booking, issue a ticket, select seats, and handle loyalty benefits. Use this when a user has selected a specific flight and wants to proceed with booking. Requires flight_id and passenger_id.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "flight_id": {"type": "string", "description": "Flight ID from search results"},
                        "passenger_id": {"type": "string", "description": "Passenger ID"},
                        "loyalty_number": {"type": "string", "description": "Optional loyalty program number"},
                        "seat_preference": {"type": "string", "description": "Preferred seat (e.g., '12A')"},
                        "include_baggage": {"type": "boolean", "description": "Include checked baggage", "default": False},
                        "meal_preference": {
                            "type": "string",
                            "enum": ["standard", "vegetarian", "vegan", "kosher", "halal", "gluten_free"],
                            "description": "Meal preference",
                            "default": "standard"
                        }
                    },
                    "required": ["flight_id", "passenger_id"]
                }
            ),
            Tool(
                name="modify_booking",
                description="Modifies an existing booking by changing the flight. This tool calculates change fees and processes the rebooking. Use this when a user wants to change their flight. Requires booking_id and new_flight_id.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "booking_id": {"type": "string", "description": "Existing booking reference"},
                        "new_flight_id": {"type": "string", "description": "New flight ID"},
                        "reason": {"type": "string", "description": "Reason for modification"}
                    },
                    "required": ["booking_id", "new_flight_id"]
                }
            ),
            Tool(
                name="cancel_booking_with_refund",
                description="Cancels an existing booking and processes any applicable refund. Use this tool when a user wishes to cancel their trip. It checks fare rules and loyalty status to determine refund eligibility. Requires booking_id.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "booking_id": {"type": "string", "description": "Booking reference to cancel"},
                        "reason": {"type": "string", "description": "Cancellation reason"}
                    },
                    "required": ["booking_id"]
                }
            ),
            Tool(
                name="check_in_and_generate_boarding_pass",
                description="Performs online check-in for a passenger and generates their boarding pass. Use this tool when a user is ready to check in for their flight. It can also handle seat selection during check-in. Requires booking_id.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "booking_id": {"type": "string", "description": "Booking reference"},
                        "seat_selection": {"type": "string", "description": "Desired seat number"}
                    },
                    "required": ["booking_id"]
                }
            ),
            Tool(
                name="get_loyalty_status",
                description="Retrieves detailed information about a customer's loyalty program status. Use this tool to check miles balance, tier status, and available benefits. Requires loyalty_number.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "loyalty_number": {"type": "string", "description": "Loyalty program number"}
                    },
                    "required": ["loyalty_number"]
                }
            ),
            Tool(
                name="redeem_miles_for_flight",
                description="Books a flight using loyalty miles instead of currency. This tool handles the redemption process and applies tier benefits. Use this when a user wants to use their miles for a flight. Requires flight_id, passenger_id, loyalty_number, and miles_to_use.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "flight_id": {"type": "string", "description": "Flight ID"},
                        "passenger_id": {"type": "string", "description": "Passenger ID"},
                        "loyalty_number": {"type": "string", "description": "Loyalty program number"},
                        "miles_to_use": {"type": "integer", "description": "Number of miles to redeem"}
                    },
                    "required": ["flight_id", "passenger_id", "loyalty_number", "miles_to_use"]
                }
            )
        ]

    async def get_jwt_token() -> str:
        """Get JWT token (static)"""
        return jwt_token

    async def api_request(service: str, endpoint: str, method: str = "GET", data: Dict | None = None) -> Dict:
        """Make authenticated API request and return response"""
        token = await get_jwt_token()
        url = f"{API_BASE_URLS[service]}{endpoint}"
        headers = {"Authorization": f"Bearer {token}"}
        if method in ["POST", "PUT", "PATCH"]:
            headers["Content-Type"] = "application/json"
        
        async with aiohttp.ClientSession() as session:
            async with session.request(method, url, headers=headers, json=data) as r:
                response_text = await r.text()
                if r.status == 200:
                    try:
                        return await r.json() if not response_text else json.loads(response_text)
                    except Exception as e:
                        logger.warning(f"JSON parse error for {url}: {e}")
                        return {"data": response_text, "status": 200}
                elif r.status == 201:
                    try:
                        return {"status": "created", "data": await r.json() if response_text else {}}
                    except:
                        return {"status": "created"}
                elif r.status == 404:
                    return {"error": "Not found", "status": 404}
                else:
                    return {"error": f"API error {r.status}: {response_text}", "status": r.status}

    @server.call_tool()
    async def call_tool(name: str, arguments: dict):
        """Handle tool calls with detailed execution tracing"""
        logger.info(f"Tool called: {name} with args: {arguments}")
        
        if name == "ping":
            return [{"type": "text", "text": "pong - Ticketing Agent MCP Server is operational"}]
        
        elif name == "search_flights":
            origin = arguments.get("origin")
            destination = arguments.get("destination")
            date = arguments.get("date")
            passengers = arguments.get("passengers", 1)
            cabin_class = arguments.get("cabin_class", "economy")
            
            try:
                steps = []
                steps.append("âœˆï¸ **FLIGHT SEARCH INITIATED**")
                steps.append(f"ðŸ“ Route: {origin} â†’ {destination}")
                steps.append(f"ðŸ“… Date: {date}")
                steps.append(f"ðŸ‘¥ Passengers: {passengers}")
                steps.append(f"ðŸ’º Class: {cabin_class}")
                steps.append("")
                
                # Step 1: Search flights
                steps.append("1ï¸âƒ£ Searching available flights...")
                search_result = await api_request(
                    "flights",
                    f"/flights/search?origin={origin}&dest={destination}&date={date}"
                )
                
                if "error" in search_result:
                    steps.append(f"   âŒ Error: {search_result['error']}")
                    return [{"type": "text", "text": "\\n".join(steps)}]
                
                flights_data = search_result.get("flights", [])
                if isinstance(flights_data, dict):
                    flights = list(flights_data.values())
                else:
                    flights = flights_data
                steps.append(f"   âœ… Found {len(flights)} flights")
                
                # Step 2: Get pricing for each flight
                steps.append("\\n2ï¸âƒ£ Fetching pricing information...")
                priced_flights = []
                for flight in flights[:5]:  # Limit to top 5
                    flight_id = flight.get("id", "unknown")
                    pricing = await api_request(
                        "pricing",
                        f"/pricing/calculate",
                        "POST",
                        {"flight_id": flight_id, "cabin_class": cabin_class, "passengers": passengers}
                    )
                    
                    if "error" not in pricing:
                        flight["pricing"] = pricing
                        priced_flights.append(flight)
                        price = pricing.get("total", 0)
                        steps.append(f"   âœ… Flight {flight_id}: ${price:.2f}")
                    else:
                        steps.append(f"   âš ï¸  Flight {flight_id}: Pricing unavailable")
                
                # Step 3: Check seat availability
                steps.append("\\n3ï¸âƒ£ Checking seat availability...")
                for flight in priced_flights:
                    flight_id = flight.get("flight_id")
                    inventory = await api_request("flights", f"/flights/{flight_id}/inventory")
                    if "error" not in inventory:
                        available_seats = inventory.get("available_seats", 0)
                        flight["available_seats"] = available_seats
                        steps.append(f"   âœ… Flight {flight_id}: {available_seats} seats available")
                
                # Build response
                response = "\\n".join(steps)
                response += "\\n\\n**AVAILABLE FLIGHTS**:\\n"
                for i, flight in enumerate(priced_flights, 1):
                    dept_time = flight.get("departure_time", "Unknown")
                    arr_time = flight.get("arrival_time", "Unknown")
                    flight_num = flight.get("flight_id", "Unknown")
                    price = flight["pricing"].get("total", 0) if "pricing" in flight else 0
                    seats = flight.get("available_seats", "?")
                    
                    response += f"\\n{i}. **Flight {flight_num}** (ID: {flight.get('flight_id')})\\n"
                    response += f"   Departure: {dept_time} | Arrival: {arr_time}\\n"
                    response += f"   Price: ${price:.2f} | Seats: {seats}\\n"
                
                response += "\\n\\n**Next Step**: Use `book_flight_itinerary` with a flight_id to complete booking"
                
                return [{"type": "text", "text": response}]
                
            except Exception as e:
                logger.error(f"Error in search_flights: {e}")
                return [{"type": "text", "text": f"âŒ System error during flight search: {str(e)}"}]
        
        elif name == "book_flight_itinerary":
            flight_id = arguments.get("flight_id")
            passenger_id = arguments.get("passenger_id")
            loyalty_number = arguments.get("loyalty_number")
            seat_preference = arguments.get("seat_preference")
            include_baggage = arguments.get("include_baggage", False)
            meal_preference = arguments.get("meal_preference", "standard")
            
            try:
                steps = []
                warnings = []
                errors = []
                
                steps.append("ðŸŽ« **FLIGHT BOOKING PROCESS INITIATED**")
                steps.append(f"âœˆï¸  Flight ID: {flight_id}")
                steps.append(f"ðŸ‘¤ Passenger ID: {passenger_id}")
                steps.append("")
                
                # Step 1: Get flight details
                steps.append("1ï¸âƒ£ Retrieving flight information...")
                flight_response = await api_request("flights", f"/flights/{flight_id}")
                if "error" in flight_response:
                    errors.append(f"Flight not found: {flight_response['error']}")
                    steps.append(f"   âŒ {errors[-1]}")
                    return [{"type": "text", "text": "\\n".join(steps)}]
                
                # Handle API response variations
                flight = flight_response
                if "flights" in flight_response:
                    flights_data = flight_response["flights"]
                    if isinstance(flights_data, dict) and flight_id in flights_data:
                        flight = flights_data[flight_id]
                    elif isinstance(flights_data, list):
                        found = next((f for f in flights_data if f.get("flight_id") == flight_id), None)
                        if found:
                            flight = found
                
                # Check if we actually have the flight data
                if not flight or "flight_id" not in flight:
                     # Fallback logic if needed
                     pass
                
                flight_num = flight.get("flight_id", "Unknown")
                origin = flight.get("origin", "???")
                dest = flight.get("destination", "???")
                dept_time = flight.get("departure_time", "Unknown")
                steps.append(f"   âœ… Flight {flight_num}: {origin} â†’ {dest} at {dept_time}")
                
                # Step 2: Get passenger details
                steps.append("\\n2ï¸âƒ£ Verifying passenger information...")
                passenger = await api_request("passengers", f"/passengers/{passenger_id}")
                if "error" in passenger:
                    errors.append(f"Passenger not found: {passenger['error']}")
                    steps.append(f"   âŒ {errors[-1]}")
                    return [{"type": "text", "text": "\\n".join(steps)}]
                
                passenger_name = passenger.get("name", "Unknown")
                steps.append(f"   âœ… Passenger: {passenger_name}")
                
                # Step 3: Check loyalty status (if provided)
                loyalty_discount = 0
                loyalty_tier = "None"
                if loyalty_number:
                    steps.append("\\n3ï¸âƒ£ Checking loyalty program benefits...")
                    loyalty = await api_request("loyalty", f"/loyalty/members/{loyalty_number}")
                    if "error" not in loyalty:
                        loyalty_tier = loyalty.get("tier", "Standard")
                        miles_available = loyalty.get("miles", 0)
                        steps.append(f"   âœ… Tier: {loyalty_tier} | Miles: {miles_available:,}")
                        
                        # Calculate tier discount
                        if loyalty_tier == "Gold":
                            loyalty_discount = 0.10
                        elif loyalty_tier == "Platinum":
                            loyalty_discount = 0.15
                        elif loyalty_tier == "Diamond":
                            loyalty_discount = 0.20
                        
                        if loyalty_discount > 0:
                            steps.append(f"   ðŸŽ {int(loyalty_discount * 100)}% loyalty discount applied")
                    else:
                        warnings.append(f"Loyalty lookup failed: {loyalty['error']}")
                        steps.append(f"   âš ï¸  {warnings[-1]}")
                
                # Step 4: Calculate pricing
                steps.append("\\n4ï¸âƒ£ Calculating total price...")
                pricing = await api_request(
                    "pricing",
                    "/pricing/calculate",
                    "POST",
                    {"flight_id": flight_id, "cabin_class": "economy", "passengers": 1}
                )
                
                if "error" in pricing:
                    errors.append(f"Pricing calculation failed: {pricing['error']}")
                    steps.append(f"   âŒ {errors[-1]}")
                    return [{"type": "text", "text": "\\n".join(steps)}]
                
                base_fare = pricing.get("base_fare", 0)
                taxes = pricing.get("taxes", 0)
                subtotal = base_fare + taxes
                discount_amount = subtotal * loyalty_discount
                total_price = subtotal - discount_amount
                
                steps.append(f"   âœ… Base Fare: ${base_fare:.2f}")
                steps.append(f"   âœ… Taxes & Fees: ${taxes:.2f}")
                if loyalty_discount > 0:
                    steps.append(f"   âœ… Loyalty Discount: -${discount_amount:.2f}")
                steps.append(f"   âœ… **Total: ${total_price:.2f}**")
                
                # Step 5: Create booking
                steps.append("\\n5ï¸âƒ£ Creating reservation...")
                booking = await api_request(
                    "bookings",
                    "/bookings",
                    "POST",
                    {
                        "flight_id": flight_id,
                        "passenger_id": passenger_id,
                        "total_price": total_price
                    }
                )
                
                if "error" in booking:
                    errors.append(f"Booking creation failed: {booking['error']}")
                    steps.append(f"   âŒ {errors[-1]}")
                    return [{"type": "text", "text": "\\n".join(steps)}]
                
                booking_id = booking.get("data", {}).get("booking_id", "UNKNOWN")
                steps.append(f"   âœ… Booking Reference: **{booking_id}**")
                
                # Step 6: Issue ticket
                steps.append("\\n6ï¸âƒ£ Issuing e-ticket...")
                ticket = await api_request(
                    "tickets",
                    "/tickets/issue",
                    "POST",
                    {"booking_id": booking_id, "passenger_id": passenger_id}
                )
                
                if "error" in ticket:
                    warnings.append(f"Ticket issuance delayed: {ticket['error']}")
                    steps.append(f"   âš ï¸  {warnings[-1]}")
                else:
                    ticket_number = ticket.get("data", {}).get("ticket_number", "PENDING")
                    steps.append(f"   âœ… Ticket Number: {ticket_number}")
                
                # Step 7: Seat selection
                if seat_preference:
                    steps.append("\\n7ï¸âƒ£ Selecting seat...")
                    seat_result = await api_request(
                        "checkin",
                        f"/checkin/{booking_id}/seat",
                        "POST",
                        {"seat": seat_preference}
                    )
                    
                    if "error" in seat_result:
                        # Try to assign any available seat
                        warnings.append(f"Preferred seat {seat_preference} unavailable")
                        steps.append(f"   âš ï¸  {warnings[-1]}")
                        
                        auto_seat = await api_request(
                            "checkin",
                            f"/checkin/{booking_id}/seat/auto",
                            "POST",
                            {}
                        )
                        if "error" not in auto_seat:
                            assigned_seat = auto_seat.get("data", {}).get("seat", "TBD")
                            steps.append(f"   âœ… Auto-assigned seat: {assigned_seat}")
                    else:
                        steps.append(f"   âœ… Seat confirmed: {seat_preference}")
                
                # Step 8: Add baggage if requested
                if include_baggage:
                    steps.append("\\n8ï¸âƒ£ Adding checked baggage...")
                    baggage = await api_request(
                        "baggage",
                        f"/baggage/add",
                        "POST",
                        {"booking_id": booking_id, "bags": 1}
                    )
                    
                    if "error" in baggage:
                        warnings.append(f"Baggage addition failed: {baggage['error']}")
                        steps.append(f"   âš ï¸  {warnings[-1]}")
                    else:
                        bag_fee = baggage.get("data", {}).get("fee", 0)
                        steps.append(f"   âœ… 1 checked bag added (${bag_fee:.2f})")
                
                # Step 9: Record meal preference
                if meal_preference != "standard":
                    steps.append("\\n9ï¸âƒ£ Recording meal preference...")
                    meal = await api_request(
                        "ancillaries",
                        f"/ancillaries/meal",
                        "POST",
                        {"booking_id": booking_id, "preference": meal_preference}
                    )
                    
                    if "error" in meal:
                        warnings.append(f"Meal preference not saved: {meal['error']}")
                        steps.append(f"   âš ï¸  {warnings[-1]}")
                    else:
                        steps.append(f"   âœ… Meal preference: {meal_preference}")
                
                # Step 10: Send confirmation
                steps.append("\\nðŸ”Ÿ Sending booking confirmation...")
                notification = await api_request(
                    "notifications",
                    "/notifications/send",
                    "POST",
                    {
                        "type": "booking_confirmation",
                        "recipient": passenger_id,
                        "booking_id": booking_id
                    }
                )
                
                if "error" in notification:
                    warnings.append(f"Confirmation email failed: {notification['error']}")
                    steps.append(f"   âš ï¸  {warnings[-1]}")
                else:
                    steps.append(f"   âœ… Confirmation sent to passenger")
                
                # Build final response
                response = "\\n".join(steps)
                response += "\\n\\n" + "="*60
                response += "\\n**BOOKING COMPLETED SUCCESSFULLY** âœ…\\n"
                response += "="*60
                response += f"\\n\\n**Booking Reference**: {booking_id}"
                response += f"\\n**Total Price**: ${total_price:.2f}"
                response += f"\\n**APIs Called**: {len([s for s in steps if 'ï¸âƒ£' in s])}"
                response += f"\\n**Warnings**: {len(warnings)}"
                response += f"\\n**Errors**: {len(errors)}"
                
                if warnings:
                    response += "\\n\\n**Warnings**:"
                    for w in warnings:
                        response += f"\\nâ€¢ {w}"
                
                return [{"type": "text", "text": response}]
                
            except Exception as e:
                logger.error(f"Error in book_flight_itinerary: {e}")
                return [{"type": "text", "text": f"âŒ Critical system error during booking: {str(e)}\\n\\nPartial trace:\\n" + "\\n".join(steps)}]
        
        elif name == "get_loyalty_status":
            loyalty_number = arguments.get("loyalty_number")
            
            try:
                steps = []
                steps.append("ðŸ† **LOYALTY STATUS CHECK**")
                steps.append(f"ðŸŽ« Member Number: {loyalty_number}")
                steps.append("")
                
                # Step 1: Get member details
                steps.append("1ï¸âƒ£ Retrieving membership information...")
                loyalty = await api_request("loyalty", f"/loyalty/members/{loyalty_number}")
                
                if "error" in loyalty:
                    steps.append(f"   âŒ Member not found: {loyalty['error']}")
                    return [{"type": "text", "text": "\\n".join(steps)}]
                
                name = loyalty.get("name", "Unknown")
                tier = loyalty.get("tier", "Standard")
                miles = loyalty.get("miles", 0)
                tier_miles = loyalty.get("tier_qualifying_miles", 0)
                member_since = loyalty.get("member_since", "Unknown")
                
                steps.append(f"   âœ… Member: {name}")
                steps.append(f"   âœ… Tier: {tier}")
                steps.append(f"   âœ… Available Miles: {miles:,}")
                steps.append(f"   âœ… Tier Miles: {tier_miles:,}")
                steps.append(f"   âœ… Member Since: {member_since}")
                
                # Step 2: Calculate next tier requirements
                steps.append("\\n2ï¸âƒ£ Calculating tier progress...")
                next_tier_requirements = {
                    "Standard": ("Silver", 25000),
                    "Silver": ("Gold", 50000),
                    "Gold": ("Platinum", 75000),
                    "Platinum": ("Diamond", 100000),
                    "Diamond": ("Diamond", 100000)  # Already at top
                }
                
                next_tier, required_miles = next_tier_requirements.get(tier, ("Unknown", 0))
                miles_needed = max(0, required_miles - tier_miles)
                
                if tier == "Diamond":
                    steps.append(f"   ðŸ† **Already at highest tier!**")
                else:
                    progress_pct = (tier_miles / required_miles * 100) if required_miles > 0 else 0
                    steps.append(f"   ðŸ“Š Progress to {next_tier}: {progress_pct:.1f}%")
                    steps.append(f"   âœˆï¸  {miles_needed:,} miles needed")
                
                # Build response
                response = "\\n".join(steps)
                response += "\\n\\n**TIER BENEFITS**:\\n"
                
                benefits = {
                    "Standard": ["Earn 1 mile per dollar", "Standard booking"],
                    "Silver": ["Earn 1.25 miles per dollar", "Priority check-in", "1 free checked bag"],
                    "Gold": ["Earn 1.5 miles per dollar", "Priority boarding", "2 free checked bags", "10% discount on tickets"],
                    "Platinum": ["Earn 1.75 miles per dollar", "Lounge access", "3 free checked bags", "15% discount on tickets"],
                    "Diamond": ["Earn 2 miles per dollar", "Premium lounge access", "Unlimited free bags", "20% discount", "Complimentary upgrades"]
                }
                
                for benefit in benefits.get(tier, []):
                    response += f"â€¢ {benefit}\\n"
                
                return [{"type": "text", "text": response}]
                
            except Exception as e:
                logger.error(f"Error in get_loyalty_status: {e}")
                return [{"type": "text", "text": f"âŒ System error: {str(e)}"}]
        
        else:
            return [{"type": "text", "text": f"âŒ Unknown tool: {name}"}]

    if __name__ == "__main__":
        import asyncio
        from mcp.server.fastmcp import FastMCP
        import uvicorn
        
        mcp_app = FastMCP("ticketing-agent-mcp", stateless_http=True, json_response=True)
        
        @mcp_app.tool()
        async def ping() -> str:
            """Health check tool"""
            result = await call_tool("ping", {})
            return result[0]["text"] if result and len(result) > 0 else "pong"
        
        @mcp_app.tool()
        async def search_flights(
            origin: str,
            destination: str,
            date: str,
            passengers: int = 1,
            cabin_class: str = "economy"
        ) -> str:
            """Searches for available flights"""
            result = await call_tool("search_flights", {
                "origin": origin,
                "destination": destination,
                "date": date,
                "passengers": passengers,
                "cabin_class": cabin_class
            })
            return result[0]["text"] if result and len(result) > 0 else str(result)
        
        @mcp_app.tool()
        async def book_flight_itinerary(
            flight_id: str,
            passenger_id: str,
            loyalty_number: str = None,
            seat_preference: str = None,
            include_baggage: bool = False,
            meal_preference: str = "standard"
        ) -> str:
            """Completes end-to-end flight booking process"""
            result = await call_tool("book_flight_itinerary", {
                "flight_id": flight_id,
                "passenger_id": passenger_id,
                "loyalty_number": loyalty_number,
                "seat_preference": seat_preference,
                "include_baggage": include_baggage,
                "meal_preference": meal_preference
            })
            return result[0]["text"] if result and len(result) > 0 else str(result)
        
        @mcp_app.tool()
        async def modify_booking(booking_id: str, new_flight_id: str, reason: str = None) -> str:
            """Modifies an existing booking by changing the flight"""
            result = await call_tool("modify_booking", {
                "booking_id": booking_id,
                "new_flight_id": new_flight_id,
                "reason": reason
            })
            return result[0]["text"] if result and len(result) > 0 else str(result)
        
        @mcp_app.tool()
        async def cancel_booking_with_refund(booking_id: str, reason: str = None) -> str:
            """Cancels an existing booking and processes refund"""
            result = await call_tool("cancel_booking_with_refund", {
                "booking_id": booking_id,
                "reason": reason
            })
            return result[0]["text"] if result and len(result) > 0 else str(result)
        
        @mcp_app.tool()
        async def check_in_and_generate_boarding_pass(booking_id: str, seat_selection: str = None) -> str:
            """Performs online check-in and generates boarding pass"""
            result = await call_tool("check_in_and_generate_boarding_pass", {
                "booking_id": booking_id,
                "seat_selection": seat_selection
            })
            return result[0]["text"] if result and len(result) > 0 else str(result)
        
        @mcp_app.tool()
        async def get_loyalty_status(loyalty_number: str) -> str:
            """Retrieves loyalty program status"""
            result = await call_tool("get_loyalty_status", {"loyalty_number": loyalty_number})
            return result[0]["text"] if result and len(result) > 0 else str(result)
        
        @mcp_app.tool()
        async def redeem_miles_for_flight(
            flight_id: str,
            passenger_id: str,
            loyalty_number: str,
            miles_to_use: int
        ) -> str:
            """Books a flight using loyalty miles"""
            result = await call_tool("redeem_miles_for_flight", {
                "flight_id": flight_id,
                "passenger_id": passenger_id,
                "loyalty_number": loyalty_number,
                "miles_to_use": miles_to_use
            })
            return result[0]["text"] if result and len(result) > 0 else str(result)
        
        logger.info("Starting Ticketing Agent MCP Server with streamable-http...")
        app = mcp_app.streamable_http_app()
        uvicorn.run(app, host="0.0.0.0", port=8080)
  requirements.txt: |
    mcp>=1.3.0
    uvicorn>=0.32.1
    aiohttp==3.9.1
    anyio==4.11.0
    httpx>=0.27.0

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ticketing-agent-mcp
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: ticketing-agent-mcp
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      app: ticketing-agent-mcp
  template:
    metadata:
      labels:
        app: ticketing-agent-mcp
        component: mcp
    spec:
      containers:
        - name: mcp-server
          image: "{{ .Values.mcpImage.repository }}:{{ .Values.mcpImage.tag }}"
          imagePullPolicy: {{ .Values.mcpImage.pullPolicy }}
          ports:
            - containerPort: 8080
          command: ["/bin/sh", "-c"]
          args:
            - |
              pip install --no-cache-dir -r /app/requirements.txt && \
              python /app/main.py
          volumeMounts:
            - name: mcp-code
              mountPath: /app
          resources:
            {{- toYaml .Values.resources | nindent 12 }}
      volumes:
        - name: mcp-code
          configMap:
            name: ticketing-agent-mcp-server

---
apiVersion: v1
kind: Service
metadata:
  name: ticketing-agent-mcp
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: ticketing-agent-mcp
spec:
  type: ClusterIP
  ports:
    - port: 8080
      targetPort: 8080
      name: mcp
  selector:
    app: ticketing-agent-mcp

---
apiVersion: traefik.io/v1alpha1
kind: Middleware
metadata:
  name: ticketing-mcp-gateway
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: ticketing-agent-mcp
spec:
  plugin:
    mcp:
      policies:
        - match: (Equals(`user.groups`, `user`) || Equals(`user.groups`, `ticket-agent`) || Equals(`user.groups`, `partner`)) && Equals(`mcp.method`, `initialize`)
          action: allow
        - match: (Equals(`user.groups`, `user`) || Equals(`user.groups`, `ticket-agent`) || Equals(`user.groups`, `partner`)) && Equals(`mcp.method`, `tools/list`)
          action: allow
        - match: (Equals(`user.groups`, `user`) || Equals(`user.groups`, `ticket-agent`) || Equals(`user.groups`, `partner`)) && Equals(`mcp.method`, `ping`)
          action: allow
        - match: (Equals(`user.groups`, `user`) || Equals(`user.groups`, `ticket-agent`) || Equals(`user.groups`, `partner`)) && Equals(`mcp.method`, `tools/call`)
          action: allow
      defaultAction: allow

---
apiVersion: hub.traefik.io/v1alpha1
kind: API
metadata:
  name: ticketing-agent-api
  namespace: airlines
spec:
  title: "Ticketing Agent MCP"
  description: "MCP Server for Booking & Ticketing"
  cors:
    allowHeadersList: ["Authorization", "Content-Type"]
    allowOriginsList: ["*"]
    allowMethodsList: ["GET", "POST"]
    allowCredentials: true

---
apiVersion: traefik.io/v1alpha1
kind: IngressRoute
metadata:
  name: ticketing-mcp-route
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: ticketing-agent-mcp
  annotations:
    hub.traefik.io/api: ticketing-agent-api
spec:
  entryPoints:
    {{- range .Values.entryPoints }}
    - {{ . }}
    {{- end }}
  routes:
    - kind: Rule
      match: Host(`ticketing-agent.{{ .Values.domain }}`)
      middlewares:
        - name: ticketing-mcp-gateway
      services:
        - name: ticketing-agent-mcp
          port: 8080
