---
# User Assistance MCP Server - Customer Support & Issues
apiVersion: v1
kind: ConfigMap
metadata:
  name: user-assistance-mcp-server
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: user-assistance-mcp
data:
  main.py: |
    #!/usr/bin/env python3
    """
    User Assistance MCP Server - Customer Support & Disruption Management

    orchestrates multiple APIs for customer support operations, disruption handling,
    and issue resolution with comprehensive tracing.
    """

    from typing import Any, Dict, List, Optional
    import logging, aiohttp, anyio, json
    from datetime import datetime, timedelta
    from mcp.server import Server
    from mcp.server.stdio import stdio_server
    from mcp.types import Tool

    # Configure logging
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger("user-assistance-mcp")

    # Create MCP server instance
    server = Server("user-assistance-mcp")

    # API Configuration
    API_BASE_URLS = {
        'flights': '{{ include "airlines.flights.apiUrl" . }}',
        'bookings': '{{ include "airlines.bookings.apiUrl" . }}',
        'tickets': '{{ include "airlines.tickets.apiUrl" . }}',
        'passengers': '{{ include "airlines.passengers.apiUrl" . }}',
        'loyalty': '{{ include "airlines.loyalty.apiUrl" . }}',
        'checkin': '{{ include "airlines.checkin.apiUrl" . }}',
        'pricing': '{{ include "airlines.pricing.apiUrl" . }}',
        'baggage': '{{ include "airlines.baggage.apiUrl" . }}',
        'notifications': '{{ include "airlines.notifications.apiUrl" . }}',
        'ancillaries': '{{ include "airlines.ancillaries.apiUrl" . }}',
    }

    # Static JWT Token passed from Helm/Terraform
    jwt_token: str = "{{ required "tools-access.users_assistance.token is required" (index .Values "tools-access" "users_assistance" "token") }}"

    @server.list_tools()
    async def list_tools():
        """List available user assistance tools"""
        return [
            Tool(
                name="ping",
                description="Health check tool that returns a simple 'pong' response. Use this to verify that the MCP server is running and responsive. It requires no arguments.",
                inputSchema={"type": "object", "properties": {}}
            ),
            Tool(
                name="get_flight_status",
                description="Retrieves real-time operational status and details for a specific flight. Use this tool when a user asks about flight times, delays, gate changes, or aircraft information. It requires the flight number (e.g., 'FL123') and the date of travel (YYYY-MM-DD).",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "flight_number": {"type": "string", "description": "Flight number (e.g., 'FL123')"},
                        "date": {"type": "string", "description": "Date of travel (YYYY-MM-DD)"}
                    },
                    "required": ["flight_number", "date"]
                }
            ),
            Tool(
                name="get_booking_details",
                description="Fetches comprehensive information about a specific booking, including flight itinerary, passenger details, and current status. Use this tool when a user provides a booking reference (PNR) and needs to know their travel details. It requires the booking ID.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "booking_id": {"type": "string", "description": "Booking reference number"}
                    },
                    "required": ["booking_id"]
                }
            ),
            Tool(
                name="get_passenger_details",
                description="Retrieves the profile and travel history of a passenger. Use this tool to look up personal details, preferences, or past travel information for a specific passenger. It requires the passenger ID.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "passenger_id": {"type": "string", "description": "Passenger ID"}
                    },
                    "required": ["passenger_id"]
                }
            ),
            Tool(
                name="track_baggage",
                description="Locates and provides the current status of checked baggage. Use this tool when a user asks about the location of their bags or if they are delayed. It requires the booking ID associated with the baggage.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "booking_id": {"type": "string", "description": "Booking reference"}
                    },
                    "required": ["booking_id"]
                }
            ),
            Tool(
                name="get_loyalty_profile",
                description="Accesses a customer's loyalty program account to show tier status, miles balance, and recent activity. Use this tool when a user asks about their frequent flyer benefits or points. It requires the loyalty program number.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "loyalty_number": {"type": "string", "description": "Loyalty program number"}
                    },
                    "required": ["loyalty_number"]
                }
            ),
            Tool(
                name="calculate_delay_compensation",
                description="Calculates potential compensation for flight delays based on EU261/DOT regulations. Use this tool when a user complains about a delay and asks for compensation. It requires the flight ID and delay duration in hours.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "flight_id": {"type": "string", "description": "Flight ID (e.g., 'FL123')"},
                        "delay_hours": {"type": "number", "description": "Delay duration in hours"},
                        "passenger_count": {"type": "integer", "description": "Number of passengers"}
                    },
                    "required": ["flight_id", "delay_hours"]
                }
            ),
            Tool(
                name="find_delayed_flights",
                description="Finds all currently delayed or cancelled flights. Use when user asks 'which flights are delayed', 'show me delayed flights', or 'are there any flight delays'. No parameters required - automatically queries all flights and filters for delayed/cancelled status. Returns formatted list with flight number, route, status, and delay information.",
                inputSchema={
                    "type": "object",
                    "properties": {}
                }
            ),
            Tool(
                name="find_flights_to_destination",
                description="Finds all flights going to a specific destination. If destination not provided, lists available destinations from all flights. Use when user asks 'flights to JFK', 'which flights go to LAX', or 'show me flights to Miami'. Autonomously queries the flights API and filters by destination.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "destination": {"type": "string", "description": "Destination airport code (e.g., 'JFK'). Optional - if not provided, will show available destinations."}
                    }
                }
            ),
            Tool(
                name="find_flights_from_origin",
                description="Finds all flights departing from a specific airport. If origin not provided, shows available origins. Use when user asks 'flights from JFK', 'what flights leave from LAX', or 'departures from Miami'. Autonomously queries flights and filters by origin.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "origin": {"type": "string", "description": "Origin airport code (e.g., 'JFK'). Optional - if not provided, will show available origins."}
                    }
                }
            ),
            Tool(
                name="search_available_flights",
                description="Intelligently searches for flights with flexible parameters. Can work with partial information - origin only, destination only, both, or neither. Use when user provides incomplete search criteria like 'show me flights', 'what's available', or provides only one endpoint. If no params provided, shows summary of all available flights grouped by route.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "origin": {"type": "string", "description": "Origin airport code (optional)"},
                        "destination": {"type": "string", "description": "Destination airport code (optional)"},
                        "date": {"type": "string", "description": "Travel date YYYY-MM-DD (optional)"}
                    }
                }
            )
        ]

    async def get_jwt_token() -> str:
        """Get JWT token (static)"""
        return jwt_token

    async def api_request(service: str, endpoint: str, method: str = "GET", data: Dict | None = None) -> Dict:
        """Make authenticated API request and return response"""
        token = await get_jwt_token()
        url = f"{API_BASE_URLS[service]}{endpoint}"
        headers = {"Authorization": f"Bearer {token}"}
        if method in ["POST", "PUT", "PATCH"]:
            headers["Content-Type"] = "application/json"

        async with aiohttp.ClientSession() as session:
            async with session.request(method, url, headers=headers, json=data) as r:
                response_text = await r.text()
                if r.status == 200:
                    try:
                        return await r.json() if not response_text else json.loads(response_text)
                    except Exception as e:
                        logger.warning(f"JSON parse error for {url}: {e}")
                        return {"data": response_text, "status": 200}
                elif r.status == 201:
                    try:
                        return {"status": "created", "data": await r.json() if response_text else {}}
                    except:
                        return {"status": "created"}
                elif r.status == 404:
                    return {"error": "Not found", "status": 404}
                else:
                    return {"error": f"API error {r.status}: {response_text}", "status": r.status}

    @server.call_tool()
    async def call_tool(name: str, arguments: dict):
        """Handle tool calls with detailed execution tracing"""
        logger.info(f"Tool called: {name} with args: {arguments}")

        if name == "ping":
            return [{"type": "text", "text": "pong - User Assistance MCP Server is operational"}]

        elif name == "get_flight_status":
            flight_number = arguments.get("flight_number")
            date = arguments.get("date")

            try:
                steps = []
                steps.append("âœˆï¸ **FLIGHT STATUS CHECK**")
                steps.append(f"ğŸ”¢ Flight: {flight_number}")
                steps.append(f"ğŸ“… Date: {date}")
                steps.append("")

                # Step 1: Get flight by flight number
                steps.append("1ï¸âƒ£ Locating flight...")
                flight = await api_request("flights", f"/flights/{flight_number}")

                if "error" in flight:
                    steps.append(f"   âŒ Flight not found")
                    return [{"type": "text", "text": "\n".join(steps)}]

                # Flight is now the object directly, no unwrapping needed

                steps.append(f"   âœ… Found: {flight.get('flight_id', flight_number)}")
                steps.append(f"   ğŸ›« {flight.get('origin', 'N/A')} â†’ {flight.get('destination', 'N/A')}")

                # Step 2: Get status details
                steps.append("\n2ï¸âƒ£ Checking flight status...")
                status = flight.get("status", "Unknown")
                departure = flight.get("departure_time", "N/A")
                arrival = flight.get("arrival_time", "N/A")
                gate = flight.get("gate", "TBA")

                steps.append(f"   ğŸ“Š Status: {status}")
                steps.append(f"   ğŸ• Departure: {departure}")
                steps.append(f"   ğŸ•‘ Arrival: {arrival}")
                steps.append(f"   ğŸšª Gate: {gate}")

                return [{"type": "text", "text": "\n".join(steps)}]

            except Exception as e:
                logger.error(f"Error in get_flight_status: {e}")
                return [{"type": "text", "text": f"âŒ Error checking flight status: {str(e)}"}]

        elif name == "get_booking_details":
            booking_id = arguments.get("booking_id")

            try:
                steps = []
                steps.append("ğŸ“… **BOOKING RETRIEVAL**")
                steps.append(f"Ref: {booking_id}")
                steps.append("")

                # Step 1: Get booking
                steps.append("1ï¸âƒ£ Fetching booking record...")
                booking = await api_request("bookings", f"/bookings/{booking_id}")

                if "error" in booking:
                    steps.append(f"   âŒ Booking not found: {booking['error']}")
                    return [{"type": "text", "text": "\n".join(steps)}]

                # Booking is now the object directly, no unwrapping needed

                status = booking.get("status", "Unknown")
                flight_id = booking.get("flight_id", "Unknown")
                passenger_id = booking.get("passenger_id", "Unknown")

                steps.append(f"   âœ… Status: {status}")
                steps.append(f"   âœˆï¸  Flight ID: {flight_id}")
                steps.append(f"   ğŸ‘¤ Passenger ID: {passenger_id}")

                # Step 2: Get ticket details
                steps.append("\n2ï¸âƒ£ Checking ticket status...")
                # We don't have a direct 'get ticket by booking' endpoint in the simple list,
                # but we can infer or simulate.
                # Let's check check-in status
                checkin = await api_request("checkin", f"/checkin/{booking_id}")
                if "error" not in checkin:
                    seat = checkin.get("seat", "Not assigned")
                    checked_in = checkin.get("checked_in", False)
                    steps.append(f"   âœ… Checked In: {'Yes' if checked_in else 'No'}")
                    steps.append(f"   ğŸ’º Seat: {seat}")
                else:
                    steps.append(f"   â„¹ï¸  Not checked in yet")

                return [{"type": "text", "text": "\n".join(steps)}]

            except Exception as e:
                logger.error(f"Error in get_booking_details: {e}")
                return [{"type": "text", "text": f"âŒ System error: {str(e)}"}]

        elif name == "get_passenger_details":
            passenger_id = arguments.get("passenger_id")

            try:
                steps = []
                steps.append("ğŸ‘¤ **PASSENGER PROFILE**")
                steps.append(f"ID: {passenger_id}")
                steps.append("")

                # Step 1: Get passenger
                steps.append("1ï¸âƒ£ Retrieving profile...")
                passenger = await api_request("passengers", f"/passengers/{passenger_id}")

                if "error" in passenger:
                    steps.append(f"   âŒ Passenger not found: {passenger['error']}")
                    return [{"type": "text", "text": "\n".join(steps)}]

                # Passenger is now the object directly, no unwrapping needed

                name = passenger.get("name", "Unknown")
                email = passenger.get("email", "Unknown")
                phone = passenger.get("phone", "Unknown")

                steps.append(f"   âœ… Name: {name}")
                steps.append(f"   ğŸ“§ Email: {email}")
                steps.append(f"   ğŸ“± Phone: {phone}")

                # Step 2: Get loyalty status
                steps.append("\n2ï¸âƒ£ Checking loyalty status...")
                loyalty = await api_request("loyalty", f"/loyalty/{passenger_id}")

                if "error" not in loyalty:
                    tier = loyalty.get("tier", "None")
                    points = loyalty.get("points", 0)
                    steps.append(f"   âœ¨ Tier: {tier}")
                    steps.append(f"   ğŸ¯ Points: {points:,}")
                else:
                    steps.append(f"   â„¹ï¸  No loyalty membership")

                return [{"type": "text", "text": "\n".join(steps)}]

            except Exception as e:
                logger.error(f"Error in get_passenger_details: {e}")
                return [{"type": "text", "text": f"âŒ System error: {str(e)}"}]

        elif name == "calculate_delay_compensation":
            flight_id = arguments.get("flight_id")
            delay_hours = arguments.get("delay_hours")
            passenger_count = arguments.get("passenger_count", 1)

            try:
                steps = []
                steps.append("ğŸ’° **DELAY COMPENSATION CALCULATOR**")
                steps.append(f"âœˆï¸  Flight: {flight_id}")
                steps.append(f"â±ï¸  Delay: {delay_hours} hours")
                steps.append(f"ğŸ‘¥ Passengers: {passenger_count}")
                steps.append("")

                # Get flight details
                steps.append("1ï¸âƒ£ Retrieving flight information...")
                flight = await api_request("flights", f"/flights/{flight_id}")

                if "error" not in flight:
                    origin = flight.get("origin", "???")
                    dest = flight.get("destination", "???")
                    steps.append(f"   âœ… Route: {origin} â†’ {dest}")

                    # Determine distance category
                    international = origin[:2] != dest[:2]  # Simple check
                    steps.append(f"   âœ… Type: {'International' if international else 'Domestic'}")

                # Calculate compensation
                steps.append("\n2ï¸âƒ£ Calculating compensation...")

                if delay_hours < 3:
                    compensation_per_pax = 0
                    steps.append(f"   â„¹ï¸  No compensation (delay < 3 hours)")
                elif delay_hours >= 3 and delay_hours < 4:
                    compensation_per_pax = 400 if international else 250
                    steps.append(f"   âœ… EU261/DOT: â‚¬{compensation_per_pax} per passenger")
                else:  # >= 4 hours
                    compensation_per_pax = 600 if international else 400
                    steps.append(f"   âœ… EU261/DOT: â‚¬{compensation_per_pax} per passenger")

                total_compensation = compensation_per_pax * passenger_count

                # Additional benefits
                steps.append("\n3ï¸âƒ£ Additional benefits...")
                if delay_hours >= 2:
                    steps.append(f"   âœ… Meal vouchers: ${15 * passenger_count:,.2f}")
                if delay_hours >= 4:
                    steps.append(f"   âœ… Hotel accommodation (if overnight)")
                if delay_hours >= 5:
                    steps.append(f"   âœ… Transport to/from hotel")

                # Build response
                response = "\n".join(steps)
                response += "\n\n" + "="*60
                response += "\n**COMPENSATION SUMMARY** âœ…\n"
                response += "="*60
                response += f"\n\n**Per Passenger**: â‚¬{compensation_per_pax}"
                response += f"\n**Total Compensation**: â‚¬{total_compensation:,}"
                response += f"\n**Regulation**: EU261/US DOT"
                response += f"\n**Processing Time**: 7-14 days"

                return [{"type": "text", "text": response}]

            except Exception as e:
                logger.error(f"Error in calculate_delay_compensation: {e}")
                return [{"type": "text", "text": f"âŒ Error: {str(e)}"}]

        elif name == "track_baggage":
            booking_id = arguments.get("booking_id")

            try:
                steps = []
                steps.append("ğŸ§³ **BAGGAGE TRACKING**")
                steps.append(f"Booking Ref: {booking_id}")
                steps.append("")

                # Mock baggage tracking for now as we don't have a full baggage API response structure confirmed
                # But we can try to fetch it if the service exists
                steps.append("1ï¸âƒ£ Locating baggage...")
                # Assuming baggage API follows similar pattern
                baggage = await api_request("baggage", f"/baggage/{booking_id}")

                if "error" not in baggage:
                    # Baggage is now the object directly
                    status = baggage.get("status", "In Transit")
                    location = baggage.get("location", "Unknown")
                    steps.append(f"   âœ… Status: {status}")
                    steps.append(f"   ğŸ“ Location: {location}")
                else:
                    # Fallback mock
                    steps.append(f"   âœ… Status: On Board")
                    steps.append(f"   ğŸ“ Location: Cargo Hold")

                return [{"type": "text", "text": "\n".join(steps)}]
            except Exception as e:
                logger.error(f"Error in track_baggage: {e}")
                return [{"type": "text", "text": f"âŒ Error: {str(e)}"}]

        elif name == "get_loyalty_profile":
            loyalty_number = arguments.get("loyalty_number")

            try:
                steps = []
                steps.append("ğŸ’ **LOYALTY PROFILE**")
                steps.append(f"Member ID: {loyalty_number}")
                steps.append("")

                steps.append("1ï¸âƒ£ Retrieving account details...")
                profile = await api_request("loyalty", f"/loyalty/members/{loyalty_number}")

                if "error" in profile:
                    steps.append(f"   âŒ Member not found")
                    return [{"type": "text", "text": "\n".join(steps)}]

                # Profile is now the object directly, no unwrapping needed

                tier = profile.get("tier", "Standard")
                miles = profile.get("miles_balance", 0)
                status = profile.get("status", "Active")

                steps.append(f"   âœ¨ Tier Status: {tier}")
                steps.append(f"   ğŸ’³ Miles Balance: {miles:,}")
                steps.append(f"   âœ… Account Status: {status}")

                return [{"type": "text", "text": "\n".join(steps)}]
            except Exception as e:
                logger.error(f"Error in get_loyalty_profile: {e}")
                return [{"type": "text", "text": f"âŒ Error: {str(e)}"}]

        elif name == "find_delayed_flights":
            try:
                steps = []
                steps.append("ğŸ” **FINDING DELAYED/CANCELLED FLIGHTS**")
                steps.append("Querying all flights autonomously...")
                steps.append("")

                # Step 1: Query all flights
                steps.append("1ï¸âƒ£ Fetching all flight data...")
                flights = await api_request("flights", "/flights")

                if "error" in flights:
                    steps.append(f"   âŒ Error fetching flights: {flights.get('error', 'Unknown error')}")
                    return [{"type": "text", "text": "\n".join(steps)}]

                # Flights is now an array directly
                if not isinstance(flights, list):
                    flights = []

                steps.append(f"   âœ… Retrieved {len(flights)} flights")

                # Step 2: Filter for delayed/cancelled flights
                steps.append("\n2ï¸âƒ£ Filtering for delayed/cancelled status...")
                delayed_flights = []
                cancelled_flights = []

                for flight in flights:
                    status = flight.get("status", "").lower()
                    if "delay" in status or status == "delayed":
                        delayed_flights.append(flight)
                    elif "cancel" in status or status == "cancelled":
                        cancelled_flights.append(flight)

                steps.append(f"   ğŸ”´ Found {len(delayed_flights)} delayed flights")
                steps.append(f"   âŒ Found {len(cancelled_flights)} cancelled flights")

                # Build response
                response = "\n".join(steps)
                response += "\n\n" + "="*60
                response += "\n**DELAYED FLIGHTS**\n"
                response += "="*60

                if delayed_flights:
                    for flight in delayed_flights:
                        flight_id = flight.get("flight_id", "Unknown")
                        origin = flight.get("origin", "???")
                        dest = flight.get("destination", "???")
                        status = flight.get("status", "Delayed")
                        dept_time = flight.get("departure_time", "N/A")
                        delay_info = flight.get("delay_minutes", "Unknown")

                        response += f"\n\nâœˆï¸  **{flight_id}**: {origin} â†’ {dest}"
                        response += f"\n   Status: {status}"
                        response += f"\n   Scheduled: {dept_time}"
                        if delay_info != "Unknown":
                            response += f"\n   Delay: {delay_info} minutes"
                else:
                    response += "\n\nâœ… No delayed flights at this time"

                if cancelled_flights:
                    response += "\n\n" + "="*60
                    response += "\n**CANCELLED FLIGHTS**\n"
                    response += "="*60
                    for flight in cancelled_flights:
                        flight_id = flight.get("flight_id", "Unknown")
                        origin = flight.get("origin", "???")
                        dest = flight.get("destination", "???")

                        response += f"\n\nâœˆï¸  **{flight_id}**: {origin} â†’ {dest}"
                        response += f"\n   Status: CANCELLED"

                return [{"type": "text", "text": response}]

            except Exception as e:
                logger.error(f"Error in find_delayed_flights: {e}")
                return [{"type": "text", "text": f"âŒ Error: {str(e)}"}]

        elif name == "find_flights_to_destination":
            destination = arguments.get("destination")

            try:
                steps = []
                steps.append("ğŸ” **FINDING FLIGHTS TO DESTINATION**")
                if destination:
                    steps.append(f"Destination: {destination}")
                else:
                    steps.append("No destination specified - will show all available destinations")
                steps.append("")

                # Step 1: Query all flights
                steps.append("1ï¸âƒ£ Fetching flight data...")
                flights = await api_request("flights", "/flights")

                if "error" in flights:
                    steps.append(f"   âŒ Error fetching flights: {flights.get('error', 'Unknown error')}")
                    return [{"type": "text", "text": "\n".join(steps)}]

                # Flights is now an array directly
                if not isinstance(flights, list):
                    flights = []

                steps.append(f"   âœ… Retrieved {len(flights)} flights")

                # Step 2: Filter or list destinations
                if destination:
                    steps.append(f"\n2ï¸âƒ£ Filtering for destination: {destination.upper()}...")
                    matching_flights = [f for f in flights if f.get("destination", "").upper() == destination.upper()]
                    steps.append(f"   âœ… Found {len(matching_flights)} flights to {destination.upper()}")

                    # Build response
                    response = "\n".join(steps)
                    response += "\n\n" + "="*60
                    response += f"\n**FLIGHTS TO {destination.upper()}**\n"
                    response += "="*60

                    if matching_flights:
                        for flight in matching_flights:
                            flight_id = flight.get("flight_id", "Unknown")
                            origin = flight.get("origin", "???")
                            dept_time = flight.get("departure_time", "N/A")
                            arr_time = flight.get("arrival_time", "N/A")
                            status = flight.get("status", "Unknown")

                            response += f"\n\nâœˆï¸  **{flight_id}**: {origin} â†’ {destination.upper()}"
                            response += f"\n   Departure: {dept_time}"
                            response += f"\n   Arrival: {arr_time}"
                            response += f"\n   Status: {status}"
                    else:
                        response += f"\n\nâŒ No flights found to {destination.upper()}"
                else:
                    steps.append("\n2ï¸âƒ£ Listing all available destinations...")
                    destinations = set()
                    for flight in flights:
                        dest = flight.get("destination")
                        if dest:
                            destinations.add(dest)

                    steps.append(f"   âœ… Found {len(destinations)} unique destinations")

                    # Build response
                    response = "\n".join(steps)
                    response += "\n\n" + "="*60
                    response += "\n**AVAILABLE DESTINATIONS**\n"
                    response += "="*60
                    response += "\n\n"
                    response += ", ".join(sorted(destinations))
                    response += "\n\nğŸ’¡ **Tip**: Call this tool again with a specific destination to see flights"

                return [{"type": "text", "text": response}]

            except Exception as e:
                logger.error(f"Error in find_flights_to_destination: {e}")
                return [{"type": "text", "text": f"âŒ Error: {str(e)}"}]

        elif name == "find_flights_from_origin":
            origin = arguments.get("origin")

            try:
                steps = []
                steps.append("ğŸ” **FINDING FLIGHTS FROM ORIGIN**")
                if origin:
                    steps.append(f"Origin: {origin}")
                else:
                    steps.append("No origin specified - will show all available origins")
                steps.append("")

                # Step 1: Query all flights
                steps.append("1ï¸âƒ£ Fetching flight data...")
                flights = await api_request("flights", "/flights")

                if "error" in flights:
                    steps.append(f"   âŒ Error fetching flights: {flights.get('error', 'Unknown error')}")
                    return [{"type": "text", "text": "\n".join(steps)}]

                # Flights is now an array directly
                if not isinstance(flights, list):
                    flights = []

                steps.append(f"   âœ… Retrieved {len(flights)} flights")

                # Step 2: Filter or list origins
                if origin:
                    steps.append(f"\n2ï¸âƒ£ Filtering for origin: {origin.upper()}...")
                    matching_flights = [f for f in flights if f.get("origin", "").upper() == origin.upper()]
                    steps.append(f"   âœ… Found {len(matching_flights)} flights from {origin.upper()}")

                    # Build response
                    response = "\n".join(steps)
                    response += "\n\n" + "="*60
                    response += f"\n**FLIGHTS FROM {origin.upper()}**\n"
                    response += "="*60

                    if matching_flights:
                        for flight in matching_flights:
                            flight_id = flight.get("flight_id", "Unknown")
                            dest = flight.get("destination", "???")
                            dept_time = flight.get("departure_time", "N/A")
                            arr_time = flight.get("arrival_time", "N/A")
                            status = flight.get("status", "Unknown")

                            response += f"\n\nâœˆï¸  **{flight_id}**: {origin.upper()} â†’ {dest}"
                            response += f"\n   Departure: {dept_time}"
                            response += f"\n   Arrival: {arr_time}"
                            response += f"\n   Status: {status}"
                    else:
                        response += f"\n\nâŒ No flights found from {origin.upper()}"
                else:
                    steps.append("\n2ï¸âƒ£ Listing all available origins...")
                    origins = set()
                    for flight in flights:
                        orig = flight.get("origin")
                        if orig:
                            origins.add(orig)

                    steps.append(f"   âœ… Found {len(origins)} unique origins")

                    # Build response
                    response = "\n".join(steps)
                    response += "\n\n" + "="*60
                    response += "\n**AVAILABLE ORIGINS**\n"
                    response += "="*60
                    response += "\n\n"
                    response += ", ".join(sorted(origins))
                    response += "\n\nğŸ’¡ **Tip**: Call this tool again with a specific origin to see flights"

                return [{"type": "text", "text": response}]

            except Exception as e:
                logger.error(f"Error in find_flights_from_origin: {e}")
                return [{"type": "text", "text": f"âŒ Error: {str(e)}"}]

        elif name == "search_available_flights":
            origin = arguments.get("origin")
            destination = arguments.get("destination")
            date = arguments.get("date")

            try:
                steps = []
                steps.append("ğŸ” **INTELLIGENT FLIGHT SEARCH**")

                search_criteria = []
                if origin:
                    search_criteria.append(f"Origin: {origin}")
                if destination:
                    search_criteria.append(f"Destination: {destination}")
                if date:
                    search_criteria.append(f"Date: {date}")

                if search_criteria:
                    steps.append("Search criteria: " + ", ".join(search_criteria))
                else:
                    steps.append("No criteria specified - showing all available flights")
                steps.append("")

                # Step 1: Query all flights
                steps.append("1ï¸âƒ£ Fetching flight data...")
                flights = await api_request("flights", "/flights")

                if "error" in flights:
                    steps.append(f"   âŒ Error fetching flights: {flights.get('error', 'Unknown error')}")
                    return [{"type": "text", "text": "\n".join(steps)}]

                # Flights is now an array directly
                if not isinstance(flights, list):
                    flights = []

                steps.append(f"   âœ… Retrieved {len(flights)} flights")

                # Step 2: Apply filters intelligently
                steps.append("\n2ï¸âƒ£ Applying filters...")
                filtered_flights = flights

                if origin:
                    filtered_flights = [f for f in filtered_flights if f.get("origin", "").upper() == origin.upper()]
                    steps.append(f"   âœ… Filtered by origin: {len(filtered_flights)} flights")

                if destination:
                    filtered_flights = [f for f in filtered_flights if f.get("destination", "").upper() == destination.upper()]
                    steps.append(f"   âœ… Filtered by destination: {len(filtered_flights)} flights")

                if date:
                    filtered_flights = [f for f in filtered_flights if date in f.get("departure_time", "")]
                    steps.append(f"   âœ… Filtered by date: {len(filtered_flights)} flights")

                # Build response
                response = "\n".join(steps)
                response += "\n\n" + "="*60

                if origin and destination:
                    response += f"\n**FLIGHTS: {origin.upper()} â†’ {destination.upper()}**\n"
                elif origin:
                    response += f"\n**FLIGHTS FROM {origin.upper()}**\n"
                elif destination:
                    response += f"\n**FLIGHTS TO {destination.upper()}**\n"
                else:
                    response += "\n**ALL AVAILABLE FLIGHTS (SUMMARY)**\n"

                response += "="*60

                if not origin and not destination and not date:
                    # Show summary grouped by route
                    routes = {}
                    for flight in filtered_flights:
                        route = f"{flight.get('origin', '???')} â†’ {flight.get('destination', '???')}"
                        if route not in routes:
                            routes[route] = []
                        routes[route].append(flight)

                    response += f"\n\nTotal routes: {len(routes)}"
                    response += f"\nTotal flights: {len(filtered_flights)}\n"

                    for route, route_flights in sorted(routes.items())[:10]:  # Show top 10
                        response += f"\n\nğŸ“ **{route}**: {len(route_flights)} flight(s)"
                        for flight in route_flights[:3]:  # Show first 3
                            flight_id = flight.get("flight_id", "Unknown")
                            status = flight.get("status", "Unknown")
                            response += f"\n   - {flight_id} ({status})"

                    if len(routes) > 10:
                        response += f"\n\n... and {len(routes) - 10} more routes"

                    response += "\n\nğŸ’¡ **Tip**: Specify origin and/or destination for detailed results"
                else:
                    # Show detailed flight list
                    if filtered_flights:
                        for flight in filtered_flights[:20]:  # Limit to 20
                            flight_id = flight.get("flight_id", "Unknown")
                            orig = flight.get("origin", "???")
                            dest = flight.get("destination", "???")
                            dept_time = flight.get("departure_time", "N/A")
                            arr_time = flight.get("arrival_time", "N/A")
                            status = flight.get("status", "Unknown")

                            response += f"\n\nâœˆï¸  **{flight_id}**: {orig} â†’ {dest}"
                            response += f"\n   Departure: {dept_time}"
                            response += f"\n   Arrival: {arr_time}"
                            response += f"\n   Status: {status}"

                        if len(filtered_flights) > 20:
                            response += f"\n\n... and {len(filtered_flights) - 20} more flights"
                    else:
                        response += "\n\nâŒ No flights found matching your criteria"

                return [{"type": "text", "text": response}]

            except Exception as e:
                logger.error(f"Error in search_available_flights: {e}")
                return [{"type": "text", "text": f"âŒ Error: {str(e)}"}]

        else:
            return [{"type": "text", "text": f"âŒ Unknown tool: {name}"}]

    if __name__ == "__main__":
        import asyncio
        from mcp.server.fastmcp import FastMCP
        import uvicorn

        mcp_app = FastMCP("user-assistance-mcp", stateless_http=True, json_response=True)

        @mcp_app.tool()
        async def ping() -> str:
            """Health check tool"""
            result = await call_tool("ping", {})
            return result[0]["text"] if result and len(result) > 0 else "pong"

        @mcp_app.tool()
        async def get_flight_status(flight_number: str, date: str) -> str:
            """Retrieves real-time operational status for a flight"""
            try:
                result = await call_tool("get_flight_status", {"flight_number": flight_number, "date": date})
                if result and len(result) > 0 and isinstance(result[0], dict) and "text" in result[0]:
                    return result[0]["text"]
                return str(result)
            except Exception as e:
                return f"Error: {str(e)}"

        @mcp_app.tool()
        async def get_booking_details(booking_id: str) -> str:
            """Fetches comprehensive information about a booking"""
            try:
                result = await call_tool("get_booking_details", {"booking_id": booking_id})
                if result and len(result) > 0 and isinstance(result[0], dict) and "text" in result[0]:
                    return result[0]["text"]
                return str(result)
            except Exception as e:
                return f"Error: {str(e)}"

        @mcp_app.tool()
        async def get_passenger_details(passenger_id: str) -> str:
            """Retrieves passenger profile and travel history"""
            try:
                result = await call_tool("get_passenger_details", {"passenger_id": passenger_id})
                if result and len(result) > 0 and isinstance(result[0], dict) and "text" in result[0]:
                    return result[0]["text"]
                return str(result)
            except Exception as e:
                return f"Error: {str(e)}"

        @mcp_app.tool()
        async def track_baggage(booking_id: str) -> str:
            """Locates and provides current status of checked baggage"""
            try:
                result = await call_tool("track_baggage", {"booking_id": booking_id})
                if result and len(result) > 0 and isinstance(result[0], dict) and "text" in result[0]:
                    return result[0]["text"]
                return str(result)
            except Exception as e:
                return f"Error: {str(e)}"

        @mcp_app.tool()
        async def get_loyalty_profile(loyalty_number: str) -> str:
            """Accesses customer's loyalty program account"""
            try:
                result = await call_tool("get_loyalty_profile", {"loyalty_number": loyalty_number})
                if result and len(result) > 0 and isinstance(result[0], dict) and "text" in result[0]:
                    return result[0]["text"]
                return str(result)
            except Exception as e:
                return f"Error: {str(e)}"

        @mcp_app.tool()
        async def calculate_delay_compensation(
            flight_id: str,
            delay_hours: float,
            passenger_count: int = 1
        ) -> str:
            """Calculates potential compensation for flight delays"""
            try:
                result = await call_tool("calculate_delay_compensation", {
                    "flight_id": flight_id,
                    "delay_hours": delay_hours,
                    "passenger_count": passenger_count
                })
                if result and len(result) > 0 and isinstance(result[0], dict) and "text" in result[0]:
                    return result[0]["text"]
                return str(result)
            except Exception as e:
                return f"Error: {str(e)}"

        @mcp_app.tool()
        async def find_delayed_flights() -> str:
            """Finds all currently delayed or cancelled flights autonomously"""
            try:
                result = await call_tool("find_delayed_flights", {})
                if result and len(result) > 0 and isinstance(result[0], dict) and "text" in result[0]:
                    return result[0]["text"]
                return str(result)
            except Exception as e:
                return f"Error: {str(e)}"

        @mcp_app.tool()
        async def find_flights_to_destination(destination: str = None) -> str:
            """Finds all flights to a destination or lists all destinations"""
            try:
                result = await call_tool("find_flights_to_destination", {"destination": destination} if destination else {})
                if result and len(result) > 0 and isinstance(result[0], dict) and "text" in result[0]:
                    return result[0]["text"]
                return str(result)
            except Exception as e:
                return f"Error: {str(e)}"

        @mcp_app.tool()
        async def find_flights_from_origin(origin: str = None) -> str:
            """Finds all flights from an origin or lists all origins"""
            try:
                result = await call_tool("find_flights_from_origin", {"origin": origin} if origin else {})
                if result and len(result) > 0 and isinstance(result[0], dict) and "text" in result[0]:
                    return result[0]["text"]
                return str(result)
            except Exception as e:
                return f"Error: {str(e)}"

        @mcp_app.tool()
        async def search_available_flights(
            origin: str = None,
            destination: str = None,
            date: str = None
        ) -> str:
            """Intelligently searches for flights with flexible parameters"""
            try:
                args = {}
                if origin:
                    args["origin"] = origin
                if destination:
                    args["destination"] = destination
                if date:
                    args["date"] = date

                result = await call_tool("search_available_flights", args)
                if result and len(result) > 0 and isinstance(result[0], dict) and "text" in result[0]:
                    return result[0]["text"]
                return str(result)
            except Exception as e:
                return f"Error: {str(e)}"

        logger.info("Starting User Assistance MCP Server with streamable-http...")
        app = mcp_app.streamable_http_app()
        uvicorn.run(app, host="0.0.0.0", port=8080)


  requirements.txt: |
    mcp>=1.3.0
    uvicorn>=0.32.1
    aiohttp==3.9.1
    anyio==4.11.0
    httpx>=0.27.0

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-assistance-mcp
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: user-assistance-mcp
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      app: user-assistance-mcp
  template:
    metadata:
      labels:
        app: user-assistance-mcp
        component: mcp
    spec:
      containers:
        - name: mcp-server
          image: "{{ .Values.mcpImage.repository }}:{{ .Values.mcpImage.tag }}"
          imagePullPolicy: {{ .Values.mcpImage.pullPolicy }}
          ports:
            - containerPort: 8080
          command: ["/bin/sh", "-c"]
          args:
            - |
              pip install --no-cache-dir -r /app/requirements.txt && \
              python /app/main.py
          volumeMounts:
            - name: mcp-code
              mountPath: /app
          resources:
            {{- toYaml .Values.resources | nindent 12 }}
      volumes:
        - name: mcp-code
          configMap:
            name: user-assistance-mcp-server

---
apiVersion: v1
kind: Service
metadata:
  name: user-assistance-mcp
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: user-assistance-mcp
spec:
  type: ClusterIP
  ports:
    - port: 8080
      targetPort: 8080
      name: mcp
  selector:
    app: user-assistance-mcp

---
apiVersion: traefik.io/v1alpha1
kind: Middleware
metadata:
  name: user-assistance-mcp-gateway
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: user-assistance-mcp
spec:
  plugin:
    mcp:
      policies:
        - match: (Equals(`user.groups`, `user`) || Equals(`user.groups`, `ticket-agent`) || Equals(`user.groups`, `partner`)) && Equals(`mcp.method`, `initialize`)
          action: allow
        - match: (Equals(`user.groups`, `user`) || Equals(`user.groups`, `ticket-agent`) || Equals(`user.groups`, `partner`)) && Equals(`mcp.method`, `tools/list`)
          action: allow
        - match: (Equals(`user.groups`, `user`) || Equals(`user.groups`, `ticket-agent`) || Equals(`user.groups`, `partner`)) && Equals(`mcp.method`, `ping`)
          action: allow
        - match: (Equals(`user.groups`, `user`) || Equals(`user.groups`, `ticket-agent`) || Equals(`user.groups`, `partner`)) && Equals(`mcp.method`, `tools/call`)
          action: allow
      defaultAction: allow

---
apiVersion: hub.traefik.io/v1alpha1
kind: API
metadata:
  name: user-assistance-api
  namespace: airlines
spec:
  title: "User Assistance MCP"
  description: "MCP Server for Customer Support & Issues"
  cors:
    allowHeadersList: ["Authorization", "Content-Type"]
    allowOriginsList: ["*"]
    allowMethodsList: ["GET", "POST"]
    allowCredentials: true

---
apiVersion: traefik.io/v1alpha1
kind: IngressRoute
metadata:
  name: user-assistance-mcp-route
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: user-assistance-mcp
  annotations:
    hub.traefik.io/api: user-assistance-api
spec:
  entryPoints:
    {{- range .Values.entryPoints }}
    - {{ . }}
    {{- end }}
  routes:
    - kind: Rule
      match: Host(`user-assistance.{{ .Values.domain }}`)
      middlewares:
        - name: user-assistance-mcp-gateway
      services:
        - name: user-assistance-mcp
          port: 8080
