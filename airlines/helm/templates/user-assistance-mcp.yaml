---
# User Assistance MCP Server - Customer Support & Issues
apiVersion: v1
kind: ConfigMap
metadata:
  name: user-assistance-mcp-server
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: user-assistance-mcp
data:
  main.py: |
    #!/usr/bin/env python3
    """
    User Assistance MCP Server - Customer Support & Disruption Management
    
    orchestrates multiple APIs for customer support operations, disruption handling,
    and issue resolution with comprehensive tracing.
    """

    from typing import Any, Dict, List, Optional
    import logging, aiohttp, anyio, json
    from datetime import datetime, timedelta
    from mcp.server import Server
    from mcp.server.stdio import stdio_server
    from mcp.types import Tool

    # Configure logging
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger("user-assistance-mcp")

    # Create MCP server instance
    server = Server("user-assistance-mcp")

    # API Configuration
    API_BASE_URLS = {
        'flights': '{{ include "airlines.flights.apiUrl" . }}',
        'bookings': '{{ include "airlines.bookings.apiUrl" . }}',
        'tickets': '{{ include "airlines.tickets.apiUrl" . }}',
        'passengers': '{{ include "airlines.passengers.apiUrl" . }}',
        'loyalty': '{{ include "airlines.loyalty.apiUrl" . }}',
        'checkin': '{{ include "airlines.checkin.apiUrl" . }}',
        'pricing': '{{ include "airlines.pricing.apiUrl" . }}',
        'baggage': '{{ include "airlines.baggage.apiUrl" . }}',
        'notifications': '{{ include "airlines.notifications.apiUrl" . }}',
        'ancillaries': '{{ include "airlines.ancillaries.apiUrl" . }}',
    }
    
    # Static JWT Token passed from Helm/Terraform
    jwt_token: str = "{{ index .Values "tool-access" "users-assistance" "token" }}"

    @server.list_tools()
    async def list_tools():
        """List available user assistance tools"""
        return [
            Tool(
                name="ping",
                description="Health check tool that returns a simple 'pong' response. Use this to verify that the MCP server is running and responsive. It requires no arguments.",
                inputSchema={"type": "object", "properties": {}}
            ),
            Tool(
                name="get_flight_status",
                description="Retrieves real-time operational status and details for a specific flight. Use this tool when a user asks about flight times, delays, gate changes, or aircraft information. It requires the flight number (e.g., 'FL123') and the date of travel (YYYY-MM-DD).",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "flight_number": {"type": "string", "description": "Flight number (e.g., 'FL123')"},
                        "date": {"type": "string", "description": "Date of travel (YYYY-MM-DD)"}
                    },
                    "required": ["flight_number", "date"]
                }
            ),
            Tool(
                name="get_booking_details",
                description="Fetches comprehensive information about a specific booking, including flight itinerary, passenger details, and current status. Use this tool when a user provides a booking reference (PNR) and needs to know their travel details. It requires the booking ID.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "booking_id": {"type": "string", "description": "Booking reference number"}
                    },
                    "required": ["booking_id"]
                }
            ),
            Tool(
                name="get_passenger_details",
                description="Retrieves the profile and travel history of a passenger. Use this tool to look up personal details, preferences, or past travel information for a specific passenger. It requires the passenger ID.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "passenger_id": {"type": "string", "description": "Passenger ID"}
                    },
                    "required": ["passenger_id"]
                }
            ),
            Tool(
                name="track_baggage",
                description="Locates and provides the current status of checked baggage. Use this tool when a user asks about the location of their bags or if they are delayed. It requires the booking ID associated with the baggage.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "booking_id": {"type": "string", "description": "Booking reference"}
                    },
                    "required": ["booking_id"]
                }
            ),
            Tool(
                name="get_loyalty_profile",
                description="Accesses a customer's loyalty program account to show tier status, miles balance, and recent activity. Use this tool when a user asks about their frequent flyer benefits or points. It requires the loyalty program number.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "loyalty_number": {"type": "string", "description": "Loyalty program number"}
                    },
                    "required": ["loyalty_number"]
                }
            )
        ]

    async def get_jwt_token() -> str:
        """Get JWT token (static)"""
        return jwt_token

    async def api_request(service: str, endpoint: str, method: str = "GET", data: Dict | None = None) -> Dict:
        """Make authenticated API request and return response"""
        token = await get_jwt_token()
        url = f"{API_BASE_URLS[service]}{endpoint}"
        headers = {"Authorization": f"Bearer {token}"}
        if method in ["POST", "PUT", "PATCH"]:
            headers["Content-Type"] = "application/json"
        
        async with aiohttp.ClientSession() as session:
            async with session.request(method, url, headers=headers, json=data) as r:
                response_text = await r.text()
                if r.status == 200:
                    try:
                        return await r.json() if not response_text else json.loads(response_text)
                    except Exception as e:
                        logger.warning(f"JSON parse error for {url}: {e}")
                        return {"data": response_text, "status": 200}
                elif r.status == 201:
                    try:
                        return {"status": "created", "data": await r.json() if response_text else {}}
                    except:
                        return {"status": "created"}
                elif r.status == 404:
                    return {"error": "Not found", "status": 404}
                else:
                    return {"error": f"API error {r.status}: {response_text}", "status": r.status}

    @server.call_tool()
    async def call_tool(name: str, arguments: dict):
        """Handle tool calls with detailed execution tracing"""
        logger.info(f"Tool called: {name} with args: {arguments}")
        
        if name == "ping":
            return [{"type": "text", "text": "pong - User Assistance MCP Server is operational"}]
        
        elif name == "get_flight_status":
            flight_number = arguments.get("flight_number")
            date = arguments.get("date")
            
            try:
                steps = []
                steps.append("‚úàÔ∏è **FLIGHT STATUS CHECK**")
                steps.append(f"üî¢ Flight: {flight_number}")
                steps.append(f"üìÖ Date: {date}")
                steps.append("")
                
                # Step 1: Search for flight
                steps.append("1Ô∏è‚É£ Locating flight...")
                # Note: In a real app, we'd search by flight number. Here we simulate finding it.
                # We'll list flights and filter (inefficient but works for demo)
                search = await api_request("flights", f"/flights/search?date={date}&origin=JFK&dest=LHR") # Dummy search
                
                # For demo purposes, we'll just get a specific flight if the search fails or is generic
                flight_id = "FL-101" # Fallback
                
                flight = await api_request("flights", f"/flights/{flight_id}")
                if "error" in flight:
                    steps.append(f"   ‚ùå Flight not found")
                    return [{"type": "text", "text": "\n".join(steps)}]
                
                status = flight.get("status", "Unknown")
                dept_time = flight.get("departure_time", "Unknown")
                arr_time = flight.get("arrival_time", "Unknown")
                gate = flight.get("gate", "TBD")
                
                steps.append(f"   ‚úÖ Status: **{status}**")
                steps.append(f"   üïí Departure: {dept_time}")
                steps.append(f"   üïí Arrival: {arr_time}")
                steps.append(f"   üö™ Gate: {gate}")
                
                return [{"type": "text", "text": "\n".join(steps)}]
                
            except Exception as e:
                logger.error(f"Error in get_flight_status: {e}")
                return [{"type": "text", "text": f"‚ùå System error: {str(e)}"}]

        elif name == "get_booking_details":
            booking_id = arguments.get("booking_id")
            
            try:
                steps = []
                steps.append("üìÖ **BOOKING RETRIEVAL**")
                steps.append(f"Ref: {booking_id}")
                steps.append("")
                
                # Step 1: Get booking
                steps.append("1Ô∏è‚É£ Fetching booking record...")
                booking = await api_request("bookings", f"/bookings/{booking_id}")
                
                if "error" in booking:
                    steps.append(f"   ‚ùå Booking not found: {booking['error']}")
                    return [{"type": "text", "text": "\n".join(steps)}]
                
                status = booking.get("status", "Unknown")
                flight_id = booking.get("flight_id", "Unknown")
                passenger_id = booking.get("passenger_id", "Unknown")
                
                steps.append(f"   ‚úÖ Status: {status}")
                steps.append(f"   ‚úàÔ∏è  Flight ID: {flight_id}")
                steps.append(f"   üë§ Passenger ID: {passenger_id}")
                
                # Step 2: Get ticket details
                steps.append("\n2Ô∏è‚É£ Checking ticket status...")
                # We don't have a direct 'get ticket by booking' endpoint in the simple list, 
                # but we can infer or simulate.
                # Let's check check-in status
                checkin = await api_request("checkin", f"/checkin/{booking_id}")
                if "error" not in checkin:
                    seat = checkin.get("seat", "Not assigned")
                    checked_in = checkin.get("checked_in", False)
                    steps.append(f"   ‚úÖ Checked In: {'Yes' if checked_in else 'No'}")
                    steps.append(f"   üí∫ Seat: {seat}")
                else:
                    steps.append(f"   ‚ÑπÔ∏è  Not checked in yet")
                
                return [{"type": "text", "text": "\n".join(steps)}]
                
            except Exception as e:
                logger.error(f"Error in get_booking_details: {e}")
                return [{"type": "text", "text": f"‚ùå System error: {str(e)}"}]

        elif name == "get_passenger_details":
            passenger_id = arguments.get("passenger_id")
            
            try:
                steps = []
                steps.append("üë§ **PASSENGER PROFILE**")
                steps.append(f"ID: {passenger_id}")
                steps.append("")
                
                # Step 1: Get passenger
                steps.append("1Ô∏è‚É£ Retrieving profile...")
                passenger = await api_request("passengers", f"/passengers/{passenger_id}")
                
                if "error" in passenger:
                    steps.append(f"   ‚ùå Passenger not found: {passenger['error']}")
                    return [{"type": "text", "text": "\n".join(steps)}]
                
                name = passenger.get("name", "Unknown")
                email = passenger.get("email", "Unknown")
                phone = passenger.get("phone", "Unknown")
                
                steps.append(f"   ‚úÖ Name: {name}")
                steps.append(f"   üìß Email: {email}")
                steps.append(f"   üì± Phone: {phone}")
                
                # Step 2: Get loyalty status
                steps.append("\n2Ô∏è‚É£ Checking loyalty status...")
                loyalty = await api_request("loyalty", f"/loyalty/{passenger_id}")
                
                if "error" not in loyalty:
                    tier = loyalty.get("tier", "None")
                    points = loyalty.get("points", 0)
                    steps.append(f"   ‚ú® Tier: {tier}")
                    steps.append(f"   üéØ Points: {points:,}")
                else:
                    steps.append(f"   ‚ÑπÔ∏è  No loyalty membership")
                
                return [{"type": "text", "text": "\n".join(steps)}]
                
            except Exception as e:
                logger.error(f"Error in get_passenger_details: {e}")
                return [{"type": "text", "text": f"‚ùå System error: {str(e)}"}]
        
        elif name == "calculate_delay_compensation":
            flight_id = arguments.get("flight_id")
            delay_hours = arguments.get("delay_hours")
            passenger_count = arguments.get("passenger_count", 1)
            
            try:
                steps = []
                steps.append("üí∞ **DELAY COMPENSATION CALCULATOR**")
                steps.append(f"‚úàÔ∏è  Flight: {flight_id}")
                steps.append(f"‚è±Ô∏è  Delay: {delay_hours} hours")
                steps.append(f"üë• Passengers: {passenger_count}")
                steps.append("")
                
                # Get flight details
                steps.append("1Ô∏è‚É£ Retrieving flight information...")
                flight = await api_request("flights", f"/flights/{flight_id}")
                
                if "error" not in flight:
                    origin = flight.get("origin", "???")
                    dest = flight.get("destination", "???")
                    steps.append(f"   ‚úÖ Route: {origin} ‚Üí {dest}")
                    
                    # Determine distance category
                    international = origin[:2] != dest[:2]  # Simple check
                    steps.append(f"   ‚úÖ Type: {'International' if international else 'Domestic'}")
                
                # Calculate compensation
                steps.append("\n2Ô∏è‚É£ Calculating compensation...")
                
                if delay_hours < 3:
                    compensation_per_pax = 0
                    steps.append(f"   ‚ÑπÔ∏è  No compensation (delay < 3 hours)")
                elif delay_hours >= 3 and delay_hours < 4:
                    compensation_per_pax = 400 if international else 250
                    steps.append(f"   ‚úÖ EU261/DOT: ‚Ç¨{compensation_per_pax} per passenger")
                else:  # >= 4 hours
                    compensation_per_pax = 600 if international else 400
                    steps.append(f"   ‚úÖ EU261/DOT: ‚Ç¨{compensation_per_pax} per passenger")
                
                total_compensation = compensation_per_pax * passenger_count
                
                # Additional benefits
                steps.append("\n3Ô∏è‚É£ Additional benefits...")
                if delay_hours >= 2:
                    steps.append(f"   ‚úÖ Meal vouchers: ${15 * passenger_count:,.2f}")
                if delay_hours >= 4:
                    steps.append(f"   ‚úÖ Hotel accommodation (if overnight)")
                if delay_hours >= 5:
                    steps.append(f"   ‚úÖ Transport to/from hotel")
                
                # Build response
                response = "\n".join(steps)
                response += "\n\n" + "="*60
                response += "\n**COMPENSATION SUMMARY** ‚úÖ\n"
                response += "="*60
                response += f"\n\n**Per Passenger**: ‚Ç¨{compensation_per_pax}"
                response += f"\n**Total Compensation**: ‚Ç¨{total_compensation:,}"
                response += f"\n**Regulation**: EU261/US DOT"
                response += f"\n**Processing Time**: 7-14 days"
                
                return [{"type": "text", "text": response}]
                
            except Exception as e:
                logger.error(f"Error in calculate_delay_compensation: {e}")
                return [{"type": "text", "text": f"‚ùå Error: {str(e)}"}]
        
        else:
            return [{"type": "text", "text": f"‚ùå Unknown tool: {name}"}]

    if __name__ == "__main__":
        import asyncio
        from mcp.server.fastmcp import FastMCP
        import uvicorn
        
        mcp_app = FastMCP("user-assistance-mcp", stateless_http=True, json_response=True)
        
        # Define each tool explicitly with proper signatures
        @mcp_app.tool()
        async def ping() -> str:
            """Health check tool"""
            result = await call_tool("ping", {})
            return result[0]["text"] if result and len(result) > 0 else "pong"
        
        @mcp_app.tool()
        async def get_flight_status(flight_number: str, date: str) -> str:
            """Retrieves real-time operational status for a flight"""
            result = await call_tool("get_flight_status", {"flight_number": flight_number, "date": date})
            return result[0]["text"] if result and len(result) > 0 else str(result)
        
        @mcp_app.tool()
        async def get_booking_details(booking_id: str) -> str:
            """Fetches comprehensive information about a booking"""
            result = await call_tool("get_booking_details", {"booking_id": booking_id})
            return result[0]["text"] if result and len(result) > 0  else str(result)
        
        @mcp_app.tool()
        async def get_passenger_details(passenger_id: str) -> str:
            """Retrieves passenger profile and travel history"""
            result = await call_tool("get_passenger_details", {"passenger_id": passenger_id})
            return result[0]["text"] if result and len(result) > 0 else str(result)
        
        @mcp_app.tool()
        async def track_baggage(booking_id: str) -> str:
            """Locates and provides current status of checked baggage"""
            result = await call_tool("track_baggage", {"booking_id": booking_id})
            return result[0]["text"] if result and len(result) > 0 else str(result)
        
        @mcp_app.tool()
        async def get_loyalty_profile(loyalty_number: str) -> str:
            """Accesses customer's loyalty program account"""
            result = await call_tool("get_loyalty_profile", {"loyalty_number": loyalty_number})
            return result[0]["text"] if result and len(result) > 0 else str(result)
        
        logger.info("Starting User Assistance MCP Server with streamable-http...")
        app = mcp_app.streamable_http_app()
        uvicorn.run(app, host="0.0.0.0", port=8080)


  requirements.txt: |
    mcp>=1.3.0
    uvicorn>=0.32.1
    aiohttp==3.9.1
    anyio==4.11.0
    httpx>=0.27.0

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-assistance-mcp
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: user-assistance-mcp
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      app: user-assistance-mcp
  template:
    metadata:
      labels:
        app: user-assistance-mcp
        component: mcp
    spec:
      containers:
        - name: mcp-server
          image: "{{ .Values.mcpImage.repository }}:{{ .Values.mcpImage.tag }}"
          imagePullPolicy: {{ .Values.mcpImage.pullPolicy }}
          ports:
            - containerPort: 8080
          command: ["/bin/sh", "-c"]
          args:
            - |
              pip install --no-cache-dir -r /app/requirements.txt && \
              python /app/main.py
          volumeMounts:
            - name: mcp-code
              mountPath: /app
          resources:
            {{- toYaml .Values.resources | nindent 12 }}
      volumes:
        - name: mcp-code
          configMap:
            name: user-assistance-mcp-server

---
apiVersion: v1
kind: Service
metadata:
  name: user-assistance-mcp
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: user-assistance-mcp
spec:
  type: ClusterIP
  ports:
    - port: 8080
      targetPort: 8080
      name: mcp
  selector:
    app: user-assistance-mcp

---
apiVersion: traefik.io/v1alpha1
kind: Middleware
metadata:
  name: user-assistance-mcp-gateway
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: user-assistance-mcp
spec:
  plugin:
    mcp:
      policies:
        - match: (Equals(`user.groups`, `user`) || Equals(`user.groups`, `ticket-agent`) || Equals(`user.groups`, `partner`)) && Equals(`mcp.method`, `initialize`)
          action: allow
        - match: (Equals(`user.groups`, `user`) || Equals(`user.groups`, `ticket-agent`) || Equals(`user.groups`, `partner`)) && Equals(`mcp.method`, `tools/list`)
          action: allow
        - match: (Equals(`user.groups`, `user`) || Equals(`user.groups`, `ticket-agent`) || Equals(`user.groups`, `partner`)) && Equals(`mcp.method`, `ping`)
          action: allow
        - match: (Equals(`user.groups`, `user`) || Equals(`user.groups`, `ticket-agent`) || Equals(`user.groups`, `partner`)) && Equals(`mcp.method`, `tools/call`)
          action: allow
      defaultAction: allow

---
apiVersion: hub.traefik.io/v1alpha1
kind: API
metadata:
  name: user-assistance-api
  namespace: airlines
spec:
  title: "User Assistance MCP"
  description: "MCP Server for Customer Support & Issues"
  cors:
    allowHeadersList: ["Authorization", "Content-Type"]
    allowOriginsList: ["*"]
    allowMethodsList: ["GET", "POST"]
    allowCredentials: true

---
apiVersion: traefik.io/v1alpha1
kind: IngressRoute
metadata:
  name: user-assistance-mcp-route
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: user-assistance-mcp
  annotations:
    hub.traefik.io/api: user-assistance-api
spec:
  entryPoints:
    {{- range .Values.entryPoints }}
    - {{ . }}
    {{- end }}
  routes:
    - kind: Rule
      match: Host(`user-assistance.{{ .Values.domain }}`)
      middlewares:
        - name: user-assistance-mcp-gateway
      services:
        - name: user-assistance-mcp
          port: 8080
