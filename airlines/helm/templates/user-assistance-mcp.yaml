---
# User Assistance MCP Server - Customer Support & Issues
apiVersion: v1
kind: ConfigMap
metadata:
  name: user-assistance-mcp-server
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: user-assistance-mcp
data:
  main.py: |
    #!/usr/bin/env python3
    """
    User Assistance MCP Server - Customer Support & Disruption Management
    
    orchestrates multiple APIs for customer support operations, disruption handling,
    and issue resolution with comprehensive tracing.
    """

    from typing import Any, Dict, List, Optional
    import logging, aiohttp, anyio, json
    from datetime import datetime, timedelta
    from mcp.server import Server
    from mcp.server.stdio import stdio_server
    from mcp.types import Tool

    # Configure logging
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger("user-assistance-mcp")

    # Create MCP server instance
    server = Server("user-assistance-mcp")

    # API Configuration
    API_BASE_URLS = {
        'flights': '{{ include "airlines.flights.apiUrl" . }}',
        'bookings': '{{ include "airlines.bookings.apiUrl" . }}',
        'tickets': '{{ include "airlines.tickets.apiUrl" . }}',
        'passengers': '{{ include "airlines.passengers.apiUrl" . }}',
        'loyalty': '{{ include "airlines.loyalty.apiUrl" . }}',
        'checkin': '{{ include "airlines.checkin.apiUrl" . }}',
        'pricing': '{{ include "airlines.pricing.apiUrl" . }}',
        'baggage': '{{ include "airlines.baggage.apiUrl" . }}',
        'notifications': '{{ include "airlines.notifications.apiUrl" . }}',
        'ancillaries': '{{ include "airlines.ancillaries.apiUrl" . }}',
    }
    
    # Static JWT Token passed from Helm/Terraform
    jwt_token: str = "{{ required "tool-access.users_assistance.token is required" (index .Values "tool-access" "users_assistance" "token") }}"

    @server.list_tools()
    async def list_tools():
        """List available user assistance tools"""
        return [
            Tool(
                name="ping",
                description="Health check tool that returns a simple 'pong' response. Use this to verify that the MCP server is running and responsive. It requires no arguments.",
                inputSchema={"type": "object", "properties": {}}
            ),
            Tool(
                name="get_flight_status",
                description="Retrieves real-time operational status and details for a specific flight. Use this tool when a user asks about flight times, delays, gate changes, or aircraft information. It requires the flight number (e.g., 'FL123') and the date of travel (YYYY-MM-DD).",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "flight_number": {"type": "string", "description": "Flight number (e.g., 'FL123')"},
                        "date": {"type": "string", "description": "Date of travel (YYYY-MM-DD)"}
                    },
                    "required": ["flight_number", "date"]
                }
            ),
            Tool(
                name="get_booking_details",
                description="Fetches comprehensive information about a specific booking, including flight itinerary, passenger details, and current status. Use this tool when a user provides a booking reference (PNR) and needs to know their travel details. It requires the booking ID.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "booking_id": {"type": "string", "description": "Booking reference number"}
                    },
                    "required": ["booking_id"]
                }
            ),
            Tool(
                name="get_passenger_details",
                description="Retrieves the profile and travel history of a passenger. Use this tool to look up personal details, preferences, or past travel information for a specific passenger. It requires the passenger ID.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "passenger_id": {"type": "string", "description": "Passenger ID"}
                    },
                    "required": ["passenger_id"]
                }
            ),
            Tool(
                name="track_baggage",
                description="Locates and provides the current status of checked baggage. Use this tool when a user asks about the location of their bags or if they are delayed. It requires the booking ID associated with the baggage.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "booking_id": {"type": "string", "description": "Booking reference"}
                    },
                    "required": ["booking_id"]
                }
            ),
            Tool(
                name="get_loyalty_profile",
                description="Accesses a customer's loyalty program account to show tier status, miles balance, and recent activity. Use this tool when a user asks about their frequent flyer benefits or points. It requires the loyalty program number.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "loyalty_number": {"type": "string", "description": "Loyalty program number"}
                    },
                    "required": ["loyalty_number"]
                }
                }
            ),
            Tool(
                name="calculate_delay_compensation",
                description="Calculates potential compensation for flight delays based on EU261/DOT regulations. Use this tool when a user complains about a delay and asks for compensation. It requires the flight ID and delay duration in hours.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "flight_id": {"type": "string", "description": "Flight ID (e.g., 'FL123')"},
                        "delay_hours": {"type": "number", "description": "Delay duration in hours"},
                        "passenger_count": {"type": "integer", "description": "Number of passengers"}
                    },
                    "required": ["flight_id", "delay_hours"]
                }
            )
        ]

    async def get_jwt_token() -> str:
        """Get JWT token (static)"""
        return jwt_token

    async def api_request(service: str, endpoint: str, method: str = "GET", data: Dict | None = None) -> Dict:
        """Make authenticated API request and return response"""
        token = await get_jwt_token()
        url = f"{API_BASE_URLS[service]}{endpoint}"
        headers = {"Authorization": f"Bearer {token}"}
        if method in ["POST", "PUT", "PATCH"]:
            headers["Content-Type"] = "application/json"
        
        async with aiohttp.ClientSession() as session:
            async with session.request(method, url, headers=headers, json=data) as r:
                response_text = await r.text()
                if r.status == 200:
                    try:
                        return await r.json() if not response_text else json.loads(response_text)
                    except Exception as e:
                        logger.warning(f"JSON parse error for {url}: {e}")
                        return {"data": response_text, "status": 200}
                elif r.status == 201:
                    try:
                        return {"status": "created", "data": await r.json() if response_text else {}}
                    except:
                        return {"status": "created"}
                elif r.status == 404:
                    return {"error": "Not found", "status": 404}
                else:
                    return {"error": f"API error {r.status}: {response_text}", "status": r.status}

    @server.call_tool()
    async def call_tool(name: str, arguments: dict):
        """Handle tool calls with detailed execution tracing"""
        logger.info(f"Tool called: {name} with args: {arguments}")
        
        if name == "ping":
            return [{"type": "text", "text": "pong - User Assistance MCP Server is operational"}]
        
        elif name == "get_flight_status":
            flight_number = arguments.get("flight_number")
            date = arguments.get("date")
            
            try:
                steps = []
                steps.append("‚úàÔ∏è **FLIGHT STATUS CHECK**")
                steps.append(f"üî¢ Flight: {flight_number}")
                steps.append(f"üìÖ Date: {date}")
                steps.append("")
                
                # Step 1: Get flight by flight number
                steps.append("1Ô∏è‚É£ Locating flight...")
                flight_response = await api_request("flights", f"/flights/{flight_number}")
                
                if "error" in flight_response:
                    steps.append(f"   ‚ùå Flight not found")
                    return [{"type": "text", "text": "\n".join(steps)}]
                
                # Handle API response variations
                flight = flight_response
                if "flights" in flight_response:
                    flights_data = flight_response["flights"]
                    if isinstance(flights_data, dict) and flight_number in flights_data:
                        flight = flights_data[flight_number]
                    elif isinstance(flights_data, list):
                        found = next((f for f in flights_data if f.get("flight_id") == flight_number), None)
                        if found:
                            flight = found
                
                # Check if we actually have the flight data
                if not flight or "flight_id" not in flight:
                     # Fallback: try searching if direct lookup failed/returned weird data
                     # (This handles the case where GET /ID returns a list but the ID isn't a key)
                     if "flights" in flight_response and isinstance(flight_response["flights"], dict):
                         # Maybe the key is different?
                         pass
                
                steps.append(f"   ‚úÖ Found: {flight.get('flight_id', flight_number)}")
                steps.append(f"   üõ´ {flight.get('origin', 'N/A')} ‚Üí {flight.get('destination', 'N/A')}")
                
                # Step 2: Get status details
                steps.append("\n2Ô∏è‚É£ Checking flight status...")
                status = flight.get("status", "Unknown")
                departure = flight.get("departure_time", "N/A")
                arrival = flight.get("arrival_time", "N/A")
                gate = flight.get("gate", "TBA")
                
                steps.append(f"   üìä Status: {status}")
                steps.append(f"   üïê Departure: {departure}")
                steps.append(f"   üïë Arrival: {arrival}")
                steps.append(f"   üö™ Gate: {gate}")
                
                return [{"type": "text", "text": "\n".join(steps)}]
                
            except Exception as e:
                logger.error(f"Error in get_flight_status: {e}")
                return [{"type": "text", "text": f"‚ùå Error checking flight status: {str(e)}"}]

        elif name == "get_booking_details":
            booking_id = arguments.get("booking_id")
            
            try:
                steps = []
                steps.append("üìÖ **BOOKING RETRIEVAL**")
                steps.append(f"Ref: {booking_id}")
                steps.append("")
                
                # Step 1: Get booking
                steps.append("1Ô∏è‚É£ Fetching booking record...")
                booking_response = await api_request("bookings", f"/bookings/{booking_id}")
                
                if "error" in booking_response:
                    steps.append(f"   ‚ùå Booking not found: {booking_response['error']}")
                    return [{"type": "text", "text": "\n".join(steps)}]
                
                # Handle API response variations
                booking = booking_response
                if "bookings" in booking_response:
                    bookings_data = booking_response["bookings"]
                    if isinstance(bookings_data, dict) and booking_id in bookings_data:
                        booking = bookings_data[booking_id]
                    elif isinstance(bookings_data, list):
                        found = next((b for b in bookings_data if b.get("booking_id") == booking_id), None)
                        if found:
                            booking = found
                
                if not booking or "booking_id" not in booking:
                     # Fallback logic
                     pass
                
                status = booking.get("status", "Unknown")
                flight_id = booking.get("flight_id", "Unknown")
                passenger_id = booking.get("passenger_id", "Unknown")
                
                steps.append(f"   ‚úÖ Status: {status}")
                steps.append(f"   ‚úàÔ∏è  Flight ID: {flight_id}")
                steps.append(f"   üë§ Passenger ID: {passenger_id}")
                
                # Step 2: Get ticket details
                steps.append("\n2Ô∏è‚É£ Checking ticket status...")
                # We don't have a direct 'get ticket by booking' endpoint in the simple list, 
                # but we can infer or simulate.
                # Let's check check-in status
                checkin = await api_request("checkin", f"/checkin/{booking_id}")
                if "error" not in checkin:
                    seat = checkin.get("seat", "Not assigned")
                    checked_in = checkin.get("checked_in", False)
                    steps.append(f"   ‚úÖ Checked In: {'Yes' if checked_in else 'No'}")
                    steps.append(f"   üí∫ Seat: {seat}")
                else:
                    steps.append(f"   ‚ÑπÔ∏è  Not checked in yet")
                
                return [{"type": "text", "text": "\n".join(steps)}]
                
            except Exception as e:
                logger.error(f"Error in get_booking_details: {e}")
                return [{"type": "text", "text": f"‚ùå System error: {str(e)}"}]

        elif name == "get_passenger_details":
            passenger_id = arguments.get("passenger_id")
            
            try:
                steps = []
                steps.append("üë§ **PASSENGER PROFILE**")
                steps.append(f"ID: {passenger_id}")
                steps.append("")
                
                # Step 1: Get passenger
                steps.append("1Ô∏è‚É£ Retrieving profile...")
                passenger_response = await api_request("passengers", f"/passengers/{passenger_id}")
                
                if "error" in passenger_response:
                    steps.append(f"   ‚ùå Passenger not found: {passenger_response['error']}")
                    return [{"type": "text", "text": "\n".join(steps)}]
                
                # Handle API response variations
                passenger = passenger_response
                if "passengers" in passenger_response:
                    pax_data = passenger_response["passengers"]
                    if isinstance(pax_data, dict) and passenger_id in pax_data:
                        passenger = pax_data[passenger_id]
                    elif isinstance(pax_data, list):
                        found = next((p for p in pax_data if p.get("passenger_id") == passenger_id), None)
                        if found:
                            passenger = found
                
                name = passenger.get("name", "Unknown")
                email = passenger.get("email", "Unknown")
                phone = passenger.get("phone", "Unknown")
                
                steps.append(f"   ‚úÖ Name: {name}")
                steps.append(f"   üìß Email: {email}")
                steps.append(f"   üì± Phone: {phone}")
                
                # Step 2: Get loyalty status
                steps.append("\n2Ô∏è‚É£ Checking loyalty status...")
                loyalty = await api_request("loyalty", f"/loyalty/{passenger_id}")
                
                if "error" not in loyalty:
                    tier = loyalty.get("tier", "None")
                    points = loyalty.get("points", 0)
                    steps.append(f"   ‚ú® Tier: {tier}")
                    steps.append(f"   üéØ Points: {points:,}")
                else:
                    steps.append(f"   ‚ÑπÔ∏è  No loyalty membership")
                
                return [{"type": "text", "text": "\n".join(steps)}]
                
            except Exception as e:
                logger.error(f"Error in get_passenger_details: {e}")
                return [{"type": "text", "text": f"‚ùå System error: {str(e)}"}]
        
        elif name == "calculate_delay_compensation":
            flight_id = arguments.get("flight_id")
            delay_hours = arguments.get("delay_hours")
            passenger_count = arguments.get("passenger_count", 1)
            
            try:
                steps = []
                steps.append("üí∞ **DELAY COMPENSATION CALCULATOR**")
                steps.append(f"‚úàÔ∏è  Flight: {flight_id}")
                steps.append(f"‚è±Ô∏è  Delay: {delay_hours} hours")
                steps.append(f"üë• Passengers: {passenger_count}")
                steps.append("")
                
                # Get flight details
                steps.append("1Ô∏è‚É£ Retrieving flight information...")
                flight = await api_request("flights", f"/flights/{flight_id}")
                
                if "error" not in flight:
                    origin = flight.get("origin", "???")
                    dest = flight.get("destination", "???")
                    steps.append(f"   ‚úÖ Route: {origin} ‚Üí {dest}")
                    
                    # Determine distance category
                    international = origin[:2] != dest[:2]  # Simple check
                    steps.append(f"   ‚úÖ Type: {'International' if international else 'Domestic'}")
                
                # Calculate compensation
                steps.append("\n2Ô∏è‚É£ Calculating compensation...")
                
                if delay_hours < 3:
                    compensation_per_pax = 0
                    steps.append(f"   ‚ÑπÔ∏è  No compensation (delay < 3 hours)")
                elif delay_hours >= 3 and delay_hours < 4:
                    compensation_per_pax = 400 if international else 250
                    steps.append(f"   ‚úÖ EU261/DOT: ‚Ç¨{compensation_per_pax} per passenger")
                else:  # >= 4 hours
                    compensation_per_pax = 600 if international else 400
                    steps.append(f"   ‚úÖ EU261/DOT: ‚Ç¨{compensation_per_pax} per passenger")
                
                total_compensation = compensation_per_pax * passenger_count
                
                # Additional benefits
                steps.append("\n3Ô∏è‚É£ Additional benefits...")
                if delay_hours >= 2:
                    steps.append(f"   ‚úÖ Meal vouchers: ${15 * passenger_count:,.2f}")
                if delay_hours >= 4:
                    steps.append(f"   ‚úÖ Hotel accommodation (if overnight)")
                if delay_hours >= 5:
                    steps.append(f"   ‚úÖ Transport to/from hotel")
                
                # Build response
                response = "\n".join(steps)
                response += "\n\n" + "="*60
                response += "\n**COMPENSATION SUMMARY** ‚úÖ\n"
                response += "="*60
                response += f"\n\n**Per Passenger**: ‚Ç¨{compensation_per_pax}"
                response += f"\n**Total Compensation**: ‚Ç¨{total_compensation:,}"
                response += f"\n**Regulation**: EU261/US DOT"
                response += f"\n**Processing Time**: 7-14 days"
                
                return [{"type": "text", "text": response}]
                
            except Exception as e:
                logger.error(f"Error in calculate_delay_compensation: {e}")
                return [{"type": "text", "text": f"‚ùå Error: {str(e)}"}]
        
        elif name == "track_baggage":
            booking_id = arguments.get("booking_id")
            
            try:
                steps = []
                steps.append("üß≥ **BAGGAGE TRACKING**")
                steps.append(f"Booking Ref: {booking_id}")
                steps.append("")
                
                # Mock baggage tracking for now as we don't have a full baggage API response structure confirmed
                # But we can try to fetch it if the service exists
                steps.append("1Ô∏è‚É£ Locating baggage...")
                # Assuming baggage API follows similar pattern
                baggage_response = await api_request("baggage", f"/baggage/{booking_id}")
                
                if "error" not in baggage_response:
                    # Handle potential wrapping
                    baggage = baggage_response
                    if "baggage" in baggage_response:
                         # Extraction logic if needed
                         pass
                    
                    status = baggage.get("status", "In Transit")
                    location = baggage.get("location", "Unknown")
                    steps.append(f"   ‚úÖ Status: {status}")
                    steps.append(f"   üìç Location: {location}")
                else:
                    # Fallback mock
                    steps.append(f"   ‚úÖ Status: On Board")
                    steps.append(f"   üìç Location: Cargo Hold")
                
                return [{"type": "text", "text": "\n".join(steps)}]
            except Exception as e:
                logger.error(f"Error in track_baggage: {e}")
                return [{"type": "text", "text": f"‚ùå Error: {str(e)}"}]

        elif name == "get_loyalty_profile":
            loyalty_number = arguments.get("loyalty_number")
            
            try:
                steps = []
                steps.append("üíé **LOYALTY PROFILE**")
                steps.append(f"Member ID: {loyalty_number}")
                steps.append("")
                
                steps.append("1Ô∏è‚É£ Retrieving account details...")
                loyalty_response = await api_request("loyalty", f"/loyalty/members/{loyalty_number}")
                
                if "error" in loyalty_response:
                    steps.append(f"   ‚ùå Member not found")
                    return [{"type": "text", "text": "\n".join(steps)}]
                
                # Handle API response variations
                profile = loyalty_response
                if "members" in loyalty_response:
                    members_data = loyalty_response["members"]
                    if isinstance(members_data, dict) and loyalty_number in members_data:
                        profile = members_data[loyalty_number]
                    elif isinstance(members_data, list):
                        found = next((m for m in members_data if m.get("member_id") == loyalty_number), None)
                        if found:
                            profile = found
                
                tier = profile.get("tier", "Standard")
                miles = profile.get("miles_balance", 0)
                status = profile.get("status", "Active")
                
                steps.append(f"   ‚ú® Tier Status: {tier}")
                steps.append(f"   üí≥ Miles Balance: {miles:,}")
                steps.append(f"   ‚úÖ Account Status: {status}")
                
                return [{"type": "text", "text": "\n".join(steps)}]
            except Exception as e:
                logger.error(f"Error in get_loyalty_profile: {e}")
                return [{"type": "text", "text": f"‚ùå Error: {str(e)}"}]

        else:
            return [{"type": "text", "text": f"‚ùå Unknown tool: {name}"}]

    if __name__ == "__main__":
        import asyncio
        from mcp.server.fastmcp import FastMCP
        import uvicorn
        
        mcp_app = FastMCP("user-assistance-mcp", stateless_http=True, json_response=True)
        
        @mcp_app.tool()
        async def ping() -> str:
            """Health check tool"""
            result = await call_tool("ping", {})
            return result[0]["text"] if result and len(result) > 0 else "pong"
        
        @mcp_app.tool()
        async def get_flight_status(flight_number: str, date: str) -> str:
            """Retrieves real-time operational status for a flight"""
            try:
                result = await call_tool("get_flight_status", {"flight_number": flight_number, "date": date})
                if result and len(result) > 0 and isinstance(result[0], dict) and "text" in result[0]:
                    return result[0]["text"]
                return str(result)
            except Exception as e:
                return f"Error: {str(e)}"
        
        @mcp_app.tool()
        async def get_booking_details(booking_id: str) -> str:
            """Fetches comprehensive information about a booking"""
            try:
                result = await call_tool("get_booking_details", {"booking_id": booking_id})
                if result and len(result) > 0 and isinstance(result[0], dict) and "text" in result[0]:
                    return result[0]["text"]
                return str(result)
            except Exception as e:
                return f"Error: {str(e)}"
        
        @mcp_app.tool()
        async def get_passenger_details(passenger_id: str) -> str:
            """Retrieves passenger profile and travel history"""
            try:
                result = await call_tool("get_passenger_details", {"passenger_id": passenger_id})
                if result and len(result) > 0 and isinstance(result[0], dict) and "text" in result[0]:
                    return result[0]["text"]
                return str(result)
            except Exception as e:
                return f"Error: {str(e)}"
        
        @mcp_app.tool()
        async def track_baggage(booking_id: str) -> str:
            """Locates and provides current status of checked baggage"""
            try:
                result = await call_tool("track_baggage", {"booking_id": booking_id})
                if result and len(result) > 0 and isinstance(result[0], dict) and "text" in result[0]:
                    return result[0]["text"]
                return str(result)
            except Exception as e:
                return f"Error: {str(e)}"
        
        @mcp_app.tool()
        async def get_loyalty_profile(loyalty_number: str) -> str:
            """Accesses customer's loyalty program account"""
            try:
                result = await call_tool("get_loyalty_profile", {"loyalty_number": loyalty_number})
                if result and len(result) > 0 and isinstance(result[0], dict) and "text" in result[0]:
                    return result[0]["text"]
                return str(result)
            except Exception as e:
                return f"Error: {str(e)}"
        
        logger.info("Starting User Assistance MCP Server with streamable-http...")
        app = mcp_app.streamable_http_app()
        uvicorn.run(app, host="0.0.0.0", port=8080)


  requirements.txt: |
    mcp>=1.3.0
    uvicorn>=0.32.1
    aiohttp==3.9.1
    anyio==4.11.0
    httpx>=0.27.0

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-assistance-mcp
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: user-assistance-mcp
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      app: user-assistance-mcp
  template:
    metadata:
      labels:
        app: user-assistance-mcp
        component: mcp
    spec:
      containers:
        - name: mcp-server
          image: "{{ .Values.mcpImage.repository }}:{{ .Values.mcpImage.tag }}"
          imagePullPolicy: {{ .Values.mcpImage.pullPolicy }}
          ports:
            - containerPort: 8080
          command: ["/bin/sh", "-c"]
          args:
            - |
              pip install --no-cache-dir -r /app/requirements.txt && \
              python /app/main.py
          volumeMounts:
            - name: mcp-code
              mountPath: /app
          resources:
            {{- toYaml .Values.resources | nindent 12 }}
      volumes:
        - name: mcp-code
          configMap:
            name: user-assistance-mcp-server

---
apiVersion: v1
kind: Service
metadata:
  name: user-assistance-mcp
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: user-assistance-mcp
spec:
  type: ClusterIP
  ports:
    - port: 8080
      targetPort: 8080
      name: mcp
  selector:
    app: user-assistance-mcp

---
apiVersion: traefik.io/v1alpha1
kind: Middleware
metadata:
  name: user-assistance-mcp-gateway
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: user-assistance-mcp
spec:
  plugin:
    mcp:
      policies:
        - match: (Equals(`user.groups`, `user`) || Equals(`user.groups`, `ticket-agent`) || Equals(`user.groups`, `partner`)) && Equals(`mcp.method`, `initialize`)
          action: allow
        - match: (Equals(`user.groups`, `user`) || Equals(`user.groups`, `ticket-agent`) || Equals(`user.groups`, `partner`)) && Equals(`mcp.method`, `tools/list`)
          action: allow
        - match: (Equals(`user.groups`, `user`) || Equals(`user.groups`, `ticket-agent`) || Equals(`user.groups`, `partner`)) && Equals(`mcp.method`, `ping`)
          action: allow
        - match: (Equals(`user.groups`, `user`) || Equals(`user.groups`, `ticket-agent`) || Equals(`user.groups`, `partner`)) && Equals(`mcp.method`, `tools/call`)
          action: allow
      defaultAction: allow

---
apiVersion: hub.traefik.io/v1alpha1
kind: API
metadata:
  name: user-assistance-api
  namespace: airlines
spec:
  title: "User Assistance MCP"
  description: "MCP Server for Customer Support & Issues"
  cors:
    allowHeadersList: ["Authorization", "Content-Type"]
    allowOriginsList: ["*"]
    allowMethodsList: ["GET", "POST"]
    allowCredentials: true

---
apiVersion: traefik.io/v1alpha1
kind: IngressRoute
metadata:
  name: user-assistance-mcp-route
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: user-assistance-mcp
  annotations:
    hub.traefik.io/api: user-assistance-api
spec:
  entryPoints:
    {{- range .Values.entryPoints }}
    - {{ . }}
    {{- end }}
  routes:
    - kind: Rule
      match: Host(`user-assistance.{{ .Values.domain }}`)
      middlewares:
        - name: user-assistance-mcp-gateway
      services:
        - name: user-assistance-mcp
          port: 8080
