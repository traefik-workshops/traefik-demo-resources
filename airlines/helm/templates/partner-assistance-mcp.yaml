---
# Partner Assistance MCP Server - B2B & Alliance Operations
apiVersion: v1
kind: ConfigMap
metadata:
  name: partner-assistance-mcp-server
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: partner-assistance-mcp
data:
  main.py: |
    #!/usr/bin/env python3
    """
    Partner Assistance MCP Server - B2B & Alliance Operations
    
    Orchestrates B2B workflows for airline partners, including codeshare management,
    alliance bookings, and revenue reconciliation.
    """

    from typing import Any, Dict, List, Optional
    import logging, aiohttp, anyio, json, random
    from datetime import datetime, timedelta
    from mcp.server import Server
    from mcp.server.stdio import stdio_server
    from mcp.types import Tool

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger("partner-assistance-mcp")

    server = Server("partner-assistance-mcp")

    API_BASE_URLS = {
        'flights': '{{ include "airlines.flights.apiUrl" . }}',
        'bookings': '{{ include "airlines.bookings.apiUrl" . }}',
        'pricing': '{{ include "airlines.pricing.apiUrl" . }}',
        'notifications': '{{ include "airlines.notifications.apiUrl" . }}',
    }
    
    # Static JWT Token passed from Helm/Terraform
    jwt_token: str = "{{ required "tools-access.partner_assistance.token is required" (index .Values "tools-access" "partner_assistance" "token") }}"

    @server.list_tools()
    async def list_tools():
        """List available partner assistance tools"""
        return [
            Tool(
                name="ping",
                description="Health check tool that returns a simple 'pong' response. Use this to verify that the MCP server is running and responsive. It requires no arguments.",
                inputSchema={"type": "object", "properties": {}}
            ),
            Tool(
                name="enroll_partner_flight",
                description="Registers a partner airline flight for codeshare agreements. This tool allows partners to add their flights to the network, making them available for booking. Use this when a partner wants to expand their reach. Requires partner_code, flight_number, origin, destination, and departure_time.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "partner_code": {"type": "string", "description": "Partner airline code (e.g., BA, AF)"},
                        "flight_number": {"type": "string", "description": "Partner flight number"},
                        "origin": {"type": "string", "description": "Origin airport code"},
                        "destination": {"type": "string", "description": "Destination airport code"},
                        "departure_time": {"type": "string", "description": "ISO 8601 departure time"},
                        "seats_allocated": {"type": "integer", "description": "Number of seats allocated to us"}
                    },
                    "required": ["partner_code", "flight_number", "origin", "destination", "departure_time"]
                }
            ),
            Tool(
                name="update_partner_schedule",
                description="Intelligently updates the schedule for a partner flight. First retrieves current schedule to show before/after comparison, then updates and notifies affected systems and passengers. Use this tool when a partner airline reports a schedule change or delay. Requires partner_code, flight_number, and new_departure_time.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "partner_code": {"type": "string", "description": "Partner airline code"},
                        "flight_number": {"type": "string", "description": "Partner flight number"},
                        "new_departure_time": {"type": "string", "description": "New ISO 8601 departure time"},
                        "reason": {"type": "string", "description": "Reason for change"}
                    },
                    "required": ["partner_code", "flight_number", "new_departure_time"]
                }
            ),
            Tool(
                name="create_alliance_booking",
                description="Creates a multi-airline alliance booking involving segments from different carriers. This tool handles interline pricing and PNR creation across systems. Use this for complex itineraries involving partners. Requires passenger_id and segments.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "passenger_id": {"type": "string", "description": "Passenger ID"},
                        "segments": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "airline": {"type": "string", "description": "Airline code"},
                                    "flight_number": {"type": "string", "description": "Flight number"},
                                    "date": {"type": "string", "description": "Flight date"}
                                }
                            }
                        }
                    },
                    "required": ["passenger_id", "segments"]
                }
            ),
            Tool(
                name="reconcile_partner_revenue",
                description="Calculates revenue sharing for a specific flight or period based on prorate factors. This tool generates settlement reports for clearing houses. Use this for financial reconciliation with partners. Requires partner_code and period.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "partner_code": {"type": "string", "description": "Partner airline code"},
                        "period": {"type": "string", "description": "Period (e.g., 2024-03)"},
                        "flight_id": {"type": "string", "description": "Specific flight ID (optional)"}
                    },
                    "required": ["partner_code", "period"]
                }
            )
        ]

    async def get_jwt_token() -> str:
        """Get JWT token (static)"""
        return jwt_token

    async def api_request(service: str, endpoint: str, method: str = "GET", data: Dict | None = None) -> Dict:
        """Make authenticated API request"""
        token = await get_jwt_token()
        url = f"{API_BASE_URLS[service]}{endpoint}"
        headers = {"Authorization": f"Bearer {token}"}
        if method in ["POST", "PUT", "PATCH"]:
            headers["Content-Type"] = "application/json"
        
        async with aiohttp.ClientSession() as session:
            async with session.request(method, url, headers=headers, json=data) as r:
                response_text = await r.text()
                if r.status == 200:
                    try:
                        return await r.json() if not response_text else json.loads(response_text)
                    except:
                        return {"data": response_text, "status": 200}
                elif r.status == 201:
                    try:
                        return {"status": "created", "data": await r.json() if response_text else {}}
                    except:
                        return {"status": "created"}
                elif r.status == 404:
                    return {"error": "Not found", "status": 404}
                else:
                    return {"error": f"API error {r.status}: {response_text}", "status": r.status}

    @server.call_tool()
    async def call_tool(name: str, arguments: dict):
        """Handle tool calls with detailed execution tracing"""
        logger.info(f"Tool called: {name} with args: {arguments}")
        
        if name == "ping":
            return [{"type": "text", "text": "pong - Partner Assistance MCP Server is operational"}]
        
        elif name == "enroll_partner_flight":
            partner = arguments.get("partner_code")
            flight_num = arguments.get("flight_number")
            origin = arguments.get("origin")
            dest = arguments.get("destination")
            dept = arguments.get("departure_time")
            seats = arguments.get("seats_allocated", 20)
            
            try:
                steps = []
                steps.append("ü§ù **PARTNER FLIGHT ENROLLMENT**")
                steps.append(f"‚úàÔ∏è  Partner: {partner} | Flight: {flight_num}")
                steps.append(f"üìç Route: {origin} ‚Üí {dest}")
                steps.append("")
                
                # Step 1: Validate partner agreement
                steps.append("1Ô∏è‚É£ Validating partner agreement...")
                # Mock validation
                valid_partners = ["BA", "AF", "LH", "JL", "QF"]
                if partner not in valid_partners:
                    steps.append(f"   ‚ùå Partner {partner} not found in alliance database")
                    return [{"type": "text", "text": "\n".join(steps)}]
                steps.append(f"   ‚úÖ Partner {partner} is active in SkyAlliance")
                
                # Step 2: Check route compatibility
                steps.append("\n2Ô∏è‚É£ Checking route compatibility...")
                steps.append(f"   ‚úÖ Route {origin}-{dest} approved for codeshare")
                
                # Step 3: Create virtual flight record via API
                steps.append("\n3Ô∏è‚É£ Creating virtual flight record...")
                virtual_flight_num = f"CS{flight_num}"

                # POST to flights API to create the flight
                flight_create = await api_request(
                    "flights",
                    "/flights",
                    "POST",
                    {
                        "flight_id": virtual_flight_num,
                        "partner_code": partner,
                        "physical_flight": f"{partner}{flight_num}",
                        "origin": origin,
                        "destination": dest,
                        "departure_time": dept,
                        "flight_type": "codeshare",
                        "operating_carrier": partner,
                        "marketing_carrier": "US"
                    }
                )

                if "error" not in flight_create:
                    steps.append(f"   ‚úÖ Virtual flight created: {virtual_flight_num}")
                    steps.append(f"   ‚úÖ Registered in system")
                else:
                    steps.append(f"   ‚ö†Ô∏è  Flight record pending (may already exist)")
                    steps.append(f"   ‚úÖ Virtual flight: {virtual_flight_num}")

                steps.append(f"   ‚ÑπÔ∏è  Mapped to physical flight {partner}{flight_num}")
                
                # Step 4: Allocate inventory
                steps.append("\n4Ô∏è‚É£ Allocating inventory...")
                steps.append(f"   ‚úÖ {seats} seats allocated to inventory pool")
                steps.append(f"   ‚úÖ Booking classes: Y, J, F mapped")
                
                # Step 5: Publish to GDS/Distribution
                steps.append("\n5Ô∏è‚É£ Publishing to distribution channels...")
                steps.append(f"   ‚úÖ Flight {virtual_flight_num} now visible in search")
                
                # Build response
                response = "\n".join(steps)
                response += "\n\n" + "="*60
                response += "\n**ENROLLMENT COMPLETE** ‚úÖ\n"
                response += "="*60
                response += f"\n\n**Virtual Flight**: {virtual_flight_num}"
                response += f"\n**Operator**: {partner}"
                response += f"\n**Inventory**: {seats} seats"
                response += f"\n**Status**: Active / Sellable"
                
                return [{"type": "text", "text": response}]
                
            except Exception as e:
                logger.error(f"Error in enroll_partner_flight: {e}")
                return [{"type": "text", "text": f"‚ùå Error: {str(e)}"}]
        
        elif name == "update_partner_schedule":
            partner = arguments.get("partner_code")
            flight_num = arguments.get("flight_number")
            new_time = arguments.get("new_departure_time")
            reason = arguments.get("reason", "Operational adjustment")

            try:
                steps = []
                steps.append("üìÖ **PARTNER SCHEDULE UPDATE**")
                steps.append(f"‚úàÔ∏è  Flight: {partner}{flight_num}")
                steps.append(f"üìù Reason: {reason}")
                steps.append("")

                # Step 1: GET current flight schedule (NEW - show before state)
                steps.append("1Ô∏è‚É£ Retrieving current flight schedule...")
                virtual_flight_num = f"CS{flight_num}"

                # Try to get the actual flight from API
                flight_response = await api_request("flights", f"/flights/{virtual_flight_num}")

                old_departure = "Unknown"
                old_arrival = "Unknown"
                origin = "???"
                destination = "???"

                if "error" not in flight_response:
                    # Successfully retrieved flight
                    flight = flight_response
                    if "flights" in flight_response:
                        flights_data = flight_response["flights"]
                        if isinstance(flights_data, dict) and virtual_flight_num in flights_data:
                            flight = flights_data[virtual_flight_num]
                        elif isinstance(flights_data, list) and len(flights_data) > 0:
                            flight = flights_data[0]

                    old_departure = flight.get("departure_time", "Unknown")
                    old_arrival = flight.get("arrival_time", "Unknown")
                    origin = flight.get("origin", "???")
                    destination = flight.get("destination", "???")

                    steps.append(f"   ‚úÖ Found: {virtual_flight_num}")
                    steps.append(f"   üìç Route: {origin} ‚Üí {destination}")
                    steps.append(f"   üïê Current Departure: {old_departure}")
                    steps.append(f"   üïë Current Arrival: {old_arrival}")
                else:
                    # Flight not found via API, use mock data
                    steps.append(f"   ‚úÖ Found mapped virtual flight: {virtual_flight_num}")
                    old_departure = "2024-12-15T14:30:00Z"

                # Step 2: Show before/after comparison
                steps.append("\n2Ô∏è‚É£ Comparing schedules...")
                steps.append(f"   üìä **BEFORE**: {old_departure}")
                steps.append(f"   üìä **AFTER**: {new_time}")

                # Calculate time difference if possible
                try:
                    from datetime import datetime
                    old_dt = datetime.fromisoformat(old_departure.replace('Z', '+00:00'))
                    new_dt = datetime.fromisoformat(new_time.replace('Z', '+00:00'))
                    diff = new_dt - old_dt
                    diff_hours = diff.total_seconds() / 3600

                    if diff_hours > 0:
                        steps.append(f"   ‚è±Ô∏è  Delay: +{abs(diff_hours):.1f} hours")
                    elif diff_hours < 0:
                        steps.append(f"   ‚è±Ô∏è  Earlier by: {abs(diff_hours):.1f} hours")
                    else:
                        steps.append(f"   ‚è±Ô∏è  No time change")
                except:
                    pass

                # Step 3: Update schedule (POST/PUT to API)
                steps.append("\n3Ô∏è‚É£ Updating schedule in system...")

                update_result = await api_request(
                    "flights",
                    f"/flights/{virtual_flight_num}",
                    "PUT",
                    {
                        "departure_time": new_time,
                        "reason": reason,
                        "updated_by": f"Partner {partner}"
                    }
                )

                if "error" not in update_result:
                    steps.append(f"   ‚úÖ Departure time updated to {new_time}")
                else:
                    steps.append(f"   ‚ö†Ô∏è  Update pending confirmation")

                # Step 4: Identify affected bookings
                steps.append("\n4Ô∏è‚É£ Identifying affected bookings...")
                affected_count = 42  # Mock
                steps.append(f"   ‚ö†Ô∏è  Found {affected_count} active bookings")

                # Step 5: Check connection validity
                steps.append("\n5Ô∏è‚É£ Validating connections...")
                broken_connections = 3
                steps.append(f"   ‚ö†Ô∏è  {broken_connections} connections broken by schedule change")

                # Step 6: Notify passengers
                steps.append("\n6Ô∏è‚É£ Triggering notifications...")
                notification = await api_request(
                    "notifications",
                    "/notifications/send",
                    "POST",
                    {
                        "type": "flight_reminder",  # Using existing type for demo
                        "recipient": "affected_passengers",
                        "booking_id": "BATCH"
                    }
                )
                steps.append(f"   ‚úÖ Notifications queued for {affected_count} passengers")
                
                # Build response
                response = "\n".join(steps)
                response += "\n\n" + "="*60
                response += "\n**SCHEDULE UPDATED** ‚úÖ\n"
                response += "="*60
                response += f"\n\n**Flight**: {partner}{flight_num} ({virtual_flight_num})"
                response += f"\n**Route**: {origin} ‚Üí {destination}"
                response += f"\n\n**BEFORE**: {old_departure}"
                response += f"\n**AFTER**: {new_time}"
                response += f"\n\n**Affected Passengers**: {affected_count}"
                response += f"\n**Broken Connections**: {broken_connections}"
                response += f"\n**Action Required**: Manual review needed for {broken_connections} bookings"
                
                return [{"type": "text", "text": response}]
                
            except Exception as e:
                logger.error(f"Error in update_partner_schedule: {e}")
                return [{"type": "text", "text": f"‚ùå Error: {str(e)}"}]
        
        elif name == "create_alliance_booking":
            passenger_id = arguments.get("passenger_id")
            segments = arguments.get("segments", [])
            
            try:
                steps = []
                steps.append("üåê **ALLIANCE BOOKING CREATION**")
                steps.append(f"üë§ Passenger: {passenger_id}")
                steps.append(f"‚úàÔ∏è  Segments: {len(segments)}")
                steps.append("")
                
                # Step 1: Validate segments
                steps.append("1Ô∏è‚É£ Validating flight segments...")
                total_price = 0
                valid_segments = []
                
                for i, seg in enumerate(segments):
                    airline = seg.get("airline")
                    flight = seg.get("flight_number")
                    steps.append(f"   Checking Segment {i+1}: {airline}{flight}...")
                    
                    if airline == "US": # Our airline
                        # Check our inventory
                        steps.append(f"   ‚úÖ {airline}{flight}: Confirmed (Native)")
                        total_price += 450.00
                    else:
                        # Check partner inventory
                        steps.append(f"   ‚úÖ {airline}{flight}: Confirmed (Partner {airline})")
                        total_price += 520.00
                    
                    valid_segments.append(f"{airline}{flight}")
                
                # Step 2: Calculate interline pricing
                steps.append("\n2Ô∏è‚É£ Calculating interline pricing...")
                steps.append(f"   ‚úÖ Base Fare: ${total_price:.2f}")
                taxes = 150.00
                total = total_price + taxes
                steps.append(f"   ‚úÖ Taxes & Fees: ${taxes:.2f}")
                steps.append(f"   üí∞ Total: ${total:.2f}")
                
                # Step 3: Create PNR
                steps.append("\n3Ô∏è‚É£ Creating Passenger Name Record (PNR)...")
                booking_id = f"AL{random.randint(10000, 99999)}"
                steps.append(f"   ‚úÖ PNR Created: {booking_id}")
                
                # Step 4: Issue tickets
                steps.append("\n4Ô∏è‚É£ Issuing e-tickets...")
                ticket_num = f"016{random.randint(1000000000, 9999999999)}"
                steps.append(f"   ‚úÖ Ticket issued: {ticket_num}")
                steps.append(f"   ‚ÑπÔ∏è  Valid on: {', '.join(valid_segments)}")
                
                # Step 5: Sync with partners
                steps.append("\n5Ô∏è‚É£ Syncing with partner systems...")
                for seg in segments:
                    if seg.get("airline") != "US":
                        steps.append(f"   ‚úÖ Synced with {seg.get('airline')} reservation system")
                
                # Build response
                response = "\n".join(steps)
                response += "\n\n" + "="*60
                response += "\n**BOOKING CONFIRMED** ‚úÖ\n"
                response += "="*60
                response += f"\n\n**Booking Ref**: {booking_id}"
                response += f"\n**Ticket**: {ticket_num}"
                response += f"\n**Itinerary**: {' -> '.join(valid_segments)}"
                response += f"\n**Total Price**: ${total:.2f}"
                
                return [{"type": "text", "text": response}]
                
            except Exception as e:
                logger.error(f"Error in create_alliance_booking: {e}")
                return [{"type": "text", "text": f"‚ùå Error: {str(e)}"}]
        
        elif name == "reconcile_partner_revenue":
            partner = arguments.get("partner_code")
            period = arguments.get("period")
            
            try:
                steps = []
                steps.append("üí∞ **REVENUE RECONCILIATION**")
                steps.append(f"üè¢ Partner: {partner}")
                steps.append(f"üìÖ Period: {period}")
                steps.append("")
                
                # Step 1: Aggregate flight data
                steps.append("1Ô∏è‚É£ Aggregating flight data...")
                flights_count = 45
                passengers_count = 6200
                steps.append(f"   ‚úÖ Processed {flights_count} flights")
                steps.append(f"   ‚úÖ Processed {passengers_count} passengers")
                
                # Step 2: Calculate gross revenue
                steps.append("\n2Ô∏è‚É£ Calculating gross revenue...")
                gross_revenue = 1250000.00
                steps.append(f"   üíµ Gross Revenue: ${gross_revenue:,.2f}")
                
                # Step 3: Apply prorate factors
                steps.append("\n3Ô∏è‚É£ Applying prorate factors...")
                # Mock prorate calculation based on mileage
                our_share_pct = 0.45
                partner_share_pct = 0.55
                steps.append(f"   üìä Mileage split: Us {our_share_pct*100}% / {partner} {partner_share_pct*100}%")
                
                partner_share = gross_revenue * partner_share_pct
                steps.append(f"   üí∞ Partner Share: ${partner_share:,.2f}")
                
                # Step 4: Deduct fees and commissions
                steps.append("\n4Ô∏è‚É£ Deducting fees and commissions...")
                handling_fees = 15000.00
                booking_fees = 5000.00
                steps.append(f"   üìâ Handling Fees: -${handling_fees:,.2f}")
                steps.append(f"   üìâ Booking Fees: -${booking_fees:,.2f}")
                
                net_settlement = partner_share - handling_fees - booking_fees
                
                # Step 5: Generate settlement report
                steps.append("\n5Ô∏è‚É£ Generating settlement report...")
                report_id = f"SET-{partner}-{period}"
                steps.append(f"   ‚úÖ Report generated: {report_id}")
                steps.append(f"   ‚úÖ Sent to clearing house (IATA ICH)")
                
                # Build response
                response = "\n".join(steps)
                response += "\n\n" + "="*60
                response += "\n**RECONCILIATION COMPLETE** ‚úÖ\n"
                response += "="*60
                response += f"\n\n**Settlement ID**: {report_id}"
                response += f"\n**Net Settlement**: ${net_settlement:,.2f}"
                response += f"\n**Direction**: PAY TO {partner}"
                response += f"\n**Status**: PENDING CLEARING"
                
                return [{"type": "text", "text": response}]
                
            except Exception as e:
                logger.error(f"Error in reconcile_partner_revenue: {e}")
                return [{"type": "text", "text": f"‚ùå Error: {str(e)}"}]
        
        else:
            return [{"type": "text", "text": f"‚ùå Unknown tool: {name}"}]

    if __name__ == "__main__":
        import asyncio
        from mcp.server.fastmcp import FastMCP
        import uvicorn
        
        mcp_app = FastMCP("partner-assistance-mcp", stateless_http=True, json_response=True)
        
        @mcp_app.tool()
        async def ping() -> str:
            """Health check tool"""
            result = await call_tool("ping", {})
            return result[0]["text"] if result and len(result) > 0 else "pong"
        
        @mcp_app.tool()
        async def enroll_partner_flight(
            partner_code: str,
            flight_number: str,
            origin: str,
            destination: str,
            departure_time: str,
            seats_allocated: int = 20
        ) -> str:
            """Registers a partner airline flight for codeshare agreements"""
            result = await call_tool("enroll_partner_flight", {
                "partner_code": partner_code,
                "flight_number": flight_number,
                "origin": origin,
                "destination": destination,
                "departure_time": departure_time,
                "seats_allocated": seats_allocated
            })
            return result[0]["text"] if result and len(result) > 0 else str(result)
        
        @mcp_app.tool()
        async def update_partner_schedule(
            partner_code: str,
            flight_number: str,
            new_departure_time: str,
            reason: str = "Operational adjustment"
        ) -> str:
            """Updates schedule for a partner flight and notifies affected systems"""
            result = await call_tool("update_partner_schedule", {
                "partner_code": partner_code,
                "flight_number": flight_number,
                "new_departure_time": new_departure_time,
                "reason": reason
            })
            return result[0]["text"] if result and len(result) > 0 else str(result)
        
        @mcp_app.tool()
        async def create_alliance_booking(passenger_id: str, segments: list) -> str:
            """Creates a multi-airline alliance booking"""
            result = await call_tool("create_alliance_booking", {
                "passenger_id": passenger_id,
                "segments": segments
            })
            return result[0]["text"] if result and len(result) > 0 else str(result)
        
        @mcp_app.tool()
        async def reconcile_partner_revenue(partner_code: str, period: str, flight_id: str = None) -> str:
            """Calculates revenue sharing based on prorate factors"""
            result = await call_tool("reconcile_partner_revenue", {
                "partner_code": partner_code,
                "period": period,
                "flight_id": flight_id
            })
            return result[0]["text"] if result and len(result) > 0 else str(result)
        
        logger.info("Starting Partner Assistance MCP Server with streamable-http...")
        app = mcp_app.streamable_http_app()
        uvicorn.run(app, host="0.0.0.0", port=8080)

  requirements.txt: |
    mcp>=1.3.0
    uvicorn>=0.32.1
    aiohttp==3.9.1
    anyio==4.11.0
    httpx>=0.27.0

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: partner-assistance-mcp
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: partner-assistance-mcp
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      app: partner-assistance-mcp
  template:
    metadata:
      labels:
        app: partner-assistance-mcp
        component: mcp
    spec:
      containers:
        - name: mcp-server
          image: "{{ .Values.mcpImage.repository }}:{{ .Values.mcpImage.tag }}"
          imagePullPolicy: {{ .Values.mcpImage.pullPolicy }}
          ports:
            - containerPort: 8080
          command: ["/bin/sh", "-c"]
          args:
            - |
              pip install --no-cache-dir -r /app/requirements.txt && \
              python /app/main.py
          volumeMounts:
            - name: mcp-code
              mountPath: /app
          resources:
            {{- toYaml .Values.resources | nindent 12 }}
      volumes:
        - name: mcp-code
          configMap:
            name: partner-assistance-mcp-server

---
apiVersion: v1
kind: Service
metadata:
  name: partner-assistance-mcp
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: partner-assistance-mcp
spec:
  type: ClusterIP
  ports:
    - port: 8080
      targetPort: 8080
      name: mcp
  selector:
    app: partner-assistance-mcp

---
apiVersion: traefik.io/v1alpha1
kind: Middleware
metadata:
  name: partner-assistance-mcp-gateway
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: partner-assistance-mcp
spec:
  plugin:
    mcp:
      policies:
        - match: (Equals(`user.groups`, `user`) || Equals(`user.groups`, `ticket-agent`) || Equals(`user.groups`, `partner`)) && Equals(`mcp.method`, `initialize`)
          action: allow
        - match: (Equals(`user.groups`, `user`) || Equals(`user.groups`, `ticket-agent`) || Equals(`user.groups`, `partner`)) && Equals(`mcp.method`, `tools/list`)
          action: allow
        - match: (Equals(`user.groups`, `user`) || Equals(`user.groups`, `ticket-agent`) || Equals(`user.groups`, `partner`)) && Equals(`mcp.method`, `ping`)
          action: allow
        - match: (Equals(`user.groups`, `user`) || Equals(`user.groups`, `ticket-agent`) || Equals(`user.groups`, `partner`)) && Equals(`mcp.method`, `tools/call`)
          action: allow
      defaultAction: allow

---
apiVersion: hub.traefik.io/v1alpha1
kind: API
metadata:
  name: partner-assistance-api
  namespace: airlines
spec:
  title: "Partner Assistance MCP"
  description: "MCP Server for B2B & Alliance Operations"
  cors:
    allowHeadersList: ["Authorization", "Content-Type"]
    allowOriginsList: ["*"]
    allowMethodsList: ["GET", "POST"]
    allowCredentials: true

---
apiVersion: traefik.io/v1alpha1
kind: IngressRoute
metadata:
  name: partner-assistance-mcp-route
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: partner-assistance-mcp
  annotations:
    hub.traefik.io/api: partner-assistance-api
spec:
  entryPoints:
    {{- range .Values.entryPoints }}
    - {{ . }}
    {{- end }}
  routes:
    - kind: Rule
      match: Host(`partner-assistance.{{ .Values.domain }}`)
      middlewares:
        - name: partner-assistance-mcp-gateway
      services:
        - name: partner-assistance-mcp
          port: 8080
