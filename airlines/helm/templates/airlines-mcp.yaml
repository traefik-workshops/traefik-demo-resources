---
# Airlines MCP Server
# Covers ALL airline operations: Customer Support, Ticketing, and Partner Management
apiVersion: v1
kind: ConfigMap
metadata:
  name: airlines-mcp-server
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: airlines-mcp
data:
  main.py: |
    #!/usr/bin/env python3
    """
    Airlines MCP Server

    Provides complete coverage for:
    - User Assistance (Customer Support & Disruption Management)
    - Ticketing Agent (Booking, Modifications, Ancillaries)
    - Partner Assistance (B2B & Alliance Operations)

    Supports all real-world airline scenarios including:
    - Complete booking workflows (search ‚Üí price ‚Üí book ‚Üí ticket ‚Üí check-in)
    - Disruption management (delays, cancellations, rebooking)
    - Baggage handling (tracking, claims, lost baggage)
    - Loyalty program operations (status, redemptions, benefits)
    - Ancillary services (seats, meals, upgrades, special requests)
    - Partner operations (codeshares, alliances, revenue reconciliation)
    - Group bookings and multi-city itineraries
    """

    from typing import Any, Dict, List, Optional
    import logging, aiohttp, anyio, json, random
    from datetime import datetime, timedelta
    from contextvars import ContextVar
    from mcp.server.fastmcp import FastMCP
    import uvicorn
    from starlette.middleware.base import BaseHTTPMiddleware
    from starlette.requests import Request

    # Configure logging
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger("airlines-mcp")

    # API Configuration
    API_BASE_URLS = {
        'flights': '{{ include "airlines.flights.apiUrl" . }}',
        'bookings': '{{ include "airlines.bookings.apiUrl" . }}',
        'tickets': '{{ include "airlines.tickets.apiUrl" . }}',
        'passengers': '{{ include "airlines.passengers.apiUrl" . }}',
        'loyalty': '{{ include "airlines.loyalty.apiUrl" . }}',
        'checkin': '{{ include "airlines.checkin.apiUrl" . }}',
        'pricing': '{{ include "airlines.pricing.apiUrl" . }}',
        'baggage': '{{ include "airlines.baggage.apiUrl" . }}',
        'notifications': '{{ include "airlines.notifications.apiUrl" . }}',
        'ancillaries': '{{ include "airlines.ancillaries.apiUrl" . }}',
    }

    # Context variable to store JWT token from request Authorization header
    jwt_token_context: ContextVar[Optional[str]] = ContextVar('jwt_token', default=None)

    async def get_jwt_token() -> str:
        """Get JWT token from context"""
        token = jwt_token_context.get()
        if not token:
            raise ValueError("No authorization token provided in request")
        return token

    async def api_request(service: str, endpoint: str, method: str = "GET", data: Dict | None = None) -> Dict:
        """Make authenticated API request and return response"""
        token = await get_jwt_token()
        url = f"{API_BASE_URLS[service]}{endpoint}"
        headers = {"Authorization": f"Bearer {token}"}
        if method in ["POST", "PUT", "PATCH"]:
            headers["Content-Type"] = "application/json"

        async with aiohttp.ClientSession() as session:
            async with session.request(method, url, headers=headers, json=data) as r:
                response_text = await r.text()
                if r.status == 200:
                    try:
                        return await r.json() if not response_text else json.loads(response_text)
                    except Exception as e:
                        logger.warning(f"JSON parse error for {url}: {e}")
                        return {"data": response_text, "status": 200}
                elif r.status == 201:
                    try:
                        return {"status": "created", "data": await r.json() if response_text else {}}
                    except:
                        return {"status": "created"}
                elif r.status == 404:
                    return {"error": "Not found", "status": 404}
                else:
                    return {"error": f"API error {r.status}: {response_text}", "status": r.status}

    # Initialize FastMCP
    mcp_app = FastMCP("airlines-mcp", stateless_http=True, json_response=True)

    # Middleware to extract and store Authorization token in context
    class AuthTokenMiddleware(BaseHTTPMiddleware):
        async def dispatch(self, request: Request, call_next):
            # Extract token from Authorization header
            auth_header = request.headers.get("authorization", "")
            token = None
            if auth_header.startswith("Bearer "):
                token = auth_header[7:]  # Remove "Bearer " prefix
            elif auth_header:
                token = auth_header  # Use as-is if no Bearer prefix

            # Store token in context variable for this request
            jwt_token_context.set(token)
            logger.info(f"Token extracted from Authorization header: {'present' if token else 'missing'}")

            # Process the request
            response = await call_next(request)
            return response

    # ===== TOOL IMPLEMENTATIONS =====

    @mcp_app.tool()
    async def ping() -> str:
        """Health check tool that returns a simple 'pong' response. Use this to verify that the MCP server is running and responsive."""
        return "pong - Airlines MCP Server is operational"

    # ===== USER ASSISTANCE TOOLS (Customer Support) =====

    @mcp_app.tool()
    async def get_flight_status(flight_number: str, date: str = None) -> str:
        """Retrieves real-time operational status and details for a specific flight including delays, gate info, and aircraft. Use when customer asks about flight times, delays, or gate changes."""
        try:
            steps = []
            steps.append("FLIGHT STATUS CHECK")
            steps.append(f"Flight: {flight_number} | Date: {date}")
            steps.append("")

            steps.append("1. Locating flight...")
            flight = await api_request("flights", f"/flights/{flight_number}")

            if "error" in flight:
                steps.append(f"   ERROR: Flight not found")
                return "\n".join(steps)

            steps.append(f"   Found: {flight.get('flight_id', flight_number)}")
            steps.append(f"   Route: {flight.get('origin', 'N/A')} -> {flight.get('destination', 'N/A')}")

            steps.append("\n2. Retrieving real-time status...")
            status = flight.get("status", "Unknown")
            departure = flight.get("departure_time", "N/A")
            arrival = flight.get("arrival_time", "N/A")
            gate = flight.get("gate", "TBA")
            terminal = flight.get("terminal", "TBA")
            aircraft = flight.get("aircraft_type", "N/A")

            steps.append(f"   Status: {status}")
            steps.append(f"   Departure: {departure}")
            steps.append(f"   Arrival: {arrival}")
            steps.append(f"   Gate: {gate} | Terminal: {terminal}")
            steps.append(f"   Aircraft: {aircraft}")

            if "delayed" in status.lower():
                delay_mins = flight.get("delay_minutes", "Unknown")
                steps.append(f"\n   DELAY: {delay_mins} minutes")
                steps.append(f"   Estimated departure: {flight.get('estimated_departure', 'Calculating...')}")

            return "\n".join(steps)

        except Exception as e:
            logger.error(f"Error in get_flight_status: {e}")
            return f"ERROR: {str(e)}"

    @mcp_app.tool()
    async def find_delayed_flights() -> str:
        """Finds all currently delayed or cancelled flights. Use when customer asks about general delays, 'which flights are delayed', or wants to check delay status."""
        try:
            steps = []
            steps.append("FINDING DELAYED/CANCELLED FLIGHTS")
            steps.append("")

            steps.append("1. Querying all flights...")
            flights = await api_request("flights", "/flights")

            if "error" in flights:
                steps.append(f"   ERROR: {flights.get('error')}")
                return "\n".join(steps)

            if not isinstance(flights, list):
                flights = []

            steps.append(f"   Retrieved {len(flights)} flights")

            steps.append("\n2. Filtering for delays/cancellations...")
            delayed = [f for f in flights if "delay" in f.get("status", "").lower()]
            cancelled = [f for f in flights if "cancel" in f.get("status", "").lower()]

            steps.append(f"   Found {len(delayed)} delayed")
            steps.append(f"   Found {len(cancelled)} cancelled")

            response = "\n".join(steps)
            response += "\n\n" + "="*60

            if delayed:
                response += "\nDELAYED FLIGHTS:\n" + "="*60
                for f in delayed:
                    response += f"\n\n{f.get('flight_id')}: {f.get('origin')} -> {f.get('destination')}"
                    response += f"\n   Status: {f.get('status')}"
                    response += f"\n   Scheduled: {f.get('departure_time')}"
                    response += f"\n   Delay: {f.get('delay_minutes', 'Unknown')} minutes"

            if cancelled:
                response += "\n\n" + "="*60
                response += "\nCANCELLED FLIGHTS:\n" + "="*60
                for f in cancelled:
                    response += f"\n\n{f.get('flight_id')}: {f.get('origin')} -> {f.get('destination')}"

            if not delayed and not cancelled:
                response += "\n\nNo delayed or cancelled flights at this time"

            return response

        except Exception as e:
            return f"ERROR: {str(e)}"

    @mcp_app.tool()
    async def find_alternative_flights(original_flight_id: str, date_range_hours: int = 24) -> str:
        """Finds alternative flight options when original flight is delayed/cancelled. Searches for flights on same route within 24 hours."""
        try:
            steps = []
            steps.append("FINDING ALTERNATIVE FLIGHTS")
            steps.append(f"Original flight: {original_flight_id}")
            steps.append(f"Search window: +/- {date_range_hours} hours")
            steps.append("")

            steps.append("1. Retrieving original flight details...")
            original = await api_request("flights", f"/flights/{original_flight_id}")

            if "error" in original:
                steps.append("   ERROR: Original flight not found")
                return "\n".join(steps)

            origin = original.get("origin")
            destination = original.get("destination")
            steps.append(f"   Route: {origin} -> {destination}")

            steps.append("\n2. Searching for alternative flights on same route...")
            all_flights = await api_request("flights", "/flights")

            if isinstance(all_flights, list):
                alternatives = [
                    f for f in all_flights
                    if f.get("origin") == origin
                    and f.get("destination") == destination
                    and f.get("flight_id") != original_flight_id
                    and "cancel" not in f.get("status", "").lower()
                ]
            else:
                alternatives = []

            steps.append(f"   Found {len(alternatives)} alternative flights")

            response = "\n".join(steps)

            if alternatives:
                response += "\n\n" + "="*60
                response += "\nAVAILABLE ALTERNATIVES:\n" + "="*60

                for alt in alternatives[:5]:  # Show top 5
                    response += f"\n\n{alt.get('flight_id')}: {origin} -> {destination}"
                    response += f"\n   Departure: {alt.get('departure_time')}"
                    response += f"\n   Status: {alt.get('status')}"
                    response += f"\n   Available seats: {alt.get('available_seats', 'Check availability')}"
            else:
                response += "\n\nNo alternative flights found on this route"

            return response

        except Exception as e:
            return f"ERROR: {str(e)}"

    @mcp_app.tool()
    async def track_flight_realtime(flight_id: str, include_map: bool = True) -> str:
        """Tracks flight with live updates including current position, altitude, speed, and ETA. Use when customer wants real-time flight tracking."""
        try:
            steps = []
            steps.append("üì° **REAL-TIME FLIGHT TRACKING**")
            steps.append(f"‚úàÔ∏è  Flight: {flight_id}")
            steps.append("")

            steps.append("1Ô∏è‚É£ Retrieving flight data...")
            flight = await api_request("flights", f"/flights/{flight_id}")

            if "error" in flight:
                steps.append("   ‚ùå Flight not found")
                return "\n".join(steps)

            steps.append(f"   ‚úÖ Route: {flight.get('origin')} ‚Üí {flight.get('destination')}")

            steps.append("\n2Ô∏è‚É£ Fetching real-time position...")
            # Simulated tracking data
            altitude = 37000
            speed = 485
            position = "Over Atlantic Ocean"
            eta_minutes = 145

            steps.append(f"   üåç Position: {position}")
            steps.append(f"   üìè Altitude: {altitude:,} ft")
            steps.append(f"   üöÄ Speed: {speed} knots")
            steps.append(f"   ‚è±Ô∏è  ETA: {eta_minutes} minutes")

            if include_map:
                steps.append("\n3Ô∏è‚É£ Map coordinates...")
                steps.append("   üìç Lat: 45.2341, Lon: -63.4521")

            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += "\n**LIVE TRACKING** üì°\n"
            response += "="*60
            response += f"\n\n**Flight**: {flight_id}"
            response += f"\n**Position**: {position}"
            response += f"\n**Altitude**: {altitude:,} ft"
            response += f"\n**Speed**: {speed} knots"
            response += f"\n**ETA**: {eta_minutes} min"
            response += f"\n**Status**: {flight.get('status', 'In Flight')}"

            return response

        except Exception as e:
            logger.error(f"Error in track_flight_realtime: {e}")
            return f"‚ùå Error: {str(e)}"

    @mcp_app.tool()
    async def get_gate_info(flight_id: str, date: str) -> str:
        """Retrieves gate, terminal, and boarding information for a flight. Use when customer asks about gate assignment."""
        try:
            steps = []
            steps.append("üö™ **GATE INFORMATION**")
            steps.append(f"‚úàÔ∏è  Flight: {flight_id}")
            steps.append(f"üìÖ Date: {date}")
            steps.append("")

            steps.append("1Ô∏è‚É£ Retrieving flight details...")
            flight = await api_request("flights", f"/flights/{flight_id}")

            if "error" in flight:
                steps.append("   ‚ùå Flight not found")
                return "\n".join(steps)

            gate = flight.get("gate", "TBA")
            terminal = flight.get("terminal", "TBA")
            boarding_time = flight.get("boarding_time", "TBA")
            departure_time = flight.get("departure_time", "Unknown")

            steps.append(f"   ‚úÖ Gate: {gate}")
            steps.append(f"   ‚úÖ Terminal: {terminal}")
            steps.append(f"   ‚úÖ Boarding: {boarding_time}")
            steps.append(f"   ‚úÖ Departure: {departure_time}")

            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += "\n**GATE & BOARDING INFO** üö™\n"
            response += "="*60
            response += f"\n\n**Flight**: {flight_id}"
            response += f"\n**Gate**: {gate}"
            response += f"\n**Terminal**: {terminal}"
            response += f"\n**Boarding Time**: {boarding_time}"
            response += f"\n**Departure Time**: {departure_time}"

            return response

        except Exception as e:
            logger.error(f"Error in get_gate_info: {e}")
            return f"‚ùå Error: {str(e)}"

    @mcp_app.tool()
    async def get_booking_details(booking_id: str) -> str:
        """Fetches comprehensive booking information including itinerary, passenger details, status, ancillaries."""
        try:
            steps = []
            steps.append("BOOKING RETRIEVAL")
            steps.append(f"Reference: {booking_id}")
            steps.append("")

            steps.append("1. Fetching booking record...")
            booking = await api_request("bookings", f"/bookings/{booking_id}")

            if "error" in booking:
                steps.append(f"   ERROR: Booking not found")
                return "\n".join(steps)

            steps.append(f"   Status: {booking.get('status')}")
            steps.append(f"   Flight: {booking.get('flight_id')}")
            steps.append(f"   Passenger: {booking.get('passenger_id')}")

            steps.append("\n2. Checking ticket status...")
            ticket = await api_request("tickets", f"/tickets/booking/{booking_id}")

            if "error" not in ticket:
                steps.append(f"   Ticket: {ticket.get('ticket_number', 'Pending')}")
            else:
                steps.append("   Ticket: Not issued")

            steps.append("\n3. Checking check-in status...")
            checkin = await api_request("checkin", f"/checkin/{booking_id}")

            if "error" not in checkin:
                steps.append(f"   Checked in: Yes")
                steps.append(f"   Seat: {checkin.get('seat', 'Not assigned')}")
            else:
                steps.append("   Checked in: No")

            return "\n".join(steps)

        except Exception as e:
            return f"ERROR: {str(e)}"

    @mcp_app.tool()
    async def search_bookings_by_passenger(
        passenger_id: str = None,
        email: str = None,
        phone: str = None,
        last_name: str = None
    ) -> str:
        """Finds all bookings for a passenger by passenger ID, email, or phone."""
        try:
            steps = []
            steps.append("SEARCHING BOOKINGS BY PASSENGER")

            search_criteria = []
            if passenger_id:
                search_criteria.append(f"ID: {passenger_id}")
            if email:
                search_criteria.append(f"Email: {email}")
            if phone:
                search_criteria.append(f"Phone: {phone}")
            if last_name:
                search_criteria.append(f"Last name: {last_name}")

            steps.append(f"Search criteria: {', '.join(search_criteria)}")
            steps.append("")

            steps.append("1. Querying bookings database...")

            # Build query based on available parameters
            query_params = []
            if passenger_id:
                query_params.append(f"passenger_id={passenger_id}")
            if email:
                query_params.append(f"email={email}")

            query_string = "&".join(query_params) if query_params else ""
            bookings = await api_request("bookings", f"/bookings/search?{query_string}")

            if isinstance(bookings, list):
                steps.append(f"   Found {len(bookings)} booking(s)")

                response = "\n".join(steps)
                response += "\n\n" + "="*60
                response += "\nBOOKINGS FOUND:\n" + "="*60

                for b in bookings[:10]:  # Show up to 10
                    response += f"\n\nBooking: {b.get('booking_id')}"
                    response += f"\n   Flight: {b.get('flight_id')}"
                    response += f"\n   Status: {b.get('status')}"
                    response += f"\n   Date: {b.get('booking_date', 'N/A')}"
            else:
                response = "\n".join(steps)
                response += "\n\nNo bookings found matching criteria"

            return response

        except Exception as e:
            return f"ERROR: {str(e)}"

    @mcp_app.tool()
    async def update_passenger_contact_info(
        passenger_id: str,
        email: str = None,
        phone: str = None,
        address: str = None
    ) -> str:
        """Updates passenger contact information (email, phone, address)."""
        try:
            steps = []
            steps.append("UPDATING PASSENGER CONTACT INFORMATION")
            steps.append(f"Passenger ID: {passenger_id}")
            steps.append("")

            update_data = {}
            if email:
                update_data["email"] = email
            if phone:
                update_data["phone"] = phone
            if address:
                update_data["address"] = address

            if not update_data:
                return "ERROR: No update data provided"

            steps.append("1. Updating passenger profile...")
            result = await api_request("passengers", f"/passengers/{passenger_id}", "PATCH", update_data)

            if "error" in result:
                steps.append(f"   ERROR: {result['error']}")
                return "\n".join(steps)

            steps.append("   Profile updated successfully")

            for key, value in update_data.items():
                steps.append(f"   {key.title()}: {value}")

            return "\n".join(steps)

        except Exception as e:
            return f"ERROR: {str(e)}"

    @mcp_app.tool()
    async def get_passenger_details(passenger_id: str) -> str:
        """Retrieves passenger profile, preferences, travel history, and special service requests."""
        try:
            steps = []
            steps.append("PASSENGER PROFILE")
            steps.append(f"ID: {passenger_id}")
            steps.append("")

            steps.append("1. Retrieving profile...")
            passenger = await api_request("passengers", f"/passengers/{passenger_id}")

            if "error" in passenger:
                steps.append("   ERROR: Passenger not found")
                return "\n".join(steps)

            steps.append(f"   Name: {passenger.get('first_name', '')} {passenger.get('last_name', '')}")
            steps.append(f"   Email: {passenger.get('email', 'N/A')}")
            steps.append(f"   Phone: {passenger.get('phone', 'N/A')}")

            steps.append("\n2. Checking loyalty status...")
            loyalty = await api_request("loyalty", f"/loyalty/passenger/{passenger_id}")

            if "error" not in loyalty:
                steps.append(f"   Tier: {loyalty.get('tier', 'None')}")
                steps.append(f"   Miles: {loyalty.get('miles_balance', 0):,}")
            else:
                steps.append("   No loyalty membership")

            return "\n".join(steps)

        except Exception as e:
            return f"ERROR: {str(e)}"

    @mcp_app.tool()
    async def track_baggage(booking_id: str, bag_tag: str = None) -> str:
        """Locates and provides current status/location of checked baggage."""
        try:
            steps = []
            steps.append("BAGGAGE TRACKING")
            steps.append(f"Booking: {booking_id}")
            if bag_tag:
                steps.append(f"Bag tag: {bag_tag}")
            steps.append("")

            steps.append("1. Locating baggage...")
            baggage = await api_request("baggage", f"/baggage/{booking_id}")

            if isinstance(baggage, list) and len(baggage) > 0:
                steps.append(f"   Found {len(baggage)} bag(s)")
                steps.append("\n2. Baggage details:")

                for i, bag in enumerate(baggage, 1):
                    steps.append(f"\n   Bag {i}:")
                    steps.append(f"      Tag: {bag.get('bag_tag', 'Unknown')}")
                    steps.append(f"      Status: {bag.get('status', 'In Transit')}")
                    steps.append(f"      Location: {bag.get('location', 'Unknown')}")
                    steps.append(f"      Last scan: {bag.get('last_scan_time', 'N/A')}")
            else:
                steps.append("   No checked baggage found")

            return "\n".join(steps)

        except Exception as e:
            return f"ERROR: {str(e)}"

    @mcp_app.tool()
    async def report_baggage_issue(
        booking_id: str,
        issue_type: str,
        description: str,
        bag_details: str = ""
    ) -> str:
        """Files a baggage claim for lost, delayed, or damaged luggage. Generates PIR (Property Irregularity Report) number."""
        try:
            steps = []
            steps.append("FILING BAGGAGE CLAIM")
            steps.append(f"Booking: {booking_id}")
            steps.append(f"Issue type: {issue_type}")
            steps.append("")

            steps.append("1. Creating Property Irregularity Report (PIR)...")

            claim_data = {
                "booking_id": booking_id,
                "issue_type": issue_type,
                "description": description,
                "bag_details": bag_details,
                "report_date": datetime.now().isoformat()
            }

            result = await api_request("baggage", "/baggage/claims", "POST", claim_data)

            if "error" in result:
                steps.append(f"   ERROR: {result['error']}")
                return "\n".join(steps)

            pir_number = result.get("data", {}).get("pir_number", f"PIR{random.randint(100000, 999999)}")
            steps.append(f"   PIR Number: {pir_number}")

            steps.append("\n2. Initiating baggage search...")
            steps.append("   Search initiated")
            steps.append("   Customer will be notified within 24 hours")

            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += f"\nCLAIM FILED SUCCESSFULLY"
            response += f"\nPIR Number: {pir_number}"
            response += f"\nStatus: Under investigation"
            response += "\n" + "="*60

            return response

        except Exception as e:
            return f"ERROR: {str(e)}"

    @mcp_app.tool()
    async def update_baggage_status(claim_id: str, status: str, notes: str = "") -> str:
        """Updates status of baggage claim (found, in transit to customer, delivered)."""
        try:
            steps = []
            steps.append("UPDATING BAGGAGE CLAIM STATUS")
            steps.append(f"Claim: {claim_id}")
            steps.append(f"New status: {status}")
            steps.append("")

            steps.append("1. Updating claim record...")
            update_data = {
                "status": status,
                "notes": notes,
                "update_time": datetime.now().isoformat()
            }

            result = await api_request("baggage", f"/baggage/claims/{claim_id}", "PATCH", update_data)

            if "error" in result:
                steps.append(f"   ERROR: {result['error']}")
                return "\n".join(steps)

            steps.append("   Status updated successfully")

            steps.append("\n2. Notifying passenger...")
            steps.append("   Notification sent")

            return "\n".join(steps)

        except Exception as e:
            return f"ERROR: {str(e)}"

    @mcp_app.tool()
    async def get_loyalty_profile(loyalty_number: str) -> str:
        """Accesses loyalty account showing tier status, miles balance, benefits, upgrade eligibility."""
        try:
            steps = []
            steps.append("LOYALTY PROFILE")
            steps.append(f"Member ID: {loyalty_number}")
            steps.append("")

            steps.append("1. Retrieving account details...")
            profile = await api_request("loyalty", f"/loyalty/members/{loyalty_number}")

            if "error" in profile:
                steps.append("   ERROR: Member not found")
                return "\n".join(steps)

            tier = profile.get("tier", "Standard")
            miles = profile.get("miles_balance", 0)
            status_miles = profile.get("status_miles", 0)
            lifetime_miles = profile.get("lifetime_miles", 0)

            steps.append(f"   Tier: {tier}")
            steps.append(f"   Miles balance: {miles:,}")
            steps.append(f"   Status miles (YTD): {status_miles:,}")
            steps.append(f"   Lifetime miles: {lifetime_miles:,}")

            steps.append("\n2. Tier benefits:")
            if tier == "Gold":
                steps.append("   - Priority check-in")
                steps.append("   - Extra baggage allowance")
                steps.append("   - Priority boarding")
            elif tier == "Platinum":
                steps.append("   - Lounge access")
                steps.append("   - Complimentary upgrades (subject to availability)")
                steps.append("   - Priority everything")
            elif tier == "Diamond":
                steps.append("   - Unlimited lounge access + guest")
                steps.append("   - Guaranteed upgrades")
                steps.append("   - Concierge service")

            return "\n".join(steps)

        except Exception as e:
            return f"ERROR: {str(e)}"

    @mcp_app.tool()
    async def search_loyalty_by_passenger(
        passenger_id: str = None,
        email: str = None,
        last_name: str = None
    ) -> str:
        """Finds loyalty account by passenger ID, email, or name."""
        try:
            steps = []
            steps.append("SEARCHING LOYALTY ACCOUNT")

            criteria = []
            if passenger_id:
                criteria.append(f"Passenger ID: {passenger_id}")
            if email:
                criteria.append(f"Email: {email}")
            if last_name:
                criteria.append(f"Last name: {last_name}")

            steps.append(f"Search: {', '.join(criteria)}")
            steps.append("")

            steps.append("1. Querying loyalty database...")

            query_params = []
            if passenger_id:
                query_params.append(f"passenger_id={passenger_id}")

            query_string = "&".join(query_params) if query_params else ""
            result = await api_request("loyalty", f"/loyalty/search?{query_string}")

            if "error" in result:
                steps.append("   No loyalty account found")
                return "\n".join(steps)

            steps.append(f"   Found account: {result.get('loyalty_number')}")
            steps.append(f"   Tier: {result.get('tier')}")
            steps.append(f"   Miles: {result.get('miles_balance', 0):,}")

            return "\n".join(steps)

        except Exception as e:
            return f"ERROR: {str(e)}"

    @mcp_app.tool()
    async def add_missing_miles(
        loyalty_number: str,
        booking_id: str,
        miles_claimed: int,
        reason: str = ""
    ) -> str:
        """Credits missing miles to loyalty account retroactively."""
        try:
            steps = []
            steps.append("CREDITING MISSING MILES")
            steps.append(f"Account: {loyalty_number}")
            steps.append(f"Booking: {booking_id}")
            steps.append(f"Miles: {miles_claimed:,}")
            steps.append("")

            steps.append("1. Verifying booking eligibility...")
            booking = await api_request("bookings", f"/bookings/{booking_id}")

            if "error" in booking:
                steps.append("   ERROR: Booking not found")
                return "\n".join(steps)

            steps.append("   Booking verified")

            steps.append("\n2. Crediting miles...")
            credit_data = {
                "loyalty_number": loyalty_number,
                "miles": miles_claimed,
                "booking_id": booking_id,
                "reason": reason,
                "type": "retroactive_credit"
            }

            result = await api_request("loyalty", "/loyalty/credit", "POST", credit_data)

            if "error" in result:
                steps.append(f"   ERROR: {result['error']}")
                return "\n".join(steps)

            new_balance = result.get("data", {}).get("new_balance", 0)
            steps.append(f"   Miles credited successfully")
            steps.append(f"   New balance: {new_balance:,}")

            return "\n".join(steps)

        except Exception as e:
            return f"ERROR: {str(e)}"

    @mcp_app.tool()
    async def calculate_delay_compensation(
        flight_id: str,
        delay_hours: float,
        passenger_count: int = 1
    ) -> str:
        """Calculates EU261/DOT compensation for flight delays based on duration and route."""
        try:
            steps = []
            steps.append("DELAY COMPENSATION CALCULATOR")
            steps.append(f"Flight: {flight_id}")
            steps.append(f"Delay: {delay_hours} hours")
            steps.append(f"Passengers: {passenger_count}")
            steps.append("")

            steps.append("1. Retrieving flight information...")
            flight = await api_request("flights", f"/flights/{flight_id}")

            international = False
            if "error" not in flight:
                origin = flight.get("origin", "???")
                dest = flight.get("destination", "???")
                steps.append(f"   Route: {origin} -> {dest}")

                international = origin[:2] != dest[:2]
                steps.append(f"   Type: {'International' if international else 'Domestic'}")
            else:
                steps.append("   Using domestic rates")

            steps.append("\n2. Calculating compensation...")

            if delay_hours < 3:
                compensation_per_pax = 0
                steps.append("   No compensation (delay < 3 hours)")
            elif delay_hours >= 3 and delay_hours < 4:
                compensation_per_pax = 400 if international else 250
                steps.append(f"   EU261/DOT: EUR {compensation_per_pax} per passenger")
            else:
                compensation_per_pax = 600 if international else 400
                steps.append(f"   EU261/DOT: EUR {compensation_per_pax} per passenger")

            total_compensation = compensation_per_pax * passenger_count

            steps.append("\n3. Additional benefits...")
            if delay_hours >= 2:
                steps.append(f"   Meal vouchers: ${15 * passenger_count}")
            if delay_hours >= 4:
                steps.append("   Hotel accommodation (if overnight)")
            if delay_hours >= 5:
                steps.append("   Transport to/from hotel")

            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += "\nCOMPENSATION SUMMARY"
            response += "\n" + "="*60
            response += f"\nPer passenger: EUR {compensation_per_pax}"
            response += f"\nTotal: EUR {total_compensation:,}"
            response += f"\nRegulation: EU261/US DOT"
            response += f"\nProcessing: 7-14 days"

            return response

        except Exception as e:
            return f"ERROR: {str(e)}"

    @mcp_app.tool()
    async def process_refund_request(
        booking_id: str,
        reason: str,
        documentation: str = ""
    ) -> str:
        """Initiates refund for cancelled booking based on fare rules and reason."""
        try:
            steps = []
            steps.append("PROCESSING REFUND REQUEST")
            steps.append(f"Booking: {booking_id}")
            steps.append(f"Reason: {reason}")
            steps.append("")

            steps.append("1. Retrieving booking details...")
            booking = await api_request("bookings", f"/bookings/{booking_id}")

            if "error" in booking:
                steps.append("   ERROR: Booking not found")
                return "\n".join(steps)

            total_paid = booking.get("total_price", 0)
            steps.append(f"   Amount paid: ${total_paid:.2f}")

            steps.append("\n2. Checking fare rules...")

            # Calculate refund based on reason
            refund_pct = 0
            if reason == "airline_cancel":
                refund_pct = 1.0  # Full refund
                steps.append("   Airline cancellation: 100% refund")
            elif reason == "medical" or reason == "bereavement":
                refund_pct = 0.9  # 90% refund with documentation
                steps.append(f"   {reason.title()}: 90% refund (with documentation)")
            elif reason == "weather":
                refund_pct = 1.0
                steps.append("   Weather disruption: 100% refund")
            else:
                refund_pct = 0.7  # 70% refund (30% penalty)
                steps.append("   Voluntary cancellation: 70% refund")

            refund_amount = total_paid * refund_pct
            penalty = total_paid - refund_amount

            steps.append(f"\n3. Processing refund...")
            refund_data = {
                "booking_id": booking_id,
                "amount": refund_amount,
                "reason": reason,
                "documentation": documentation
            }

            result = await api_request("bookings", f"/bookings/{booking_id}/refund", "POST", refund_data)

            if "error" in result:
                steps.append(f"   ERROR: {result['error']}")
                return "\n".join(steps)

            steps.append("   Refund approved")

            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += "\nREFUND SUMMARY"
            response += "\n" + "="*60
            response += f"\nOriginal payment: ${total_paid:.2f}"
            response += f"\nCancellation penalty: ${penalty:.2f}"
            response += f"\nRefund amount: ${refund_amount:.2f}"
            response += f"\nProcessing time: 7-10 business days"

            return response

        except Exception as e:
            return f"ERROR: {str(e)}"

    @mcp_app.tool()
    async def issue_travel_voucher(
        booking_id: str,
        amount: float,
        expiry_months: int = 12,
        reason: str = ""
    ) -> str:
        """Issues travel credit/voucher instead of refund."""
        try:
            steps = []
            steps.append("ISSUING TRAVEL VOUCHER")
            steps.append(f"Booking: {booking_id}")
            steps.append(f"Amount: ${amount:.2f}")
            steps.append(f"Validity: {expiry_months} months")
            steps.append("")

            steps.append("1. Creating voucher...")

            voucher_code = f"TVC{random.randint(100000, 999999)}"
            expiry_date = (datetime.now() + timedelta(days=expiry_months*30)).strftime("%Y-%m-%d")

            voucher_data = {
                "booking_id": booking_id,
                "voucher_code": voucher_code,
                "amount": amount,
                "expiry_date": expiry_date,
                "reason": reason
            }

            result = await api_request("bookings", "/bookings/vouchers", "POST", voucher_data)

            if "error" in result:
                steps.append(f"   ERROR: {result['error']}")
                return "\n".join(steps)

            steps.append(f"   Voucher code: {voucher_code}")
            steps.append(f"   Expiry: {expiry_date}")

            steps.append("\n2. Sending voucher to passenger...")
            steps.append("   Email sent")

            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += "\nTRAVEL VOUCHER ISSUED"
            response += "\n" + "="*60
            response += f"\nCode: {voucher_code}"
            response += f"\nValue: ${amount:.2f}"
            response += f"\nExpiry: {expiry_date}"
            response += f"\nUse for: Future flight bookings"

            return response

        except Exception as e:
            return f"ERROR: {str(e)}"

    @mcp_app.tool()
    async def send_notification(
        passenger_id: str,
        notification_type: str,
        message: str = "",
        channel: str = "both"
    ) -> str:
        """Sends notification to passenger (email/SMS) about flight changes, delays, gate changes."""
        try:
            steps = []
            steps.append("SENDING NOTIFICATION")
            steps.append(f"Passenger: {passenger_id}")
            steps.append(f"Type: {notification_type}")
            steps.append(f"Channel: {channel}")
            steps.append("")

            steps.append("1. Preparing notification...")
            notification_data = {
                "passenger_id": passenger_id,
                "type": notification_type,
                "message": message,
                "channel": channel,
                "timestamp": datetime.now().isoformat()
            }

            result = await api_request("notifications", "/notifications/send", "POST", notification_data)

            if "error" in result:
                steps.append(f"   ERROR: {result['error']}")
                return "\n".join(steps)

            steps.append("   Notification sent successfully")

            if channel == "both" or channel == "email":
                steps.append("   Email delivered")
            if channel == "both" or channel == "sms":
                steps.append("   SMS delivered")

            return "\n".join(steps)

        except Exception as e:
            return f"ERROR: {str(e)}"

    @mcp_app.tool()
    async def get_notification_history(passenger_id: str = None, booking_id: str = None) -> str:
        """Retrieves notification history for a passenger or booking."""
        try:
            steps = []
            steps.append("NOTIFICATION HISTORY")
            if passenger_id:
                steps.append(f"Passenger: {passenger_id}")
            if booking_id:
                steps.append(f"Booking: {booking_id}")
            steps.append("")

            steps.append("1. Retrieving notification history...")

            query_params = []
            if passenger_id:
                query_params.append(f"passenger_id={passenger_id}")
            if booking_id:
                query_params.append(f"booking_id={booking_id}")

            query_string = "&".join(query_params)
            history = await api_request("notifications", f"/notifications/history?{query_string}")

            if isinstance(history, list):
                steps.append(f"   Found {len(history)} notification(s)")

                response = "\n".join(steps)
                response += "\n\n" + "="*60
                response += "\nNOTIFICATION HISTORY"
                response += "\n" + "="*60

                for notif in history[:10]:
                    response += f"\n\n{notif.get('timestamp', 'N/A')}"
                    response += f"\n   Type: {notif.get('type')}"
                    response += f"\n   Channel: {notif.get('channel')}"
                    response += f"\n   Status: {notif.get('status', 'Delivered')}"
            else:
                response = "\n".join(steps)
                response += "\n\nNo notifications found"

            return response

        except Exception as e:
            return f"ERROR: {str(e)}"

    # ===== TICKETING AGENT TOOLS (Sales & Operations) =====

    @mcp_app.tool()
    async def search_flights(
        origin: str = None,
        destination: str = None,
        date: str = None,
        passengers: int = 1,
        cabin_class: str = "economy",
        flexible_dates: bool = False
    ) -> str:
        """Intelligently searches for available flights with OPTIONAL parameters. Can work with any combination or NO parameters."""
        try:
            steps = []
            steps.append("FLIGHT SEARCH")

            criteria = []
            if origin:
                criteria.append(f"From: {origin}")
            if destination:
                criteria.append(f"To: {destination}")
            if date:
                criteria.append(f"Date: {date}")
            criteria.append(f"Passengers: {passengers}")
            criteria.append(f"Class: {cabin_class}")

            steps.append(f"Search: {', '.join(criteria)}")
            steps.append("")

            steps.append("1. Querying flight inventory...")

            if origin and destination and date:
                search_result = await api_request("flights", f"/flights/search?origin={origin}&dest={destination}&date={date}")
            else:
                search_result = await api_request("flights", "/flights")

            if "error" in search_result:
                steps.append(f"   ERROR: {search_result['error']}")
                return "\n".join(steps)

            flights = search_result if isinstance(search_result, list) else []

            # Apply filters
            if origin and not (origin and destination and date):
                flights = [f for f in flights if f.get("origin", "").upper() == origin.upper()]
            if destination and not (origin and destination and date):
                flights = [f for f in flights if f.get("destination", "").upper() == destination.upper()]
            if date and not (origin and destination and date):
                flights = [f for f in flights if date in f.get("departure_time", "")]

            steps.append(f"   Found {len(flights)} flight(s)")

            steps.append("\n2. Fetching pricing...")
            priced_flights = []
            for flight in flights[:5]:
                flight_id = flight.get("id", flight.get("flight_id"))
                pricing = await api_request("pricing", "/pricing/calculate", "POST", {
                    "flight_id": flight_id,
                    "cabin_class": cabin_class,
                    "passengers": passengers
                })

                if "error" not in pricing:
                    flight["pricing"] = pricing
                    priced_flights.append(flight)
                    steps.append(f"   {flight_id}: ${pricing.get('total', 0):.2f}")

            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += "\nAVAILABLE FLIGHTS"
            response += "\n" + "="*60

            for i, flight in enumerate(priced_flights, 1):
                response += f"\n\n{i}. {flight.get('flight_id')}: {flight.get('origin')} -> {flight.get('destination')}"
                response += f"\n   Departure: {flight.get('departure_time')}"
                response += f"\n   Arrival: {flight.get('arrival_time')}"
                if "pricing" in flight:
                    response += f"\n   Price: ${flight['pricing'].get('total', 0):.2f}"

            return response

        except Exception as e:
            return f"ERROR: {str(e)}"

    @mcp_app.tool()
    async def get_flight_pricing(flight_id: str, cabin_class: str, passengers: int) -> str:
        """Gets comprehensive pricing for flight including base fare, taxes, fees, total."""
        try:
            steps = []
            steps.append("üí∞ **FLIGHT PRICING**")
            steps.append(f"‚úàÔ∏è  Flight: {flight_id}")
            steps.append(f"üë• Passengers: {passengers}")
            steps.append(f"üé´ Class: {cabin_class}")
            steps.append("")

            steps.append("1Ô∏è‚É£ Retrieving flight details...")
            flight = await api_request("flights", f"/flights/{flight_id}")

            if "error" in flight:
                steps.append("   ‚ùå Flight not found")
                return "\n".join(steps)

            steps.append(f"   ‚úÖ Route: {flight.get('origin')} ‚Üí {flight.get('destination')}")

            steps.append("\n2Ô∏è‚É£ Calculating pricing...")
            pricing = await api_request("pricing", "/pricing/calculate", "POST", {
                "flight_id": flight_id,
                "cabin_class": cabin_class,
                "passengers": passengers
            })

            if "error" in pricing:
                steps.append("   ‚ö†Ô∏è  Using estimated pricing")
                base_fare = 299.00 * passengers
                taxes = base_fare * 0.15
                total = base_fare + taxes
            else:
                base_fare = pricing.get("base_fare", 299.00) * passengers
                taxes = pricing.get("taxes", base_fare * 0.15)
                fees = pricing.get("fees", 0)
                total = pricing.get("total", base_fare + taxes + fees)

            steps.append(f"   üíµ Base fare: ${base_fare:.2f}")
            steps.append(f"   üíµ Taxes & fees: ${taxes:.2f}")
            steps.append(f"   üíµ Total: ${total:.2f}")

            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += "\n**PRICING BREAKDOWN** üí∞\n"
            response += "="*60
            response += f"\n\n**Base Fare**: ${base_fare:.2f}"
            response += f"\n**Taxes & Fees**: ${taxes:.2f}"
            response += f"\n**Total**: ${total:.2f}"
            response += f"\n**Per Passenger**: ${total/passengers:.2f}"

            return response

        except Exception as e:
            logger.error(f"Error in get_flight_pricing: {e}")
            return f"‚ùå Error: {str(e)}"

    @mcp_app.tool()
    async def calculate_total_trip_price(
        flight_ids: List[str],
        passengers: int,
        ancillaries: Dict[str, Any] = None
    ) -> str:
        """Calculates total price for complete itinerary including flights, ancillaries, fees."""
        try:
            if ancillaries is None:
                ancillaries = {}

            steps = []
            steps.append("üí∞ **TOTAL TRIP PRICE CALCULATOR**")
            steps.append(f"‚úàÔ∏è  Flights: {len(flight_ids)} segments")
            steps.append(f"üë• Passengers: {passengers}")
            steps.append("")

            total_base = 0
            total_taxes = 0
            ancillary_total = 0

            steps.append("1Ô∏è‚É£ Calculating flight costs...")
            for idx, fid in enumerate(flight_ids, 1):
                pricing = await api_request("pricing", "/pricing/calculate", "POST", {
                    "flight_id": fid,
                    "cabin_class": "economy",
                    "passengers": passengers
                })

                if "error" not in pricing:
                    segment_total = pricing.get("total", 299.00)
                else:
                    segment_total = 299.00

                total_base += segment_total
                steps.append(f"   Segment {idx}: ${segment_total:.2f}")

            steps.append(f"\n2Ô∏è‚É£ Calculating ancillaries...")
            if ancillaries.get("baggage_count", 0) > 0:
                baggage_fee = ancillaries["baggage_count"] * 35.00 * passengers
                ancillary_total += baggage_fee
                steps.append(f"   Baggage ({ancillaries['baggage_count']} bags): ${baggage_fee:.2f}")

            if ancillaries.get("seat_upgrades"):
                seat_fee = 50.00 * passengers * len(flight_ids)
                ancillary_total += seat_fee
                steps.append(f"   Seat upgrades: ${seat_fee:.2f}")

            if ancillaries.get("meals"):
                meal_fee = 15.00 * passengers * len(flight_ids)
                ancillary_total += meal_fee
                steps.append(f"   Meals: ${meal_fee:.2f}")

            total_taxes = total_base * 0.15
            grand_total = total_base + total_taxes + ancillary_total

            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += "\n**TRIP TOTAL** üí∞\n"
            response += "="*60
            response += f"\n\n**Flight Base**: ${total_base:.2f}"
            response += f"\n**Taxes & Fees**: ${total_taxes:.2f}"
            response += f"\n**Ancillaries**: ${ancillary_total:.2f}"
            response += f"\n**Grand Total**: ${grand_total:.2f}"

            return response

        except Exception as e:
            logger.error(f"Error in calculate_total_trip_price: {e}")
            return f"‚ùå Error: {str(e)}"

    @mcp_app.tool()
    async def book_flight_itinerary(
        flight_id: str,
        passenger_id: str,
        loyalty_number: str = None,
        seat_preference: str = None,
        include_baggage: bool = False,
        meal_preference: str = "standard"
    ) -> str:
        """Completes end-to-end booking process: creates reservation, issues ticket, assigns seats."""
        try:
            steps = []
            steps.append("FLIGHT BOOKING PROCESS")
            steps.append(f"Flight: {flight_id}")
            steps.append(f"Passenger: {passenger_id}")
            steps.append("")

            # Complete booking workflow (simplified for space)
            steps.append("1. Retrieving flight information...")
            flight = await api_request("flights", f"/flights/{flight_id}")
            if "error" in flight:
                return "ERROR: Flight not found"
            steps.append(f"   {flight.get('origin')} -> {flight.get('destination')}")

            steps.append("\n2. Creating booking...")
            booking_result = await api_request("bookings", "/bookings", "POST", {
                "flight_id": flight_id,
                "passenger_id": passenger_id
            })

            booking_id = booking_result.get("data", {}).get("booking_id", "UNKNOWN")
            steps.append(f"   Booking: {booking_id}")

            steps.append("\n3. Issuing ticket...")
            ticket = await api_request("tickets", "/tickets/issue", "POST", {
                "booking_id": booking_id,
                "passenger_id": passenger_id
            })
            steps.append("   Ticket issued")

            if seat_preference:
                steps.append("\n4. Assigning seat...")
                await api_request("checkin", f"/checkin/{booking_id}/seat", "POST", {"seat": seat_preference})
                steps.append(f"   Seat: {seat_preference}")

            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += "\nBOOKING COMPLETE"
            response += "\n" + "="*60
            response += f"\nBooking reference: {booking_id}"

            return response

        except Exception as e:
            return f"ERROR: {str(e)}"

    @mcp_app.tool()
    async def modify_booking(booking_id: str, new_flight_id: str, reason: str = "Customer request") -> str:
        """Modifies existing booking by changing flight, dates, or passengers. Calculates change fees."""
        try:
            steps = []
            steps.append("‚úèÔ∏è **BOOKING MODIFICATION**")
            steps.append(f"üìã Booking: {booking_id}")
            steps.append(f"‚úàÔ∏è  New Flight: {new_flight_id}")
            steps.append("")

            # Step 1: Get current booking
            steps.append("1Ô∏è‚É£ Retrieving current booking...")
            booking = await api_request("bookings", f"/bookings/{booking_id}")

            if "error" in booking:
                steps.append(f"   ‚ùå Booking not found: {booking['error']}")
                return "\n".join(steps)

            old_flight_id = booking.get("flight_id", "Unknown")
            passenger_id = booking.get("passenger_id", "Unknown")
            steps.append(f"   ‚úÖ Current flight: {old_flight_id}")

            # Step 2: Get new flight details
            steps.append("\n2Ô∏è‚É£ Checking new flight availability...")
            new_flight = await api_request("flights", f"/flights/{new_flight_id}")

            if "error" in new_flight:
                steps.append(f"   ‚ùå New flight not available")
                return "\n".join(steps)

            steps.append(f"   ‚úÖ New flight available")

            # Step 3: Calculate change fee
            steps.append("\n3Ô∏è‚É£ Calculating change fee...")
            change_fee = 75.00
            steps.append(f"   üí∞ Change fee: ${change_fee:.2f}")

            # Step 4: Update booking
            steps.append("\n4Ô∏è‚É£ Updating booking...")
            update_result = await api_request(
                "bookings",
                f"/bookings/{booking_id}",
                "PUT",
                {"flight_id": new_flight_id, "change_fee": change_fee}
            )

            if "error" not in update_result:
                steps.append(f"   ‚úÖ Booking updated successfully")
            else:
                steps.append(f"   ‚ö†Ô∏è  Update pending confirmation")

            # Step 5: Send notification
            steps.append("\n5Ô∏è‚É£ Sending confirmation...")
            await api_request(
                "notifications",
                "/notifications/send",
                "POST",
                {"type": "booking_confirmation", "recipient": passenger_id, "booking_id": booking_id}
            )
            steps.append(f"   ‚úÖ Confirmation sent")

            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += "\n**BOOKING MODIFIED** ‚úÖ\n"
            response += "="*60
            response += f"\n\n**Booking**: {booking_id}"
            response += f"\n**Old Flight**: {old_flight_id}"
            response += f"\n**New Flight**: {new_flight_id}"
            response += f"\n**Change Fee**: ${change_fee:.2f}"

            return response

        except Exception as e:
            logger.error(f"Error in modify_booking: {e}")
            return f"‚ùå Error: {str(e)}"

    @mcp_app.tool()
    async def verify_change_refund_eligibility(booking_id: str, action: str = "change") -> str:
        """Checks fare rules to determine if booking is eligible for changes or refunds."""
        try:
            steps = []
            steps.append("üìù **ELIGIBILITY CHECK**")
            steps.append(f"üìã Booking: {booking_id}")
            steps.append(f"üîß Action: {action}")
            steps.append("")

            steps.append("1Ô∏è‚É£ Retrieving booking...")
            booking = await api_request("bookings", f"/bookings/{booking_id}")

            if "error" in booking:
                steps.append("   ‚ùå Booking not found")
                return "\n".join(steps)

            fare_class = booking.get("fare_class", "economy")
            total_price = booking.get("total_price", 500.00)

            steps.append(f"   ‚úÖ Fare class: {fare_class}")
            steps.append(f"   ‚úÖ Price paid: ${total_price:.2f}")

            steps.append("\n2Ô∏è‚É£ Checking fare rules...")
            # Simplified fare rule logic
            if action == "change":
                change_fee = 75.00
                eligible = True
                steps.append(f"   ‚úÖ Changes allowed")
                steps.append(f"   üí∞ Change fee: ${change_fee:.2f}")
            elif action == "refund":
                refund_pct = 0.70
                refund_amount = total_price * refund_pct
                eligible = True
                steps.append(f"   ‚úÖ Refundable (70%)")
                steps.append(f"   üí∞ Refund amount: ${refund_amount:.2f}")
            else:  # cancel
                eligible = True
                steps.append(f"   ‚úÖ Cancellation allowed")

            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += "\n**ELIGIBILITY RESULT** ‚úÖ\n"
            response += "="*60
            response += f"\n\n**Booking**: {booking_id}"
            response += f"\n**Action**: {action.title()}"
            response += f"\n**Eligible**: Yes"
            if action == "change":
                response += f"\n**Change Fee**: ${change_fee:.2f}"
            elif action == "refund":
                response += f"\n**Refund Amount**: ${refund_amount:.2f}"

            return response

        except Exception as e:
            logger.error(f"Error in verify_change_refund_eligibility: {e}")
            return f"‚ùå Error: {str(e)}"

    @mcp_app.tool()
    async def cancel_booking_with_refund(
        booking_id: str,
        reason: str = "Customer request",
        full_refund: bool = False
    ) -> str:
        """Cancels booking and processes refund according to fare rules."""
        try:
            steps = []
            steps.append("‚ùå **BOOKING CANCELLATION WITH REFUND**")
            steps.append(f"üìã Booking: {booking_id}")
            steps.append(f"üìù Reason: {reason}")
            steps.append("")

            steps.append("1Ô∏è‚É£ Retrieving booking...")
            booking = await api_request("bookings", f"/bookings/{booking_id}")

            if "error" in booking:
                steps.append("   ‚ùå Booking not found")
                return "\n".join(steps)

            total_price = booking.get("total_price", 500.00)
            passenger_id = booking.get("passenger_id", "Unknown")

            steps.append(f"   ‚úÖ Amount paid: ${total_price:.2f}")

            steps.append("\n2Ô∏è‚É£ Calculating refund...")
            if full_refund:
                refund_amount = total_price
                penalty = 0
            else:
                penalty = 50.00
                refund_amount = max(0, total_price - penalty)

            steps.append(f"   üí∞ Penalty: ${penalty:.2f}")
            steps.append(f"   üí∞ Refund: ${refund_amount:.2f}")

            steps.append("\n3Ô∏è‚É£ Cancelling booking...")
            cancel_result = await api_request("bookings", f"/bookings/{booking_id}", "DELETE")

            if "error" not in cancel_result:
                steps.append("   ‚úÖ Booking cancelled")
            else:
                steps.append("   ‚ö†Ô∏è  Cancellation pending")

            steps.append("\n4Ô∏è‚É£ Processing refund...")
            steps.append(f"   ‚úÖ Refund of ${refund_amount:.2f} initiated")
            steps.append(f"   ‚ÑπÔ∏è  Processing time: 7-10 business days")

            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += "\n**CANCELLATION COMPLETE** ‚úÖ\n"
            response += "="*60
            response += f"\n\n**Booking**: {booking_id}"
            response += f"\n**Original Amount**: ${total_price:.2f}"
            response += f"\n**Penalty**: ${penalty:.2f}"
            response += f"\n**Refund**: ${refund_amount:.2f}"
            response += f"\n**Status**: Cancelled"

            return response

        except Exception as e:
            logger.error(f"Error in cancel_booking_with_refund: {e}")
            return f"‚ùå Error: {str(e)}"

    @mcp_app.tool()
    async def check_in_and_generate_boarding_pass(
        booking_id: str,
        seat_selection: str = None
    ) -> str:
        """Performs online check-in and generates boarding pass."""
        try:
            steps = []
            steps.append("üé´ **CHECK-IN PROCESS**")
            steps.append(f"üìã Booking: {booking_id}")
            steps.append("")

            # Step 1: Get booking
            steps.append("1Ô∏è‚É£ Retrieving booking...")
            booking = await api_request("bookings", f"/bookings/{booking_id}")

            if "error" in booking:
                steps.append(f"   ‚ùå Booking not found")
                return "\n".join(steps)

            flight_id = booking.get("flight_id", "Unknown")
            passenger_id = booking.get("passenger_id", "Unknown")
            steps.append(f"   ‚úÖ Flight: {flight_id}")

            # Step 2: Get flight details
            steps.append("\n2Ô∏è‚É£ Getting flight details...")
            flight = await api_request("flights", f"/flights/{flight_id}")

            # Default values
            dept_time = "Unknown"
            gate = "TBA"

            if "error" not in flight:
                dept_time = flight.get("departure_time", "Unknown")
                gate = flight.get("gate", "TBA")
                steps.append(f"   ‚úÖ Departure: {dept_time}")
                steps.append(f"   ‚úÖ Gate: {gate}")
            else:
                steps.append(f"   ‚ö†Ô∏è  Could not retrieve flight details")

            # Step 3: Seat assignment
            steps.append("\n3Ô∏è‚É£ Assigning seat...")
            if seat_selection:
                seat_result = await api_request(
                    "checkin",
                    f"/checkin/{booking_id}/seat",
                    "POST",
                    {"seat": seat_selection}
                )
                assigned_seat = seat_selection if "error" not in seat_result else "12A"
            else:
                assigned_seat = "12A"  # Auto-assign

            steps.append(f"   ‚úÖ Seat assigned: {assigned_seat}")

            # Step 4: Generate boarding pass
            steps.append("\n4Ô∏è‚É£ Generating boarding pass...")
            checkin_result = await api_request(
                "checkin",
                f"/checkin/{booking_id}",
                "POST",
                {"seat": assigned_seat, "checked_in": True}
            )

            boarding_pass_num = f"BP{booking_id[-6:]}{assigned_seat.replace(' ', '')}"
            steps.append(f"   ‚úÖ Boarding pass: {boarding_pass_num}")

            # Step 5: Send boarding pass
            steps.append("\n5Ô∏è‚É£ Sending boarding pass...")
            await api_request(
                "notifications",
                "/notifications/send",
                "POST",
                {"type": "flight_reminder", "recipient": passenger_id, "booking_id": booking_id}
            )
            steps.append(f"   ‚úÖ Boarding pass sent to mobile")

            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += "\n**CHECK-IN COMPLETE** ‚úÖ\n"
            response += "="*60
            response += f"\n\n**Booking**: {booking_id}"
            response += f"\n**Flight**: {flight_id}"
            response += f"\n**Seat**: {assigned_seat}"
            response += f"\n**Boarding Pass**: {boarding_pass_num}"
            response += f"\n**Gate**: {gate}"

            return response

        except Exception as e:
            logger.error(f"Error in check_in_and_generate_boarding_pass: {e}")
            return f"‚ùå Error: {str(e)}"

    @mcp_app.tool()
    async def select_seat(booking_id: str, seat_number: str, charge_fee: bool = True) -> str:
        """Allows passenger to select or change seat assignment."""
        try:
            steps = []
            steps.append("üí∫ **SEAT SELECTION**")
            steps.append(f"üìã Booking: {booking_id}")
            steps.append(f"ü™ë Seat: {seat_number}")
            steps.append("")

            steps.append("1Ô∏è‚É£ Checking seat availability...")
            # Simulate seat check
            seat_available = True
            seat_fee = 25.00 if charge_fee else 0.00

            if seat_available:
                steps.append(f"   ‚úÖ Seat {seat_number} is available")
                if seat_fee > 0:
                    steps.append(f"   üí∞ Seat selection fee: ${seat_fee:.2f}")
            else:
                steps.append(f"   ‚ùå Seat {seat_number} is occupied")
                return "\n".join(steps)

            steps.append("\n2Ô∏è‚É£ Assigning seat...")
            seat_result = await api_request("checkin", f"/checkin/{booking_id}/seat", "POST", {
                "seat": seat_number,
                "fee": seat_fee
            })

            if "error" not in seat_result:
                steps.append(f"   ‚úÖ Seat {seat_number} assigned")
            else:
                steps.append(f"   ‚ö†Ô∏è  Assignment pending")

            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += "\n**SEAT CONFIRMED** üí∫\n"
            response += "="*60
            response += f"\n\n**Booking**: {booking_id}"
            response += f"\n**Seat**: {seat_number}"
            if seat_fee > 0:
                response += f"\n**Fee**: ${seat_fee:.2f}"

            return response

        except Exception as e:
            logger.error(f"Error in select_seat: {e}")
            return f"‚ùå Error: {str(e)}"

    @mcp_app.tool()
    async def manage_baggage(
        booking_id: str,
        action: str,
        baggage_count: int = 1,
        baggage_type: str = "standard"
    ) -> str:
        """Adds, removes, or modifies baggage for a booking."""
        try:
            steps = []
            steps.append("üß≥ **BAGGAGE MANAGEMENT**")
            steps.append(f"üìã Booking: {booking_id}")
            steps.append(f"üîß Action: {action}")
            steps.append(f"üíº Count: {baggage_count} bag(s)")
            steps.append(f"üì¶ Type: {baggage_type}")
            steps.append("")

            # Step 1: Get booking details
            steps.append("1Ô∏è‚É£ Retrieving booking...")
            booking = await api_request("bookings", f"/bookings/{booking_id}")

            if "error" in booking:
                steps.append(f"   ‚ùå Booking not found")
                return "\n".join(steps)

            flight_id = booking.get("flight_id", "Unknown")
            passenger_id = booking.get("passenger_id", "Unknown")
            current_bags = booking.get("checked_bags", 0)
            steps.append(f"   ‚úÖ Current baggage: {current_bags} bag(s)")

            # Step 2: Calculate fees
            steps.append("\n2Ô∏è‚É£ Calculating baggage fees...")

            # Fee structure
            fee_per_bag = 35.0  # Standard bag fee
            if baggage_type == "oversize":
                fee_per_bag = 75.0
            elif baggage_type == "sports_equipment":
                fee_per_bag = 50.0

            # First bag often free, subsequent bags charged
            free_bags = 1
            if action == "add":
                new_total = current_bags + baggage_count
                chargeable_bags = max(0, new_total - free_bags)
                total_fee = chargeable_bags * fee_per_bag
            elif action == "remove":
                new_total = max(0, current_bags - baggage_count)
                # Calculate refund if applicable
                total_fee = -min(current_bags - free_bags, baggage_count) * fee_per_bag
            else:  # modify
                new_total = baggage_count
                chargeable_bags = max(0, new_total - free_bags)
                total_fee = chargeable_bags * fee_per_bag

            steps.append(f"   üìä New total: {new_total} bag(s)")
            steps.append(f"   üí∞ Fee: ${abs(total_fee):.2f}" + (" (refund)" if total_fee < 0 else ""))

            # Step 3: Update baggage record
            steps.append("\n3Ô∏è‚É£ Updating baggage records...")
            baggage_update = await api_request(
                "baggage",
                f"/baggage/{booking_id}",
                "POST" if action == "add" else "PUT",
                {
                    "booking_id": booking_id,
                    "passenger_id": passenger_id,
                    "bags": new_total,
                    "baggage_type": baggage_type,
                    "fee": total_fee
                }
            )

            if "error" not in baggage_update:
                steps.append(f"   ‚úÖ Baggage updated")
            else:
                steps.append(f"   ‚ö†Ô∏è  Update pending")

            # Step 4: Update booking
            steps.append("\n4Ô∏è‚É£ Updating booking..." )
            await api_request(
                "bookings",
                f"/bookings/{booking_id}",
                "PUT",
                {"checked_bags": new_total, "baggage_fee": total_fee}
            )
            steps.append(f"   ‚úÖ Booking updated")

            # Step 5: Send confirmation
            steps.append("\n5Ô∏è‚É£ Sending confirmation...")
            await api_request(
                "notifications",
                "/notifications/send",
                "POST",
                {"type": "baggage_confirmation", "recipient": passenger_id, "booking_id": booking_id}
            )
            steps.append(f"   ‚úÖ Confirmation sent")

            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += "\n**BAGGAGE UPDATED** ‚úÖ\n"
            response += "="*60
            response += f"\n\n**Booking**: {booking_id}"
            response += f"\n**Baggage**: {new_total} bag(s) ({baggage_type})"
            response += f"\n**Fee**: ${abs(total_fee):.2f}" + (" (refund)" if total_fee < 0 else "")

            return response

        except Exception as e:
            logger.error(f"Error in manage_baggage: {e}")
            return f"‚ùå Error: {str(e)}"

    @mcp_app.tool()
    async def update_meal_preference(
        booking_id: str,
        meal_type: str = "standard",
        special_requests: str = ""
    ) -> str:
        """Updates meal preferences for a booking."""
        try:
            steps = []
            steps.append("üçΩÔ∏è **MEAL PREFERENCE UPDATE**")
            steps.append(f"üìã Booking: {booking_id}")
            steps.append(f"ü•ò Meal Type: {meal_type}")
            if special_requests:
                steps.append(f"üìù Special Requests: {special_requests}")
            steps.append("")

            steps.append("1Ô∏è‚É£ Retrieving booking...")
            booking = await api_request("bookings", f"/bookings/{booking_id}")

            if "error" in booking:
                steps.append("   ‚ùå Booking not found")
                return "\n".join(steps)

            passenger_id = booking.get("passenger_id", "Unknown")
            steps.append(f"   ‚úÖ Booking found")

            steps.append("\n2Ô∏è‚É£ Updating meal preference...")
            meal_result = await api_request("ancillaries", "/ancillaries/meal", "POST", {
                "booking_id": booking_id,
                "passenger_id": passenger_id,
                "meal_type": meal_type,
                "special_requests": special_requests
            })

            if "error" not in meal_result:
                steps.append(f"   ‚úÖ Meal preference updated to: {meal_type}")
            else:
                steps.append(f"   ‚ö†Ô∏è  Update pending confirmation")

            if special_requests:
                steps.append(f"   ‚úÖ Special requests noted")

            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += "\n**MEAL UPDATED** üçΩÔ∏è\n"
            response += "="*60
            response += f"\n\n**Booking**: {booking_id}"
            response += f"\n**Meal Type**: {meal_type.replace('_', ' ').title()}"
            if special_requests:
                response += f"\n**Special Requests**: {special_requests}"

            return response

        except Exception as e:
            logger.error(f"Error in update_meal_preference: {e}")
            return f"‚ùå Error: {str(e)}"

    @mcp_app.tool()
    async def check_standby_status(booking_id: str, standby_flight_id: str) -> str:
        """Checks passenger's position on standby list and clearance likelihood."""
        try:
            steps = []
            steps.append("‚è≥ **STANDBY STATUS CHECK**")
            steps.append(f"üìã Booking: {booking_id}")
            steps.append(f"‚úàÔ∏è  Standby Flight: {standby_flight_id}")
            steps.append("")

            steps.append("1Ô∏è‚É£ Checking standby list...")
            # Simulated standby position
            position = 3
            total_on_list = 7
            available_seats = 2

            steps.append(f"   ‚úÖ Position on list: #{position}")
            steps.append(f"   ‚ÑπÔ∏è  Total on standby: {total_on_list}")
            steps.append(f"   ‚ÑπÔ∏è  Available seats: {available_seats}")

            steps.append("\n2Ô∏è‚É£ Calculating clearance likelihood...")
            if position <= available_seats:
                likelihood = "High"
                steps.append(f"   ‚úÖ Likelihood: {likelihood} - You should clear!")
            else:
                likelihood = "Low"
                steps.append(f"   ‚ö†Ô∏è  Likelihood: {likelihood}")

            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += "\n**STANDBY STATUS** ‚è≥\n"
            response += "="*60
            response += f"\n\n**Position**: #{position} of {total_on_list}"
            response += f"\n**Available Seats**: {available_seats}"
            response += f"\n**Clearance Likelihood**: {likelihood}"

            return response

        except Exception as e:
            logger.error(f"Error in check_standby_status: {e}")
            return f"‚ùå Error: {str(e)}"

    @mcp_app.tool()
    async def get_loyalty_status(loyalty_number: str) -> str:
        """Retrieves detailed loyalty tier status, benefits, and progress toward next tier."""
        try:
            steps = []
            steps.append("üèÜ **LOYALTY STATUS CHECK**")
            steps.append(f"üé´ Member Number: {loyalty_number}")
            steps.append("")

            # Step 1: Get member details
            steps.append("1Ô∏è‚É£ Retrieving membership information...")
            loyalty = await api_request("loyalty", f"/loyalty/members/{loyalty_number}")

            if "error" in loyalty:
                steps.append(f"   ‚ùå Member not found: {loyalty['error']}")
                return "\n".join(steps)

            name = loyalty.get("name", "Unknown")
            tier = loyalty.get("tier", "Standard")
            miles = loyalty.get("miles", 0)
            tier_miles = loyalty.get("tier_qualifying_miles", 0)
            member_since = loyalty.get("member_since", "Unknown")

            steps.append(f"   ‚úÖ Member: {name}")
            steps.append(f"   ‚úÖ Tier: {tier}")
            steps.append(f"   ‚úÖ Available Miles: {miles:,}")
            steps.append(f"   ‚úÖ Tier Miles: {tier_miles:,}")
            steps.append(f"   ‚úÖ Member Since: {member_since}")

            # Step 2: Calculate next tier requirements
            steps.append("\n2Ô∏è‚É£ Calculating tier progress...")
            next_tier_requirements = {
                "Standard": ("Silver", 25000),
                "Silver": ("Gold", 50000),
                "Gold": ("Platinum", 75000),
                "Platinum": ("Diamond", 100000),
                "Diamond": ("Diamond", 100000)  # Already at top
            }

            next_tier, required_miles = next_tier_requirements.get(tier, ("Unknown", 0))
            miles_needed = max(0, required_miles - tier_miles)

            if tier == "Diamond":
                steps.append(f"   üèÜ **Already at highest tier!**")
            else:
                progress_pct = (tier_miles / required_miles * 100) if required_miles > 0 else 0
                steps.append(f"   üìä Progress to {next_tier}: {progress_pct:.1f}%")
                steps.append(f"   ‚úàÔ∏è  {miles_needed:,} miles needed")

            # Build response
            response = "\n".join(steps)
            response += "\n\n**TIER BENEFITS**:\n"

            benefits = {
                "Standard": ["Earn 1 mile per dollar", "Standard booking"],
                "Silver": ["Earn 1.25 miles per dollar", "Priority check-in", "1 free checked bag"],
                "Gold": ["Earn 1.5 miles per dollar", "Priority boarding", "2 free checked bags", "10% discount on tickets"],
                "Platinum": ["Earn 1.75 miles per dollar", "Lounge access", "3 free checked bags", "15% discount on tickets"],
                "Diamond": ["Earn 2 miles per dollar", "Premium lounge access", "Unlimited free bags", "20% discount", "Complimentary upgrades"]
            }

            for benefit in benefits.get(tier, []):
                response += f"‚Ä¢ {benefit}\n"

            return response

        except Exception as e:
            logger.error(f"Error in get_loyalty_status: {e}")
            return f"‚ùå System error: {str(e)}"

    @mcp_app.tool()
    async def redeem_miles_for_flight(
        flight_id: str,
        passenger_id: str,
        loyalty_number: str,
        miles_to_use: int
    ) -> str:
        """Books flight using loyalty miles (award redemption)."""
        try:
            steps = []
            steps.append("üíé **MILES REDEMPTION**")
            steps.append(f"‚úàÔ∏è  Flight: {flight_id}")
            steps.append(f"üé´ Loyalty: {loyalty_number}")
            steps.append(f"üí∞ Miles: {miles_to_use:,}")
            steps.append("")

            # Step 1: Check loyalty account
            steps.append("1Ô∏è‚É£ Checking loyalty account...")
            loyalty = await api_request("loyalty", f"/loyalty/members/{loyalty_number}")

            if "error" in loyalty:
                steps.append(f"   ‚ùå Loyalty account not found")
                return "\n".join(steps)

            available_miles = loyalty.get("miles_balance", 0)
            tier = loyalty.get("tier", "Standard")
            steps.append(f"   ‚úÖ Available miles: {available_miles:,}")
            steps.append(f"   ‚úÖ Tier: {tier}")

            # Step 2: Check if enough miles
            if available_miles < miles_to_use:
                steps.append("\n‚ùå **INSUFFICIENT MILES**")
                steps.append(f"   Needed: {miles_to_use:,}")
                steps.append(f"   Available: {available_miles:,}")
                steps.append(f"   Short by: {miles_to_use - available_miles:,}")
                return "\n".join(steps)

            steps.append("\n2Ô∏è‚É£ Validating redemption...")
            steps.append(f"   ‚úÖ Sufficient miles available")

            # Step 3: Get flight pricing
            steps.append("\n3Ô∏è‚É£ Calculating ticket value...")
            pricing = await api_request(
                "pricing",
                "/pricing/calculate",
                "POST",
                {"flight_id": flight_id, "cabin_class": "economy", "passengers": 1}
            )

            ticket_value = pricing.get("total", 500) if "error" not in pricing else 500
            miles_value = miles_to_use / 100  # 100 miles = $1
            steps.append(f"   üíµ Ticket value: ${ticket_value:.2f}")
            steps.append(f"   üíé Miles value: ${miles_value:.2f}")

            # Step 4: Create booking
            steps.append("\n4Ô∏è‚É£ Creating award booking...")
            booking = await api_request(
                "bookings",
                "/bookings",
                "POST",
                {
                    "flight_id": flight_id,
                    "passenger_id": passenger_id,
                    "total_price": 0,
                    "payment_method": "miles",
                    "miles_used": miles_to_use
                }
            )

            if "error" in booking:
                steps.append(f"   ‚ùå Booking failed")
                return "\n".join(steps)

            booking_id = booking.get("data", {}).get("booking_id", "AWARD001")
            steps.append(f"   ‚úÖ Booking created: {booking_id}")

            # Step 5: Deduct miles
            steps.append("\n5Ô∏è‚É£ Deducting miles...")
            new_balance = available_miles - miles_to_use
            steps.append(f"   ‚úÖ Miles deducted: {miles_to_use:,}")
            steps.append(f"   ‚úÖ New balance: {new_balance:,}")

            # Step 6: Issue ticket
            steps.append("\n6Ô∏è‚É£ Issuing award ticket...")
            ticket = await api_request(
                "tickets",
                "/tickets/issue",
                "POST",
                {"booking_id": booking_id, "passenger_id": passenger_id}
            )

            ticket_number = ticket.get("data", {}).get("ticket_number", "AWARD-TKT") if "error" not in ticket else "AWARD-TKT"
            steps.append(f"   ‚úÖ Ticket: {ticket_number}")

            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += "\n**AWARD BOOKING COMPLETE** ‚úÖ\n"
            response += "="*60
            response += f"\n\n**Booking**: {booking_id}"
            response += f"\n**Ticket**: {ticket_number}"
            response += f"\n**Miles Used**: {miles_to_use:,}"
            response += f"\n**Remaining Miles**: {new_balance:,}"

            return response

        except Exception as e:
            logger.error(f"Error in redeem_miles_for_flight: {e}")
            return f"‚ùå Error: {str(e)}"

    # ===== PARTNER ASSISTANCE TOOLS =====

    @mcp_app.tool()
    async def enroll_partner_flight(
        partner_code: str,
        flight_number: str,
        origin: str,
        destination: str,
        departure_time: str,
        seats_allocated: int = 20
    ) -> str:
        """Enrolls partner airline flight in codeshare agreement."""
        try:
            steps = []
            steps.append("ü§ù **PARTNER FLIGHT ENROLLMENT**")
            steps.append(f"‚úàÔ∏è  Partner: {partner_code} | Flight: {flight_number}")
            steps.append(f"üìç Route: {origin} ‚Üí {destination}")
            steps.append("")

            # Step 1: Validate partner agreement
            steps.append("1Ô∏è‚É£ Validating partner agreement...")
            # Mock validation
            valid_partners = ["BA", "AF", "LH", "JL", "QF"]
            if partner_code not in valid_partners:
                steps.append(f"   ‚ùå Partner {partner_code} not found in alliance database")
                return "\n".join(steps)
            steps.append(f"   ‚úÖ Partner {partner_code} is active in SkyAlliance")

            # Step 2: Check route compatibility
            steps.append("\n2Ô∏è‚É£ Checking route compatibility...")
            steps.append(f"   ‚úÖ Route {origin}-{destination} approved for codeshare")

            # Step 3: Create virtual flight record via API
            steps.append("\n3Ô∏è‚É£ Creating virtual flight record...")
            virtual_flight_num = f"CS{flight_number}"

            # POST to flights API to create the flight
            flight_create = await api_request(
                "flights",
                "/flights",
                "POST",
                {
                    "flight_id": virtual_flight_num,
                    "partner_code": partner_code,
                    "physical_flight": f"{partner_code}{flight_number}",
                    "origin": origin,
                    "destination": destination,
                    "departure_time": departure_time,
                    "flight_type": "codeshare",
                    "operating_carrier": partner_code,
                    "marketing_carrier": "US"
                }
            )

            if "error" not in flight_create:
                steps.append(f"   ‚úÖ Virtual flight created: {virtual_flight_num}")
                steps.append(f"   ‚úÖ Registered in system")
            else:
                steps.append(f"   ‚ö†Ô∏è  Flight record pending (may already exist)")
                steps.append(f"   ‚úÖ Virtual flight: {virtual_flight_num}")

            steps.append(f"   ‚ÑπÔ∏è  Mapped to physical flight {partner_code}{flight_number}")

            # Step 4: Allocate inventory
            steps.append("\n4Ô∏è‚É£ Allocating inventory...")
            steps.append(f"   ‚úÖ {seats_allocated} seats allocated to inventory pool")
            steps.append(f"   ‚úÖ Booking classes: Y, J, F mapped")

            # Step 5: Publish to GDS/Distribution
            steps.append("\n5Ô∏è‚É£ Publishing to distribution channels...")
            steps.append(f"   ‚úÖ Flight {virtual_flight_num} now visible in search")

            # Build response
            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += "\n**ENROLLMENT COMPLETE** ‚úÖ\n"
            response += "="*60
            response += f"\n\n**Virtual Flight**: {virtual_flight_num}"
            response += f"\n**Operator**: {partner_code}"
            response += f"\n**Inventory**: {seats_allocated} seats"
            response += f"\n**Status**: Active / Sellable"

            return response

        except Exception as e:
            logger.error(f"Error in enroll_partner_flight: {e}")
            return f"‚ùå Error: {str(e)}"

    @mcp_app.tool()
    async def update_partner_schedule(
        partner_code: str,
        flight_number: str,
        new_departure_time: str,
        reason: str = "Operational adjustment"
    ) -> str:
        """Updates partner flight schedule and notifies affected passengers."""
        try:
            steps = []
            steps.append("üìÖ **PARTNER SCHEDULE UPDATE**")
            steps.append(f"‚úàÔ∏è  Flight: {partner_code}{flight_number}")
            steps.append(f"üìù Reason: {reason}")
            steps.append("")

            # Step 1: GET current flight schedule
            steps.append("1Ô∏è‚É£ Retrieving current flight schedule...")
            virtual_flight_num = f"CS{flight_number}"

            # Try to get the actual flight from API
            flight = await api_request("flights", f"/flights/{virtual_flight_num}")

            old_departure = "Unknown"
            old_arrival = "Unknown"
            origin = "???"
            destination = "???"

            if "error" not in flight:
                old_departure = flight.get("departure_time", "Unknown")
                old_arrival = flight.get("arrival_time", "Unknown")
                origin = flight.get("origin", "???")
                destination = flight.get("destination", "???")

                steps.append(f"   ‚úÖ Found: {virtual_flight_num}")
                steps.append(f"   üìç Route: {origin} ‚Üí {destination}")
                steps.append(f"   üïê Current Departure: {old_departure}")
                steps.append(f"   üïë Current Arrival: {old_arrival}")
            else:
                # Flight not found via API, use mock data
                steps.append(f"   ‚úÖ Found mapped virtual flight: {virtual_flight_num}")
                old_departure = "2024-12-15T14:30:00Z"

            # Step 2: Show before/after comparison
            steps.append("\n2Ô∏è‚É£ Comparing schedules...")
            steps.append(f"   üìä **BEFORE**: {old_departure}")
            steps.append(f"   üìä **AFTER**: {new_departure_time}")

            # Calculate time difference if possible
            try:
                old_dt = datetime.fromisoformat(old_departure.replace('Z', '+00:00'))
                new_dt = datetime.fromisoformat(new_departure_time.replace('Z', '+00:00'))
                diff = new_dt - old_dt
                diff_hours = diff.total_seconds() / 3600

                if diff_hours > 0:
                    steps.append(f"   ‚è±Ô∏è  Delay: +{abs(diff_hours):.1f} hours")
                elif diff_hours < 0:
                    steps.append(f"   ‚è±Ô∏è  Earlier by: {abs(diff_hours):.1f} hours")
                else:
                    steps.append(f"   ‚è±Ô∏è  No time change")
            except:
                pass

            # Step 3: Update schedule (POST/PUT to API)
            steps.append("\n3Ô∏è‚É£ Updating schedule in system...")

            update_result = await api_request(
                "flights",
                f"/flights/{virtual_flight_num}",
                "PUT",
                {
                    "departure_time": new_departure_time,
                    "reason": reason,
                    "updated_by": f"Partner {partner_code}"
                }
            )

            if "error" not in update_result:
                steps.append(f"   ‚úÖ Departure time updated to {new_departure_time}")
            else:
                steps.append(f"   ‚ö†Ô∏è  Update pending confirmation")

            # Step 4: Identify affected bookings
            steps.append("\n4Ô∏è‚É£ Identifying affected bookings...")
            affected_count = 42  # Mock
            steps.append(f"   ‚ö†Ô∏è  Found {affected_count} active bookings")

            # Step 5: Check connection validity
            steps.append("\n5Ô∏è‚É£ Validating connections...")
            broken_connections = 3
            steps.append(f"   ‚ö†Ô∏è  {broken_connections} connections broken by schedule change")

            # Step 6: Notify passengers
            steps.append("\n6Ô∏è‚É£ Triggering notifications...")
            notification = await api_request(
                "notifications",
                "/notifications/send",
                "POST",
                {
                    "type": "flight_reminder",
                    "recipient": "affected_passengers",
                    "booking_id": "BATCH"
                }
            )
            steps.append(f"   ‚úÖ Notifications queued for {affected_count} passengers")

            # Build response
            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += "\n**SCHEDULE UPDATED** ‚úÖ\n"
            response += "="*60
            response += f"\n\n**Flight**: {partner_code}{flight_number} ({virtual_flight_num})"
            response += f"\n**Route**: {origin} ‚Üí {destination}"
            response += f"\n\n**BEFORE**: {old_departure}"
            response += f"\n**AFTER**: {new_departure_time}"
            response += f"\n\n**Affected Passengers**: {affected_count}"
            response += f"\n**Broken Connections**: {broken_connections}"
            response += f"\n**Action Required**: Manual review needed for {broken_connections} bookings"

            return response

        except Exception as e:
            logger.error(f"Error in update_partner_schedule: {e}")
            return f"‚ùå Error: {str(e)}"

    @mcp_app.tool()
    async def create_alliance_booking(passenger_id: str, segments: List[Dict[str, str]]) -> str:
        """Creates multi-airline booking across alliance partners."""
        try:
            steps = []
            steps.append("üåê **ALLIANCE BOOKING CREATION**")
            steps.append(f"üë§ Passenger: {passenger_id}")
            steps.append(f"‚úàÔ∏è  Segments: {len(segments)}")
            steps.append("")

            # Step 1: Validate segments
            steps.append("1Ô∏è‚É£ Validating flight segments...")
            total_price = 0
            valid_segments = []

            for i, seg in enumerate(segments):
                airline = seg.get("airline")
                flight = seg.get("flight_number")
                steps.append(f"   Checking Segment {i+1}: {airline}{flight}...")

                if airline == "US": # Our airline
                    # Check our inventory
                    steps.append(f"   ‚úÖ {airline}{flight}: Confirmed (Native)")
                    total_price += 450.00
                else:
                    # Check partner inventory
                    steps.append(f"   ‚úÖ {airline}{flight}: Confirmed (Partner {airline})")
                    total_price += 520.00

                valid_segments.append(f"{airline}{flight}")

            # Step 2: Calculate interline pricing
            steps.append("\n2Ô∏è‚É£ Calculating interline pricing...")
            steps.append(f"   ‚úÖ Base Fare: ${total_price:.2f}")
            taxes = 150.00
            total = total_price + taxes
            steps.append(f"   ‚úÖ Taxes & Fees: ${taxes:.2f}")
            steps.append(f"   üí∞ Total: ${total:.2f}")

            # Step 3: Create PNR
            steps.append("\n3Ô∏è‚É£ Creating Passenger Name Record (PNR)...")
            booking_id = f"AL{random.randint(10000, 99999)}"
            steps.append(f"   ‚úÖ PNR Created: {booking_id}")

            # Step 4: Issue tickets
            steps.append("\n4Ô∏è‚É£ Issuing e-tickets...")
            ticket_num = f"016{random.randint(1000000000, 9999999999)}"
            steps.append(f"   ‚úÖ Ticket issued: {ticket_num}")
            steps.append(f"   ‚ÑπÔ∏è  Valid on: {', '.join(valid_segments)}")

            # Step 5: Sync with partners
            steps.append("\n5Ô∏è‚É£ Syncing with partner systems...")
            for seg in segments:
                if seg.get("airline") != "US":
                    steps.append(f"   ‚úÖ Synced with {seg.get('airline')} reservation system")

            # Build response
            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += "\n**BOOKING CONFIRMED** ‚úÖ\n"
            response += "="*60
            response += f"\n\n**Booking Ref**: {booking_id}"
            response += f"\n**Ticket**: {ticket_num}"
            response += f"\n**Itinerary**: {' -> '.join(valid_segments)}"
            response += f"\n**Total Price**: ${total:.2f}"

            return response

        except Exception as e:
            logger.error(f"Error in create_alliance_booking: {e}")
            return f"‚ùå Error: {str(e)}"

    @mcp_app.tool()
    async def reconcile_partner_revenue(partner_code: str, period: str) -> str:
        """Reconciles revenue share with partner airline for a period."""
        try:
            steps = []
            steps.append("üí∞ **REVENUE RECONCILIATION**")
            steps.append(f"üè¢ Partner: {partner_code}")
            steps.append(f"üìÖ Period: {period}")
            steps.append("")

            # Step 1: Aggregate flight data
            steps.append("1Ô∏è‚É£ Aggregating flight data...")
            flights_count = 45
            passengers_count = 6200
            steps.append(f"   ‚úÖ Processed {flights_count} flights")
            steps.append(f"   ‚úÖ Processed {passengers_count} passengers")

            # Step 2: Calculate gross revenue
            steps.append("\n2Ô∏è‚É£ Calculating gross revenue...")
            gross_revenue = 1250000.00
            steps.append(f"   üíµ Gross Revenue: ${gross_revenue:,.2f}")

            # Step 3: Apply prorate factors
            steps.append("\n3Ô∏è‚É£ Applying prorate factors...")
            # Mock prorate calculation based on mileage
            our_share_pct = 0.45
            partner_share_pct = 0.55
            steps.append(f"   üìä Mileage split: Us {our_share_pct*100}% / {partner_code} {partner_share_pct*100}%")

            partner_share = gross_revenue * partner_share_pct
            steps.append(f"   üí∞ Partner Share: ${partner_share:,.2f}")

            # Step 4: Deduct fees and commissions
            steps.append("\n4Ô∏è‚É£ Deducting fees and commissions...")
            handling_fees = 15000.00
            booking_fees = 5000.00
            steps.append(f"   üìâ Handling Fees: -${handling_fees:,.2f}")
            steps.append(f"   üìâ Booking Fees: -${booking_fees:,.2f}")

            net_settlement = partner_share - handling_fees - booking_fees

            # Step 5: Generate settlement report
            steps.append("\n5Ô∏è‚É£ Generating settlement report...")
            report_id = f"SET-{partner_code}-{period}"
            steps.append(f"   ‚úÖ Report generated: {report_id}")
            steps.append(f"   ‚úÖ Sent to clearing house (IATA ICH)")

            # Build response
            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += "\n**RECONCILIATION COMPLETE** ‚úÖ\n"
            response += "="*60
            response += f"\n\n**Settlement ID**: {report_id}"
            response += f"\n**Net Settlement**: ${net_settlement:,.2f}"
            response += f"\n**Direction**: PAY TO {partner_code}"
            response += f"\n**Status**: PENDING CLEARING"

            return response

        except Exception as e:
            logger.error(f"Error in reconcile_partner_revenue: {e}")
            return f"‚ùå Error: {str(e)}"

    @mcp_app.tool()
    async def get_airport_information(airport_code: str) -> str:
        """Retrieves airport details including name, location, terminals, and facilities."""
        try:
            steps = []
            steps.append("üè¢ **AIRPORT INFORMATION**")
            steps.append(f"üìç Code: {airport_code}")
            steps.append("")

            # Mock airport data
            airports = {
                "JFK": {"name": "John F. Kennedy International", "city": "New York", "country": "USA", "terminals": 8},
                "LAX": {"name": "Los Angeles International", "city": "Los Angeles", "country": "USA", "terminals": 9},
                "LHR": {"name": "London Heathrow", "city": "London", "country": "UK", "terminals": 5},
                "DXB": {"name": "Dubai International", "city": "Dubai", "country": "UAE", "terminals": 3}
            }

            airport = airports.get(airport_code.upper(), {
                "name": "Unknown Airport",
                "city": "Unknown",
                "country": "Unknown",
                "terminals": 1
            })

            steps.append("1Ô∏è‚É£ Retrieving airport data...")
            steps.append(f"   ‚úÖ Name: {airport['name']}")
            steps.append(f"   ‚úÖ City: {airport['city']}, {airport['country']}")
            steps.append(f"   ‚úÖ Terminals: {airport['terminals']}")

            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += "\n**AIRPORT INFO** üè¢\n"
            response += "="*60
            response += f"\n\n**Code**: {airport_code.upper()}"
            response += f"\n**Name**: {airport['name']}"
            response += f"\n**City**: {airport['city']}"
            response += f"\n**Country**: {airport['country']}"
            response += f"\n**Terminals**: {airport['terminals']}"

            return response

        except Exception as e:
            logger.error(f"Error in get_airport_information: {e}")
            return f"‚ùå Error: {str(e)}"

    @mcp_app.tool()
    async def generate_passenger_manifest(flight_id: str, date: str) -> str:
        """Generates passenger manifest for a specific flight."""
        try:
            steps = []
            steps.append("üìã **PASSENGER MANIFEST GENERATION**")
            steps.append(f"‚úàÔ∏è  Flight: {flight_id}")
            steps.append(f"üìÖ Date: {date}")
            steps.append("")

            steps.append("1Ô∏è‚É£ Retrieving flight details...")
            flight = await api_request("flights", f"/flights/{flight_id}")

            if "error" in flight:
                steps.append("   ‚ùå Flight not found")
                return "\n".join(steps)

            steps.append(f"   ‚úÖ Route: {flight.get('origin')} ‚Üí {flight.get('destination')}")

            steps.append("\n2Ô∏è‚É£ Fetching bookings for this flight...")
            bookings = await api_request("bookings", f"/bookings?flight_id={flight_id}")

            if isinstance(bookings, list):
                passenger_count = len(bookings)
                steps.append(f"   ‚úÖ Found {passenger_count} confirmed passengers")
            else:
                passenger_count = 0
                steps.append("   ‚ÑπÔ∏è  No bookings found (using sample data)")

            steps.append("\n3Ô∏è‚É£ Generating manifest...")
            steps.append(f"   ‚úÖ Manifest generated")
            steps.append(f"   ‚úÖ Total passengers: {passenger_count}")

            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += "\n**PASSENGER MANIFEST** üìã\n"
            response += "="*60
            response += f"\n\n**Flight**: {flight_id}"
            response += f"\n**Date**: {date}"
            response += f"\n**Route**: {flight.get('origin')} ‚Üí {flight.get('destination')}"
            response += f"\n**Total Passengers**: {passenger_count}"
            response += f"\n**Status**: Ready for boarding"

            return response

        except Exception as e:
            logger.error(f"Error in generate_passenger_manifest: {e}")
            return f"‚ùå Error: {str(e)}"

    @mcp_app.tool()
    async def search_available_flights(
        origin: str = None,
        destination: str = None,
        date: str = None
    ) -> str:
        """Searches for flights with available seats (availability check)."""
        try:
            steps = []
            steps.append("üîç **SEARCHING AVAILABLE FLIGHTS**")
            if origin:
                steps.append(f"üìç From: {origin}")
            if destination:
                steps.append(f"üìç To: {destination}")
            if date:
                steps.append(f"üìÖ Date: {date}")
            steps.append("")

            steps.append("1Ô∏è‚É£ Querying flight inventory...")
            flights = await api_request("flights", "/flights")

            if "error" in flights or not isinstance(flights, list):
                steps.append("   ‚ùå Unable to retrieve flights")
                return "\n".join(steps)

            # Filter flights
            available = flights
            if origin:
                available = [f for f in available if f.get("origin", "").upper() == origin.upper()]
            if destination:
                available = [f for f in available if f.get("destination", "").upper() == destination.upper()]
            if date:
                available = [f for f in available if date in f.get("departure_time", "")]

            # Only show flights with available seats
            available = [f for f in available if f.get("available_seats", 0) > 0]

            steps.append(f"   ‚úÖ Found {len(available)} available flights")

            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += "\n**AVAILABLE FLIGHTS**\n"
            response += "="*60

            for i, flight in enumerate(available[:10], 1):
                response += f"\n\n{i}. {flight.get('flight_id')}: {flight.get('origin')} ‚Üí {flight.get('destination')}"
                response += f"\n   Departure: {flight.get('departure_time')}"
                response += f"\n   Available seats: {flight.get('available_seats', 'N/A')}"
                response += f"\n   Status: {flight.get('status', 'On-time')}"

            if not available:
                response += "\n\nNo flights available matching criteria"

            return response

        except Exception as e:
            logger.error(f"Error in search_available_flights: {e}")
            return f"‚ùå Error: {str(e)}"

    @mcp_app.tool()
    async def find_flights_to_destination(destination: str, date: str = None) -> str:
        """Finds all flights to a specific destination."""
        try:
            steps = []
            steps.append(f"üîç **FLIGHTS TO {destination}**")
            if date:
                steps.append(f"üìÖ Date: {date}")
            steps.append("")

            steps.append("1Ô∏è‚É£ Searching for flights...")
            flights = await api_request("flights", "/flights")

            if "error" in flights or not isinstance(flights, list):
                steps.append("   ‚ùå Unable to retrieve flights")
                return "\n".join(steps)

            # Filter by destination
            to_dest = [f for f in flights if f.get("destination", "").upper() == destination.upper()]
            if date:
                to_dest = [f for f in to_dest if date in f.get("departure_time", "")]

            steps.append(f"   ‚úÖ Found {len(to_dest)} flights to {destination}")

            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += f"\n**FLIGHTS TO {destination}**\n"
            response += "="*60

            for i, flight in enumerate(to_dest[:10], 1):
                response += f"\n\n{i}. {flight.get('flight_id')}: {flight.get('origin')} ‚Üí {destination}"
                response += f"\n   Departure: {flight.get('departure_time')}"
                response += f"\n   Arrival: {flight.get('arrival_time')}"
                response += f"\n   Status: {flight.get('status', 'On-time')}"

            return response

        except Exception as e:
            logger.error(f"Error in find_flights_to_destination: {e}")
            return f"‚ùå Error: {str(e)}"

    @mcp_app.tool()
    async def find_flights_from_origin(origin: str, date: str = None) -> str:
        """Finds all flights from a specific origin."""
        try:
            steps = []
            steps.append(f"üîç **FLIGHTS FROM {origin}**")
            if date:
                steps.append(f"üìÖ Date: {date}")
            steps.append("")

            steps.append("1Ô∏è‚É£ Searching for flights...")
            flights = await api_request("flights", "/flights")

            if "error" in flights or not isinstance(flights, list):
                steps.append("   ‚ùå Unable to retrieve flights")
                return "\n".join(steps)

            # Filter by origin
            from_origin = [f for f in flights if f.get("origin", "").upper() == origin.upper()]
            if date:
                from_origin = [f for f in from_origin if date in f.get("departure_time", "")]

            steps.append(f"   ‚úÖ Found {len(from_origin)} flights from {origin}")

            response = "\n".join(steps)
            response += "\n\n" + "="*60
            response += f"\n**FLIGHTS FROM {origin}**\n"
            response += "="*60

            for i, flight in enumerate(from_origin[:10], 1):
                response += f"\n\n{i}. {flight.get('flight_id')}: {origin} ‚Üí {flight.get('destination')}"
                response += f"\n   Departure: {flight.get('departure_time')}"
                response += f"\n   Arrival: {flight.get('arrival_time')}"
                response += f"\n   Status: {flight.get('status', 'On-time')}"

            return response

        except Exception as e:
            logger.error(f"Error in find_flights_from_origin: {e}")
            return f"‚ùå Error: {str(e)}"

    # ===== APPLICATION SETUP =====

    if __name__ == "__main__":
        logger.info("Starting Airlines MCP Server with FastMCP...")
        app = mcp_app.streamable_http_app()

        # Add middleware to extract Authorization header
        app.add_middleware(AuthTokenMiddleware)

        uvicorn.run(app, host="0.0.0.0", port=8080)


  requirements.txt: |
    mcp==1.22.0
    uvicorn>=0.32.1
    aiohttp==3.9.1
    anyio==4.11.0
    httpx>=0.27.0

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: airlines-mcp
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: airlines-mcp
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      app: airlines-mcp
  template:
    metadata:
      labels:
        app: airlines-mcp
        component: mcp
    spec:
      containers:
        - name: mcp-server
          image: "{{ .Values.mcpImage.repository }}:{{ .Values.mcpImage.tag }}"
          imagePullPolicy: {{ .Values.mcpImage.pullPolicy }}
          ports:
            - containerPort: 8080
          command: ["/bin/sh", "-c"]
          args:
            - |
              pip install --no-cache-dir -r /app/requirements.txt && \
              python /app/main.py
          volumeMounts:
            - name: mcp-code
              mountPath: /app
          resources:
            {{- toYaml .Values.resources | nindent 12 }}
      volumes:
        - name: mcp-code
          configMap:
            name: airlines-mcp-server

---
apiVersion: v1
kind: Service
metadata:
  name: airlines-mcp
  namespace: airlines
  labels:
    {{- include "airlines.labels" . | nindent 4 }}
    component: airlines-mcp
spec:
  type: ClusterIP
  ports:
    - port: 8080
      targetPort: 8080
      name: mcp
  selector:
    app: airlines-mcp
